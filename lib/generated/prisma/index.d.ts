
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model UserProfile
 * 
 */
export type UserProfile = $Result.DefaultSelection<Prisma.$UserProfilePayload>
/**
 * Model UserPassword
 * 
 */
export type UserPassword = $Result.DefaultSelection<Prisma.$UserPasswordPayload>
/**
 * Model TwoFactorAuth
 * 
 */
export type TwoFactorAuth = $Result.DefaultSelection<Prisma.$TwoFactorAuthPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model LoginAttempt
 * 
 */
export type LoginAttempt = $Result.DefaultSelection<Prisma.$LoginAttemptPayload>
/**
 * Model Sport
 * 
 */
export type Sport = $Result.DefaultSelection<Prisma.$SportPayload>
/**
 * Model League
 * 
 */
export type League = $Result.DefaultSelection<Prisma.$LeaguePayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model Game
 * 
 */
export type Game = $Result.DefaultSelection<Prisma.$GamePayload>
/**
 * Model BetMarket
 * 
 */
export type BetMarket = $Result.DefaultSelection<Prisma.$BetMarketPayload>
/**
 * Model BetSelection
 * 
 */
export type BetSelection = $Result.DefaultSelection<Prisma.$BetSelectionPayload>
/**
 * Model Bet
 * 
 */
export type Bet = $Result.DefaultSelection<Prisma.$BetPayload>
/**
 * Model BetSelectionBet
 * 
 */
export type BetSelectionBet = $Result.DefaultSelection<Prisma.$BetSelectionBetPayload>
/**
 * Model FinancialAccount
 * 
 */
export type FinancialAccount = $Result.DefaultSelection<Prisma.$FinancialAccountPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model PaymentMethod
 * 
 */
export type PaymentMethod = $Result.DefaultSelection<Prisma.$PaymentMethodPayload>
/**
 * Model Deposit
 * 
 */
export type Deposit = $Result.DefaultSelection<Prisma.$DepositPayload>
/**
 * Model Withdrawal
 * 
 */
export type Withdrawal = $Result.DefaultSelection<Prisma.$WithdrawalPayload>
/**
 * Model FraudEvent
 * 
 */
export type FraudEvent = $Result.DefaultSelection<Prisma.$FraudEventPayload>
/**
 * Model BettingPattern
 * 
 */
export type BettingPattern = $Result.DefaultSelection<Prisma.$BettingPatternPayload>
/**
 * Model AccountActivityLog
 * 
 */
export type AccountActivityLog = $Result.DefaultSelection<Prisma.$AccountActivityLogPayload>
/**
 * Model DeviceRegistry
 * 
 */
export type DeviceRegistry = $Result.DefaultSelection<Prisma.$DeviceRegistryPayload>
/**
 * Model IpAddress
 * 
 */
export type IpAddress = $Result.DefaultSelection<Prisma.$IpAddressPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model GdprConsent
 * 
 */
export type GdprConsent = $Result.DefaultSelection<Prisma.$GdprConsentPayload>
/**
 * Model DataDeletionRequest
 * 
 */
export type DataDeletionRequest = $Result.DefaultSelection<Prisma.$DataDeletionRequestPayload>
/**
 * Model DataExportRequest
 * 
 */
export type DataExportRequest = $Result.DefaultSelection<Prisma.$DataExportRequestPayload>
/**
 * Model SecurityAlert
 * 
 */
export type SecurityAlert = $Result.DefaultSelection<Prisma.$SecurityAlertPayload>
/**
 * Model Promotion
 * 
 */
export type Promotion = $Result.DefaultSelection<Prisma.$PromotionPayload>
/**
 * Model UserBonus
 * 
 */
export type UserBonus = $Result.DefaultSelection<Prisma.$UserBonusPayload>
/**
 * Model CurrentOdds
 * 
 */
export type CurrentOdds = $Result.DefaultSelection<Prisma.$CurrentOddsPayload>
/**
 * Model OddsSnapshot
 * 
 */
export type OddsSnapshot = $Result.DefaultSelection<Prisma.$OddsSnapshotPayload>
/**
 * Model OddsSyncStatus
 * 
 */
export type OddsSyncStatus = $Result.DefaultSelection<Prisma.$OddsSyncStatusPayload>
/**
 * Model OddsChangeEvent
 * 
 */
export type OddsChangeEvent = $Result.DefaultSelection<Prisma.$OddsChangeEventPayload>
/**
 * Model ApiOddsSnapshot
 * 
 */
export type ApiOddsSnapshot = $Result.DefaultSelection<Prisma.$ApiOddsSnapshotPayload>
/**
 * Model OddsAuditLog
 * 
 */
export type OddsAuditLog = $Result.DefaultSelection<Prisma.$OddsAuditLogPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPassword`: Exposes CRUD operations for the **UserPassword** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPasswords
    * const userPasswords = await prisma.userPassword.findMany()
    * ```
    */
  get userPassword(): Prisma.UserPasswordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.twoFactorAuth`: Exposes CRUD operations for the **TwoFactorAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwoFactorAuths
    * const twoFactorAuths = await prisma.twoFactorAuth.findMany()
    * ```
    */
  get twoFactorAuth(): Prisma.TwoFactorAuthDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loginAttempt`: Exposes CRUD operations for the **LoginAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoginAttempts
    * const loginAttempts = await prisma.loginAttempt.findMany()
    * ```
    */
  get loginAttempt(): Prisma.LoginAttemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sport`: Exposes CRUD operations for the **Sport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sports
    * const sports = await prisma.sport.findMany()
    * ```
    */
  get sport(): Prisma.SportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.league`: Exposes CRUD operations for the **League** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leagues
    * const leagues = await prisma.league.findMany()
    * ```
    */
  get league(): Prisma.LeagueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.game`: Exposes CRUD operations for the **Game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.game.findMany()
    * ```
    */
  get game(): Prisma.GameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.betMarket`: Exposes CRUD operations for the **BetMarket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BetMarkets
    * const betMarkets = await prisma.betMarket.findMany()
    * ```
    */
  get betMarket(): Prisma.BetMarketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.betSelection`: Exposes CRUD operations for the **BetSelection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BetSelections
    * const betSelections = await prisma.betSelection.findMany()
    * ```
    */
  get betSelection(): Prisma.BetSelectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bet`: Exposes CRUD operations for the **Bet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bets
    * const bets = await prisma.bet.findMany()
    * ```
    */
  get bet(): Prisma.BetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.betSelectionBet`: Exposes CRUD operations for the **BetSelectionBet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BetSelectionBets
    * const betSelectionBets = await prisma.betSelectionBet.findMany()
    * ```
    */
  get betSelectionBet(): Prisma.BetSelectionBetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.financialAccount`: Exposes CRUD operations for the **FinancialAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinancialAccounts
    * const financialAccounts = await prisma.financialAccount.findMany()
    * ```
    */
  get financialAccount(): Prisma.FinancialAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentMethod`: Exposes CRUD operations for the **PaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethods
    * const paymentMethods = await prisma.paymentMethod.findMany()
    * ```
    */
  get paymentMethod(): Prisma.PaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deposit`: Exposes CRUD operations for the **Deposit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deposits
    * const deposits = await prisma.deposit.findMany()
    * ```
    */
  get deposit(): Prisma.DepositDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.withdrawal`: Exposes CRUD operations for the **Withdrawal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Withdrawals
    * const withdrawals = await prisma.withdrawal.findMany()
    * ```
    */
  get withdrawal(): Prisma.WithdrawalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fraudEvent`: Exposes CRUD operations for the **FraudEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FraudEvents
    * const fraudEvents = await prisma.fraudEvent.findMany()
    * ```
    */
  get fraudEvent(): Prisma.FraudEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bettingPattern`: Exposes CRUD operations for the **BettingPattern** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BettingPatterns
    * const bettingPatterns = await prisma.bettingPattern.findMany()
    * ```
    */
  get bettingPattern(): Prisma.BettingPatternDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accountActivityLog`: Exposes CRUD operations for the **AccountActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountActivityLogs
    * const accountActivityLogs = await prisma.accountActivityLog.findMany()
    * ```
    */
  get accountActivityLog(): Prisma.AccountActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceRegistry`: Exposes CRUD operations for the **DeviceRegistry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceRegistries
    * const deviceRegistries = await prisma.deviceRegistry.findMany()
    * ```
    */
  get deviceRegistry(): Prisma.DeviceRegistryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ipAddress`: Exposes CRUD operations for the **IpAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IpAddresses
    * const ipAddresses = await prisma.ipAddress.findMany()
    * ```
    */
  get ipAddress(): Prisma.IpAddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gdprConsent`: Exposes CRUD operations for the **GdprConsent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GdprConsents
    * const gdprConsents = await prisma.gdprConsent.findMany()
    * ```
    */
  get gdprConsent(): Prisma.GdprConsentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataDeletionRequest`: Exposes CRUD operations for the **DataDeletionRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataDeletionRequests
    * const dataDeletionRequests = await prisma.dataDeletionRequest.findMany()
    * ```
    */
  get dataDeletionRequest(): Prisma.DataDeletionRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataExportRequest`: Exposes CRUD operations for the **DataExportRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataExportRequests
    * const dataExportRequests = await prisma.dataExportRequest.findMany()
    * ```
    */
  get dataExportRequest(): Prisma.DataExportRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.securityAlert`: Exposes CRUD operations for the **SecurityAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityAlerts
    * const securityAlerts = await prisma.securityAlert.findMany()
    * ```
    */
  get securityAlert(): Prisma.SecurityAlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promotion`: Exposes CRUD operations for the **Promotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Promotions
    * const promotions = await prisma.promotion.findMany()
    * ```
    */
  get promotion(): Prisma.PromotionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userBonus`: Exposes CRUD operations for the **UserBonus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBonuses
    * const userBonuses = await prisma.userBonus.findMany()
    * ```
    */
  get userBonus(): Prisma.UserBonusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.currentOdds`: Exposes CRUD operations for the **CurrentOdds** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CurrentOdds
    * const currentOdds = await prisma.currentOdds.findMany()
    * ```
    */
  get currentOdds(): Prisma.CurrentOddsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.oddsSnapshot`: Exposes CRUD operations for the **OddsSnapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OddsSnapshots
    * const oddsSnapshots = await prisma.oddsSnapshot.findMany()
    * ```
    */
  get oddsSnapshot(): Prisma.OddsSnapshotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.oddsSyncStatus`: Exposes CRUD operations for the **OddsSyncStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OddsSyncStatuses
    * const oddsSyncStatuses = await prisma.oddsSyncStatus.findMany()
    * ```
    */
  get oddsSyncStatus(): Prisma.OddsSyncStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.oddsChangeEvent`: Exposes CRUD operations for the **OddsChangeEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OddsChangeEvents
    * const oddsChangeEvents = await prisma.oddsChangeEvent.findMany()
    * ```
    */
  get oddsChangeEvent(): Prisma.OddsChangeEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiOddsSnapshot`: Exposes CRUD operations for the **ApiOddsSnapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiOddsSnapshots
    * const apiOddsSnapshots = await prisma.apiOddsSnapshot.findMany()
    * ```
    */
  get apiOddsSnapshot(): Prisma.ApiOddsSnapshotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.oddsAuditLog`: Exposes CRUD operations for the **OddsAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OddsAuditLogs
    * const oddsAuditLogs = await prisma.oddsAuditLog.findMany()
    * ```
    */
  get oddsAuditLog(): Prisma.OddsAuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    UserProfile: 'UserProfile',
    UserPassword: 'UserPassword',
    TwoFactorAuth: 'TwoFactorAuth',
    UserSession: 'UserSession',
    LoginAttempt: 'LoginAttempt',
    Sport: 'Sport',
    League: 'League',
    Team: 'Team',
    Game: 'Game',
    BetMarket: 'BetMarket',
    BetSelection: 'BetSelection',
    Bet: 'Bet',
    BetSelectionBet: 'BetSelectionBet',
    FinancialAccount: 'FinancialAccount',
    Transaction: 'Transaction',
    PaymentMethod: 'PaymentMethod',
    Deposit: 'Deposit',
    Withdrawal: 'Withdrawal',
    FraudEvent: 'FraudEvent',
    BettingPattern: 'BettingPattern',
    AccountActivityLog: 'AccountActivityLog',
    DeviceRegistry: 'DeviceRegistry',
    IpAddress: 'IpAddress',
    AuditLog: 'AuditLog',
    GdprConsent: 'GdprConsent',
    DataDeletionRequest: 'DataDeletionRequest',
    DataExportRequest: 'DataExportRequest',
    SecurityAlert: 'SecurityAlert',
    Promotion: 'Promotion',
    UserBonus: 'UserBonus',
    CurrentOdds: 'CurrentOdds',
    OddsSnapshot: 'OddsSnapshot',
    OddsSyncStatus: 'OddsSyncStatus',
    OddsChangeEvent: 'OddsChangeEvent',
    ApiOddsSnapshot: 'ApiOddsSnapshot',
    OddsAuditLog: 'OddsAuditLog',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "account" | "session" | "verificationToken" | "userProfile" | "userPassword" | "twoFactorAuth" | "userSession" | "loginAttempt" | "sport" | "league" | "team" | "game" | "betMarket" | "betSelection" | "bet" | "betSelectionBet" | "financialAccount" | "transaction" | "paymentMethod" | "deposit" | "withdrawal" | "fraudEvent" | "bettingPattern" | "accountActivityLog" | "deviceRegistry" | "ipAddress" | "auditLog" | "gdprConsent" | "dataDeletionRequest" | "dataExportRequest" | "securityAlert" | "promotion" | "userBonus" | "currentOdds" | "oddsSnapshot" | "oddsSyncStatus" | "oddsChangeEvent" | "apiOddsSnapshot" | "oddsAuditLog" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      UserProfile: {
        payload: Prisma.$UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      UserPassword: {
        payload: Prisma.$UserPasswordPayload<ExtArgs>
        fields: Prisma.UserPasswordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPasswordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPasswordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPasswordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPasswordPayload>
          }
          findFirst: {
            args: Prisma.UserPasswordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPasswordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPasswordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPasswordPayload>
          }
          findMany: {
            args: Prisma.UserPasswordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPasswordPayload>[]
          }
          create: {
            args: Prisma.UserPasswordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPasswordPayload>
          }
          createMany: {
            args: Prisma.UserPasswordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPasswordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPasswordPayload>[]
          }
          delete: {
            args: Prisma.UserPasswordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPasswordPayload>
          }
          update: {
            args: Prisma.UserPasswordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPasswordPayload>
          }
          deleteMany: {
            args: Prisma.UserPasswordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPasswordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPasswordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPasswordPayload>[]
          }
          upsert: {
            args: Prisma.UserPasswordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPasswordPayload>
          }
          aggregate: {
            args: Prisma.UserPasswordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPassword>
          }
          groupBy: {
            args: Prisma.UserPasswordGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPasswordGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPasswordCountArgs<ExtArgs>
            result: $Utils.Optional<UserPasswordCountAggregateOutputType> | number
          }
        }
      }
      TwoFactorAuth: {
        payload: Prisma.$TwoFactorAuthPayload<ExtArgs>
        fields: Prisma.TwoFactorAuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TwoFactorAuthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TwoFactorAuthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>
          }
          findFirst: {
            args: Prisma.TwoFactorAuthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TwoFactorAuthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>
          }
          findMany: {
            args: Prisma.TwoFactorAuthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>[]
          }
          create: {
            args: Prisma.TwoFactorAuthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>
          }
          createMany: {
            args: Prisma.TwoFactorAuthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TwoFactorAuthCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>[]
          }
          delete: {
            args: Prisma.TwoFactorAuthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>
          }
          update: {
            args: Prisma.TwoFactorAuthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>
          }
          deleteMany: {
            args: Prisma.TwoFactorAuthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TwoFactorAuthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TwoFactorAuthUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>[]
          }
          upsert: {
            args: Prisma.TwoFactorAuthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>
          }
          aggregate: {
            args: Prisma.TwoFactorAuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTwoFactorAuth>
          }
          groupBy: {
            args: Prisma.TwoFactorAuthGroupByArgs<ExtArgs>
            result: $Utils.Optional<TwoFactorAuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.TwoFactorAuthCountArgs<ExtArgs>
            result: $Utils.Optional<TwoFactorAuthCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      LoginAttempt: {
        payload: Prisma.$LoginAttemptPayload<ExtArgs>
        fields: Prisma.LoginAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoginAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoginAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAttemptPayload>
          }
          findFirst: {
            args: Prisma.LoginAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoginAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAttemptPayload>
          }
          findMany: {
            args: Prisma.LoginAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAttemptPayload>[]
          }
          create: {
            args: Prisma.LoginAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAttemptPayload>
          }
          createMany: {
            args: Prisma.LoginAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoginAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAttemptPayload>[]
          }
          delete: {
            args: Prisma.LoginAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAttemptPayload>
          }
          update: {
            args: Prisma.LoginAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAttemptPayload>
          }
          deleteMany: {
            args: Prisma.LoginAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoginAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoginAttemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAttemptPayload>[]
          }
          upsert: {
            args: Prisma.LoginAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAttemptPayload>
          }
          aggregate: {
            args: Prisma.LoginAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoginAttempt>
          }
          groupBy: {
            args: Prisma.LoginAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoginAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoginAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<LoginAttemptCountAggregateOutputType> | number
          }
        }
      }
      Sport: {
        payload: Prisma.$SportPayload<ExtArgs>
        fields: Prisma.SportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          findFirst: {
            args: Prisma.SportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          findMany: {
            args: Prisma.SportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>[]
          }
          create: {
            args: Prisma.SportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          createMany: {
            args: Prisma.SportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>[]
          }
          delete: {
            args: Prisma.SportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          update: {
            args: Prisma.SportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          deleteMany: {
            args: Prisma.SportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>[]
          }
          upsert: {
            args: Prisma.SportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          aggregate: {
            args: Prisma.SportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSport>
          }
          groupBy: {
            args: Prisma.SportGroupByArgs<ExtArgs>
            result: $Utils.Optional<SportGroupByOutputType>[]
          }
          count: {
            args: Prisma.SportCountArgs<ExtArgs>
            result: $Utils.Optional<SportCountAggregateOutputType> | number
          }
        }
      }
      League: {
        payload: Prisma.$LeaguePayload<ExtArgs>
        fields: Prisma.LeagueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeagueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeagueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          findFirst: {
            args: Prisma.LeagueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeagueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          findMany: {
            args: Prisma.LeagueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>[]
          }
          create: {
            args: Prisma.LeagueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          createMany: {
            args: Prisma.LeagueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeagueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>[]
          }
          delete: {
            args: Prisma.LeagueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          update: {
            args: Prisma.LeagueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          deleteMany: {
            args: Prisma.LeagueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeagueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeagueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>[]
          }
          upsert: {
            args: Prisma.LeagueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          aggregate: {
            args: Prisma.LeagueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeague>
          }
          groupBy: {
            args: Prisma.LeagueGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeagueGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeagueCountArgs<ExtArgs>
            result: $Utils.Optional<LeagueCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      Game: {
        payload: Prisma.$GamePayload<ExtArgs>
        fields: Prisma.GameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findFirst: {
            args: Prisma.GameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findMany: {
            args: Prisma.GameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          create: {
            args: Prisma.GameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          createMany: {
            args: Prisma.GameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          delete: {
            args: Prisma.GameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          update: {
            args: Prisma.GameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          deleteMany: {
            args: Prisma.GameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          upsert: {
            args: Prisma.GameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          aggregate: {
            args: Prisma.GameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame>
          }
          groupBy: {
            args: Prisma.GameGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameCountArgs<ExtArgs>
            result: $Utils.Optional<GameCountAggregateOutputType> | number
          }
        }
      }
      BetMarket: {
        payload: Prisma.$BetMarketPayload<ExtArgs>
        fields: Prisma.BetMarketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BetMarketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetMarketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BetMarketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetMarketPayload>
          }
          findFirst: {
            args: Prisma.BetMarketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetMarketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BetMarketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetMarketPayload>
          }
          findMany: {
            args: Prisma.BetMarketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetMarketPayload>[]
          }
          create: {
            args: Prisma.BetMarketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetMarketPayload>
          }
          createMany: {
            args: Prisma.BetMarketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BetMarketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetMarketPayload>[]
          }
          delete: {
            args: Prisma.BetMarketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetMarketPayload>
          }
          update: {
            args: Prisma.BetMarketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetMarketPayload>
          }
          deleteMany: {
            args: Prisma.BetMarketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BetMarketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BetMarketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetMarketPayload>[]
          }
          upsert: {
            args: Prisma.BetMarketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetMarketPayload>
          }
          aggregate: {
            args: Prisma.BetMarketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBetMarket>
          }
          groupBy: {
            args: Prisma.BetMarketGroupByArgs<ExtArgs>
            result: $Utils.Optional<BetMarketGroupByOutputType>[]
          }
          count: {
            args: Prisma.BetMarketCountArgs<ExtArgs>
            result: $Utils.Optional<BetMarketCountAggregateOutputType> | number
          }
        }
      }
      BetSelection: {
        payload: Prisma.$BetSelectionPayload<ExtArgs>
        fields: Prisma.BetSelectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BetSelectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BetSelectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionPayload>
          }
          findFirst: {
            args: Prisma.BetSelectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BetSelectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionPayload>
          }
          findMany: {
            args: Prisma.BetSelectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionPayload>[]
          }
          create: {
            args: Prisma.BetSelectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionPayload>
          }
          createMany: {
            args: Prisma.BetSelectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BetSelectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionPayload>[]
          }
          delete: {
            args: Prisma.BetSelectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionPayload>
          }
          update: {
            args: Prisma.BetSelectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionPayload>
          }
          deleteMany: {
            args: Prisma.BetSelectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BetSelectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BetSelectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionPayload>[]
          }
          upsert: {
            args: Prisma.BetSelectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionPayload>
          }
          aggregate: {
            args: Prisma.BetSelectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBetSelection>
          }
          groupBy: {
            args: Prisma.BetSelectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BetSelectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BetSelectionCountArgs<ExtArgs>
            result: $Utils.Optional<BetSelectionCountAggregateOutputType> | number
          }
        }
      }
      Bet: {
        payload: Prisma.$BetPayload<ExtArgs>
        fields: Prisma.BetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>
          }
          findFirst: {
            args: Prisma.BetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>
          }
          findMany: {
            args: Prisma.BetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>[]
          }
          create: {
            args: Prisma.BetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>
          }
          createMany: {
            args: Prisma.BetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>[]
          }
          delete: {
            args: Prisma.BetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>
          }
          update: {
            args: Prisma.BetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>
          }
          deleteMany: {
            args: Prisma.BetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>[]
          }
          upsert: {
            args: Prisma.BetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>
          }
          aggregate: {
            args: Prisma.BetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBet>
          }
          groupBy: {
            args: Prisma.BetGroupByArgs<ExtArgs>
            result: $Utils.Optional<BetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BetCountArgs<ExtArgs>
            result: $Utils.Optional<BetCountAggregateOutputType> | number
          }
        }
      }
      BetSelectionBet: {
        payload: Prisma.$BetSelectionBetPayload<ExtArgs>
        fields: Prisma.BetSelectionBetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BetSelectionBetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionBetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BetSelectionBetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionBetPayload>
          }
          findFirst: {
            args: Prisma.BetSelectionBetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionBetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BetSelectionBetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionBetPayload>
          }
          findMany: {
            args: Prisma.BetSelectionBetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionBetPayload>[]
          }
          create: {
            args: Prisma.BetSelectionBetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionBetPayload>
          }
          createMany: {
            args: Prisma.BetSelectionBetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BetSelectionBetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionBetPayload>[]
          }
          delete: {
            args: Prisma.BetSelectionBetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionBetPayload>
          }
          update: {
            args: Prisma.BetSelectionBetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionBetPayload>
          }
          deleteMany: {
            args: Prisma.BetSelectionBetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BetSelectionBetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BetSelectionBetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionBetPayload>[]
          }
          upsert: {
            args: Prisma.BetSelectionBetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetSelectionBetPayload>
          }
          aggregate: {
            args: Prisma.BetSelectionBetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBetSelectionBet>
          }
          groupBy: {
            args: Prisma.BetSelectionBetGroupByArgs<ExtArgs>
            result: $Utils.Optional<BetSelectionBetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BetSelectionBetCountArgs<ExtArgs>
            result: $Utils.Optional<BetSelectionBetCountAggregateOutputType> | number
          }
        }
      }
      FinancialAccount: {
        payload: Prisma.$FinancialAccountPayload<ExtArgs>
        fields: Prisma.FinancialAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinancialAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinancialAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAccountPayload>
          }
          findFirst: {
            args: Prisma.FinancialAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinancialAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAccountPayload>
          }
          findMany: {
            args: Prisma.FinancialAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAccountPayload>[]
          }
          create: {
            args: Prisma.FinancialAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAccountPayload>
          }
          createMany: {
            args: Prisma.FinancialAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinancialAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAccountPayload>[]
          }
          delete: {
            args: Prisma.FinancialAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAccountPayload>
          }
          update: {
            args: Prisma.FinancialAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAccountPayload>
          }
          deleteMany: {
            args: Prisma.FinancialAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinancialAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FinancialAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAccountPayload>[]
          }
          upsert: {
            args: Prisma.FinancialAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialAccountPayload>
          }
          aggregate: {
            args: Prisma.FinancialAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancialAccount>
          }
          groupBy: {
            args: Prisma.FinancialAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancialAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinancialAccountCountArgs<ExtArgs>
            result: $Utils.Optional<FinancialAccountCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethod: {
        payload: Prisma.$PaymentMethodPayload<ExtArgs>
        fields: Prisma.PaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          delete: {
            args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          update: {
            args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentMethodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          upsert: {
            args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethod>
          }
          groupBy: {
            args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      Deposit: {
        payload: Prisma.$DepositPayload<ExtArgs>
        fields: Prisma.DepositFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepositFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepositFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          findFirst: {
            args: Prisma.DepositFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepositFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          findMany: {
            args: Prisma.DepositFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>[]
          }
          create: {
            args: Prisma.DepositCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          createMany: {
            args: Prisma.DepositCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepositCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>[]
          }
          delete: {
            args: Prisma.DepositDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          update: {
            args: Prisma.DepositUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          deleteMany: {
            args: Prisma.DepositDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepositUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepositUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>[]
          }
          upsert: {
            args: Prisma.DepositUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          aggregate: {
            args: Prisma.DepositAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeposit>
          }
          groupBy: {
            args: Prisma.DepositGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepositGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepositCountArgs<ExtArgs>
            result: $Utils.Optional<DepositCountAggregateOutputType> | number
          }
        }
      }
      Withdrawal: {
        payload: Prisma.$WithdrawalPayload<ExtArgs>
        fields: Prisma.WithdrawalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WithdrawalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WithdrawalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          findFirst: {
            args: Prisma.WithdrawalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WithdrawalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          findMany: {
            args: Prisma.WithdrawalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>[]
          }
          create: {
            args: Prisma.WithdrawalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          createMany: {
            args: Prisma.WithdrawalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WithdrawalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>[]
          }
          delete: {
            args: Prisma.WithdrawalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          update: {
            args: Prisma.WithdrawalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          deleteMany: {
            args: Prisma.WithdrawalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WithdrawalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WithdrawalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>[]
          }
          upsert: {
            args: Prisma.WithdrawalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          aggregate: {
            args: Prisma.WithdrawalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWithdrawal>
          }
          groupBy: {
            args: Prisma.WithdrawalGroupByArgs<ExtArgs>
            result: $Utils.Optional<WithdrawalGroupByOutputType>[]
          }
          count: {
            args: Prisma.WithdrawalCountArgs<ExtArgs>
            result: $Utils.Optional<WithdrawalCountAggregateOutputType> | number
          }
        }
      }
      FraudEvent: {
        payload: Prisma.$FraudEventPayload<ExtArgs>
        fields: Prisma.FraudEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FraudEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FraudEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudEventPayload>
          }
          findFirst: {
            args: Prisma.FraudEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FraudEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudEventPayload>
          }
          findMany: {
            args: Prisma.FraudEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudEventPayload>[]
          }
          create: {
            args: Prisma.FraudEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudEventPayload>
          }
          createMany: {
            args: Prisma.FraudEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FraudEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudEventPayload>[]
          }
          delete: {
            args: Prisma.FraudEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudEventPayload>
          }
          update: {
            args: Prisma.FraudEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudEventPayload>
          }
          deleteMany: {
            args: Prisma.FraudEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FraudEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FraudEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudEventPayload>[]
          }
          upsert: {
            args: Prisma.FraudEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudEventPayload>
          }
          aggregate: {
            args: Prisma.FraudEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFraudEvent>
          }
          groupBy: {
            args: Prisma.FraudEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<FraudEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.FraudEventCountArgs<ExtArgs>
            result: $Utils.Optional<FraudEventCountAggregateOutputType> | number
          }
        }
      }
      BettingPattern: {
        payload: Prisma.$BettingPatternPayload<ExtArgs>
        fields: Prisma.BettingPatternFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BettingPatternFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPatternPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BettingPatternFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPatternPayload>
          }
          findFirst: {
            args: Prisma.BettingPatternFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPatternPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BettingPatternFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPatternPayload>
          }
          findMany: {
            args: Prisma.BettingPatternFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPatternPayload>[]
          }
          create: {
            args: Prisma.BettingPatternCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPatternPayload>
          }
          createMany: {
            args: Prisma.BettingPatternCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BettingPatternCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPatternPayload>[]
          }
          delete: {
            args: Prisma.BettingPatternDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPatternPayload>
          }
          update: {
            args: Prisma.BettingPatternUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPatternPayload>
          }
          deleteMany: {
            args: Prisma.BettingPatternDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BettingPatternUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BettingPatternUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPatternPayload>[]
          }
          upsert: {
            args: Prisma.BettingPatternUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BettingPatternPayload>
          }
          aggregate: {
            args: Prisma.BettingPatternAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBettingPattern>
          }
          groupBy: {
            args: Prisma.BettingPatternGroupByArgs<ExtArgs>
            result: $Utils.Optional<BettingPatternGroupByOutputType>[]
          }
          count: {
            args: Prisma.BettingPatternCountArgs<ExtArgs>
            result: $Utils.Optional<BettingPatternCountAggregateOutputType> | number
          }
        }
      }
      AccountActivityLog: {
        payload: Prisma.$AccountActivityLogPayload<ExtArgs>
        fields: Prisma.AccountActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountActivityLogPayload>
          }
          findFirst: {
            args: Prisma.AccountActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountActivityLogPayload>
          }
          findMany: {
            args: Prisma.AccountActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountActivityLogPayload>[]
          }
          create: {
            args: Prisma.AccountActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountActivityLogPayload>
          }
          createMany: {
            args: Prisma.AccountActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountActivityLogPayload>[]
          }
          delete: {
            args: Prisma.AccountActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountActivityLogPayload>
          }
          update: {
            args: Prisma.AccountActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.AccountActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.AccountActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountActivityLogPayload>
          }
          aggregate: {
            args: Prisma.AccountActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountActivityLog>
          }
          groupBy: {
            args: Prisma.AccountActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<AccountActivityLogCountAggregateOutputType> | number
          }
        }
      }
      DeviceRegistry: {
        payload: Prisma.$DeviceRegistryPayload<ExtArgs>
        fields: Prisma.DeviceRegistryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceRegistryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRegistryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceRegistryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRegistryPayload>
          }
          findFirst: {
            args: Prisma.DeviceRegistryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRegistryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceRegistryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRegistryPayload>
          }
          findMany: {
            args: Prisma.DeviceRegistryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRegistryPayload>[]
          }
          create: {
            args: Prisma.DeviceRegistryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRegistryPayload>
          }
          createMany: {
            args: Prisma.DeviceRegistryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceRegistryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRegistryPayload>[]
          }
          delete: {
            args: Prisma.DeviceRegistryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRegistryPayload>
          }
          update: {
            args: Prisma.DeviceRegistryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRegistryPayload>
          }
          deleteMany: {
            args: Prisma.DeviceRegistryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceRegistryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceRegistryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRegistryPayload>[]
          }
          upsert: {
            args: Prisma.DeviceRegistryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRegistryPayload>
          }
          aggregate: {
            args: Prisma.DeviceRegistryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceRegistry>
          }
          groupBy: {
            args: Prisma.DeviceRegistryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceRegistryGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceRegistryCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceRegistryCountAggregateOutputType> | number
          }
        }
      }
      IpAddress: {
        payload: Prisma.$IpAddressPayload<ExtArgs>
        fields: Prisma.IpAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IpAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IpAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpAddressPayload>
          }
          findFirst: {
            args: Prisma.IpAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IpAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpAddressPayload>
          }
          findMany: {
            args: Prisma.IpAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpAddressPayload>[]
          }
          create: {
            args: Prisma.IpAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpAddressPayload>
          }
          createMany: {
            args: Prisma.IpAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IpAddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpAddressPayload>[]
          }
          delete: {
            args: Prisma.IpAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpAddressPayload>
          }
          update: {
            args: Prisma.IpAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpAddressPayload>
          }
          deleteMany: {
            args: Prisma.IpAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IpAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IpAddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpAddressPayload>[]
          }
          upsert: {
            args: Prisma.IpAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpAddressPayload>
          }
          aggregate: {
            args: Prisma.IpAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIpAddress>
          }
          groupBy: {
            args: Prisma.IpAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<IpAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.IpAddressCountArgs<ExtArgs>
            result: $Utils.Optional<IpAddressCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      GdprConsent: {
        payload: Prisma.$GdprConsentPayload<ExtArgs>
        fields: Prisma.GdprConsentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GdprConsentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GdprConsentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GdprConsentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GdprConsentPayload>
          }
          findFirst: {
            args: Prisma.GdprConsentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GdprConsentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GdprConsentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GdprConsentPayload>
          }
          findMany: {
            args: Prisma.GdprConsentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GdprConsentPayload>[]
          }
          create: {
            args: Prisma.GdprConsentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GdprConsentPayload>
          }
          createMany: {
            args: Prisma.GdprConsentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GdprConsentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GdprConsentPayload>[]
          }
          delete: {
            args: Prisma.GdprConsentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GdprConsentPayload>
          }
          update: {
            args: Prisma.GdprConsentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GdprConsentPayload>
          }
          deleteMany: {
            args: Prisma.GdprConsentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GdprConsentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GdprConsentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GdprConsentPayload>[]
          }
          upsert: {
            args: Prisma.GdprConsentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GdprConsentPayload>
          }
          aggregate: {
            args: Prisma.GdprConsentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGdprConsent>
          }
          groupBy: {
            args: Prisma.GdprConsentGroupByArgs<ExtArgs>
            result: $Utils.Optional<GdprConsentGroupByOutputType>[]
          }
          count: {
            args: Prisma.GdprConsentCountArgs<ExtArgs>
            result: $Utils.Optional<GdprConsentCountAggregateOutputType> | number
          }
        }
      }
      DataDeletionRequest: {
        payload: Prisma.$DataDeletionRequestPayload<ExtArgs>
        fields: Prisma.DataDeletionRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataDeletionRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataDeletionRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>
          }
          findFirst: {
            args: Prisma.DataDeletionRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataDeletionRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>
          }
          findMany: {
            args: Prisma.DataDeletionRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>[]
          }
          create: {
            args: Prisma.DataDeletionRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>
          }
          createMany: {
            args: Prisma.DataDeletionRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataDeletionRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>[]
          }
          delete: {
            args: Prisma.DataDeletionRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>
          }
          update: {
            args: Prisma.DataDeletionRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>
          }
          deleteMany: {
            args: Prisma.DataDeletionRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataDeletionRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DataDeletionRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>[]
          }
          upsert: {
            args: Prisma.DataDeletionRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>
          }
          aggregate: {
            args: Prisma.DataDeletionRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataDeletionRequest>
          }
          groupBy: {
            args: Prisma.DataDeletionRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataDeletionRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataDeletionRequestCountArgs<ExtArgs>
            result: $Utils.Optional<DataDeletionRequestCountAggregateOutputType> | number
          }
        }
      }
      DataExportRequest: {
        payload: Prisma.$DataExportRequestPayload<ExtArgs>
        fields: Prisma.DataExportRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataExportRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataExportRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportRequestPayload>
          }
          findFirst: {
            args: Prisma.DataExportRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataExportRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportRequestPayload>
          }
          findMany: {
            args: Prisma.DataExportRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportRequestPayload>[]
          }
          create: {
            args: Prisma.DataExportRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportRequestPayload>
          }
          createMany: {
            args: Prisma.DataExportRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataExportRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportRequestPayload>[]
          }
          delete: {
            args: Prisma.DataExportRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportRequestPayload>
          }
          update: {
            args: Prisma.DataExportRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportRequestPayload>
          }
          deleteMany: {
            args: Prisma.DataExportRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataExportRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DataExportRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportRequestPayload>[]
          }
          upsert: {
            args: Prisma.DataExportRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportRequestPayload>
          }
          aggregate: {
            args: Prisma.DataExportRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataExportRequest>
          }
          groupBy: {
            args: Prisma.DataExportRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataExportRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataExportRequestCountArgs<ExtArgs>
            result: $Utils.Optional<DataExportRequestCountAggregateOutputType> | number
          }
        }
      }
      SecurityAlert: {
        payload: Prisma.$SecurityAlertPayload<ExtArgs>
        fields: Prisma.SecurityAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecurityAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecurityAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>
          }
          findFirst: {
            args: Prisma.SecurityAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecurityAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>
          }
          findMany: {
            args: Prisma.SecurityAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>[]
          }
          create: {
            args: Prisma.SecurityAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>
          }
          createMany: {
            args: Prisma.SecurityAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SecurityAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>[]
          }
          delete: {
            args: Prisma.SecurityAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>
          }
          update: {
            args: Prisma.SecurityAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>
          }
          deleteMany: {
            args: Prisma.SecurityAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecurityAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SecurityAlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>[]
          }
          upsert: {
            args: Prisma.SecurityAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAlertPayload>
          }
          aggregate: {
            args: Prisma.SecurityAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurityAlert>
          }
          groupBy: {
            args: Prisma.SecurityAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecurityAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecurityAlertCountArgs<ExtArgs>
            result: $Utils.Optional<SecurityAlertCountAggregateOutputType> | number
          }
        }
      }
      Promotion: {
        payload: Prisma.$PromotionPayload<ExtArgs>
        fields: Prisma.PromotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findFirst: {
            args: Prisma.PromotionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findMany: {
            args: Prisma.PromotionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          create: {
            args: Prisma.PromotionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          createMany: {
            args: Prisma.PromotionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromotionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          delete: {
            args: Prisma.PromotionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          update: {
            args: Prisma.PromotionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          deleteMany: {
            args: Prisma.PromotionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromotionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          upsert: {
            args: Prisma.PromotionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          aggregate: {
            args: Prisma.PromotionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotion>
          }
          groupBy: {
            args: Prisma.PromotionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionCountAggregateOutputType> | number
          }
        }
      }
      UserBonus: {
        payload: Prisma.$UserBonusPayload<ExtArgs>
        fields: Prisma.UserBonusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBonusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBonusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>
          }
          findFirst: {
            args: Prisma.UserBonusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBonusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>
          }
          findMany: {
            args: Prisma.UserBonusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>[]
          }
          create: {
            args: Prisma.UserBonusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>
          }
          createMany: {
            args: Prisma.UserBonusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBonusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>[]
          }
          delete: {
            args: Prisma.UserBonusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>
          }
          update: {
            args: Prisma.UserBonusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>
          }
          deleteMany: {
            args: Prisma.UserBonusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBonusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserBonusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>[]
          }
          upsert: {
            args: Prisma.UserBonusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>
          }
          aggregate: {
            args: Prisma.UserBonusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBonus>
          }
          groupBy: {
            args: Prisma.UserBonusGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBonusGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBonusCountArgs<ExtArgs>
            result: $Utils.Optional<UserBonusCountAggregateOutputType> | number
          }
        }
      }
      CurrentOdds: {
        payload: Prisma.$CurrentOddsPayload<ExtArgs>
        fields: Prisma.CurrentOddsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CurrentOddsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentOddsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CurrentOddsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentOddsPayload>
          }
          findFirst: {
            args: Prisma.CurrentOddsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentOddsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CurrentOddsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentOddsPayload>
          }
          findMany: {
            args: Prisma.CurrentOddsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentOddsPayload>[]
          }
          create: {
            args: Prisma.CurrentOddsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentOddsPayload>
          }
          createMany: {
            args: Prisma.CurrentOddsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CurrentOddsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentOddsPayload>[]
          }
          delete: {
            args: Prisma.CurrentOddsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentOddsPayload>
          }
          update: {
            args: Prisma.CurrentOddsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentOddsPayload>
          }
          deleteMany: {
            args: Prisma.CurrentOddsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CurrentOddsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CurrentOddsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentOddsPayload>[]
          }
          upsert: {
            args: Prisma.CurrentOddsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentOddsPayload>
          }
          aggregate: {
            args: Prisma.CurrentOddsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurrentOdds>
          }
          groupBy: {
            args: Prisma.CurrentOddsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurrentOddsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CurrentOddsCountArgs<ExtArgs>
            result: $Utils.Optional<CurrentOddsCountAggregateOutputType> | number
          }
        }
      }
      OddsSnapshot: {
        payload: Prisma.$OddsSnapshotPayload<ExtArgs>
        fields: Prisma.OddsSnapshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OddsSnapshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSnapshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OddsSnapshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSnapshotPayload>
          }
          findFirst: {
            args: Prisma.OddsSnapshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSnapshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OddsSnapshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSnapshotPayload>
          }
          findMany: {
            args: Prisma.OddsSnapshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSnapshotPayload>[]
          }
          create: {
            args: Prisma.OddsSnapshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSnapshotPayload>
          }
          createMany: {
            args: Prisma.OddsSnapshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OddsSnapshotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSnapshotPayload>[]
          }
          delete: {
            args: Prisma.OddsSnapshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSnapshotPayload>
          }
          update: {
            args: Prisma.OddsSnapshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSnapshotPayload>
          }
          deleteMany: {
            args: Prisma.OddsSnapshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OddsSnapshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OddsSnapshotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSnapshotPayload>[]
          }
          upsert: {
            args: Prisma.OddsSnapshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSnapshotPayload>
          }
          aggregate: {
            args: Prisma.OddsSnapshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOddsSnapshot>
          }
          groupBy: {
            args: Prisma.OddsSnapshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<OddsSnapshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.OddsSnapshotCountArgs<ExtArgs>
            result: $Utils.Optional<OddsSnapshotCountAggregateOutputType> | number
          }
        }
      }
      OddsSyncStatus: {
        payload: Prisma.$OddsSyncStatusPayload<ExtArgs>
        fields: Prisma.OddsSyncStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OddsSyncStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSyncStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OddsSyncStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSyncStatusPayload>
          }
          findFirst: {
            args: Prisma.OddsSyncStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSyncStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OddsSyncStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSyncStatusPayload>
          }
          findMany: {
            args: Prisma.OddsSyncStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSyncStatusPayload>[]
          }
          create: {
            args: Prisma.OddsSyncStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSyncStatusPayload>
          }
          createMany: {
            args: Prisma.OddsSyncStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OddsSyncStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSyncStatusPayload>[]
          }
          delete: {
            args: Prisma.OddsSyncStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSyncStatusPayload>
          }
          update: {
            args: Prisma.OddsSyncStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSyncStatusPayload>
          }
          deleteMany: {
            args: Prisma.OddsSyncStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OddsSyncStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OddsSyncStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSyncStatusPayload>[]
          }
          upsert: {
            args: Prisma.OddsSyncStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsSyncStatusPayload>
          }
          aggregate: {
            args: Prisma.OddsSyncStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOddsSyncStatus>
          }
          groupBy: {
            args: Prisma.OddsSyncStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<OddsSyncStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.OddsSyncStatusCountArgs<ExtArgs>
            result: $Utils.Optional<OddsSyncStatusCountAggregateOutputType> | number
          }
        }
      }
      OddsChangeEvent: {
        payload: Prisma.$OddsChangeEventPayload<ExtArgs>
        fields: Prisma.OddsChangeEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OddsChangeEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsChangeEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OddsChangeEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsChangeEventPayload>
          }
          findFirst: {
            args: Prisma.OddsChangeEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsChangeEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OddsChangeEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsChangeEventPayload>
          }
          findMany: {
            args: Prisma.OddsChangeEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsChangeEventPayload>[]
          }
          create: {
            args: Prisma.OddsChangeEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsChangeEventPayload>
          }
          createMany: {
            args: Prisma.OddsChangeEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OddsChangeEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsChangeEventPayload>[]
          }
          delete: {
            args: Prisma.OddsChangeEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsChangeEventPayload>
          }
          update: {
            args: Prisma.OddsChangeEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsChangeEventPayload>
          }
          deleteMany: {
            args: Prisma.OddsChangeEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OddsChangeEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OddsChangeEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsChangeEventPayload>[]
          }
          upsert: {
            args: Prisma.OddsChangeEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsChangeEventPayload>
          }
          aggregate: {
            args: Prisma.OddsChangeEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOddsChangeEvent>
          }
          groupBy: {
            args: Prisma.OddsChangeEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<OddsChangeEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.OddsChangeEventCountArgs<ExtArgs>
            result: $Utils.Optional<OddsChangeEventCountAggregateOutputType> | number
          }
        }
      }
      ApiOddsSnapshot: {
        payload: Prisma.$ApiOddsSnapshotPayload<ExtArgs>
        fields: Prisma.ApiOddsSnapshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiOddsSnapshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiOddsSnapshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiOddsSnapshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiOddsSnapshotPayload>
          }
          findFirst: {
            args: Prisma.ApiOddsSnapshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiOddsSnapshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiOddsSnapshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiOddsSnapshotPayload>
          }
          findMany: {
            args: Prisma.ApiOddsSnapshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiOddsSnapshotPayload>[]
          }
          create: {
            args: Prisma.ApiOddsSnapshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiOddsSnapshotPayload>
          }
          createMany: {
            args: Prisma.ApiOddsSnapshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiOddsSnapshotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiOddsSnapshotPayload>[]
          }
          delete: {
            args: Prisma.ApiOddsSnapshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiOddsSnapshotPayload>
          }
          update: {
            args: Prisma.ApiOddsSnapshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiOddsSnapshotPayload>
          }
          deleteMany: {
            args: Prisma.ApiOddsSnapshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiOddsSnapshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiOddsSnapshotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiOddsSnapshotPayload>[]
          }
          upsert: {
            args: Prisma.ApiOddsSnapshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiOddsSnapshotPayload>
          }
          aggregate: {
            args: Prisma.ApiOddsSnapshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiOddsSnapshot>
          }
          groupBy: {
            args: Prisma.ApiOddsSnapshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiOddsSnapshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiOddsSnapshotCountArgs<ExtArgs>
            result: $Utils.Optional<ApiOddsSnapshotCountAggregateOutputType> | number
          }
        }
      }
      OddsAuditLog: {
        payload: Prisma.$OddsAuditLogPayload<ExtArgs>
        fields: Prisma.OddsAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OddsAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OddsAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsAuditLogPayload>
          }
          findFirst: {
            args: Prisma.OddsAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OddsAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsAuditLogPayload>
          }
          findMany: {
            args: Prisma.OddsAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsAuditLogPayload>[]
          }
          create: {
            args: Prisma.OddsAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsAuditLogPayload>
          }
          createMany: {
            args: Prisma.OddsAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OddsAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsAuditLogPayload>[]
          }
          delete: {
            args: Prisma.OddsAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsAuditLogPayload>
          }
          update: {
            args: Prisma.OddsAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.OddsAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OddsAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OddsAuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsAuditLogPayload>[]
          }
          upsert: {
            args: Prisma.OddsAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OddsAuditLogPayload>
          }
          aggregate: {
            args: Prisma.OddsAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOddsAuditLog>
          }
          groupBy: {
            args: Prisma.OddsAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<OddsAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.OddsAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<OddsAuditLogCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    userProfile?: UserProfileOmit
    userPassword?: UserPasswordOmit
    twoFactorAuth?: TwoFactorAuthOmit
    userSession?: UserSessionOmit
    loginAttempt?: LoginAttemptOmit
    sport?: SportOmit
    league?: LeagueOmit
    team?: TeamOmit
    game?: GameOmit
    betMarket?: BetMarketOmit
    betSelection?: BetSelectionOmit
    bet?: BetOmit
    betSelectionBet?: BetSelectionBetOmit
    financialAccount?: FinancialAccountOmit
    transaction?: TransactionOmit
    paymentMethod?: PaymentMethodOmit
    deposit?: DepositOmit
    withdrawal?: WithdrawalOmit
    fraudEvent?: FraudEventOmit
    bettingPattern?: BettingPatternOmit
    accountActivityLog?: AccountActivityLogOmit
    deviceRegistry?: DeviceRegistryOmit
    ipAddress?: IpAddressOmit
    auditLog?: AuditLogOmit
    gdprConsent?: GdprConsentOmit
    dataDeletionRequest?: DataDeletionRequestOmit
    dataExportRequest?: DataExportRequestOmit
    securityAlert?: SecurityAlertOmit
    promotion?: PromotionOmit
    userBonus?: UserBonusOmit
    currentOdds?: CurrentOddsOmit
    oddsSnapshot?: OddsSnapshotOmit
    oddsSyncStatus?: OddsSyncStatusOmit
    oddsChangeEvent?: OddsChangeEventOmit
    apiOddsSnapshot?: ApiOddsSnapshotOmit
    oddsAuditLog?: OddsAuditLogOmit
    notification?: NotificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    userSessions: number
    financialAccounts: number
    bets: number
    transactions: number
    paymentMethods: number
    fraudEvents: number
    bettingPatterns: number
    activityLogs: number
    devices: number
    notifications: number
    consents: number
    deletionRequests: number
    exportRequests: number
    securityAlerts: number
    bonuses: number
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    userSessions?: boolean | UserCountOutputTypeCountUserSessionsArgs
    financialAccounts?: boolean | UserCountOutputTypeCountFinancialAccountsArgs
    bets?: boolean | UserCountOutputTypeCountBetsArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    paymentMethods?: boolean | UserCountOutputTypeCountPaymentMethodsArgs
    fraudEvents?: boolean | UserCountOutputTypeCountFraudEventsArgs
    bettingPatterns?: boolean | UserCountOutputTypeCountBettingPatternsArgs
    activityLogs?: boolean | UserCountOutputTypeCountActivityLogsArgs
    devices?: boolean | UserCountOutputTypeCountDevicesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    consents?: boolean | UserCountOutputTypeCountConsentsArgs
    deletionRequests?: boolean | UserCountOutputTypeCountDeletionRequestsArgs
    exportRequests?: boolean | UserCountOutputTypeCountExportRequestsArgs
    securityAlerts?: boolean | UserCountOutputTypeCountSecurityAlertsArgs
    bonuses?: boolean | UserCountOutputTypeCountBonusesArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFinancialAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFraudEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FraudEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBettingPatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BettingPatternWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountActivityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDevicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceRegistryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConsentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GdprConsentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeletionRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataDeletionRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExportRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataExportRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSecurityAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityAlertWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBonusWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type SportCountOutputType
   */

  export type SportCountOutputType = {
    leagues: number
    games: number
  }

  export type SportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leagues?: boolean | SportCountOutputTypeCountLeaguesArgs
    games?: boolean | SportCountOutputTypeCountGamesArgs
  }

  // Custom InputTypes
  /**
   * SportCountOutputType without action
   */
  export type SportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportCountOutputType
     */
    select?: SportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SportCountOutputType without action
   */
  export type SportCountOutputTypeCountLeaguesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeagueWhereInput
  }

  /**
   * SportCountOutputType without action
   */
  export type SportCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }


  /**
   * Count Type LeagueCountOutputType
   */

  export type LeagueCountOutputType = {
    teams: number
    games: number
  }

  export type LeagueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teams?: boolean | LeagueCountOutputTypeCountTeamsArgs
    games?: boolean | LeagueCountOutputTypeCountGamesArgs
  }

  // Custom InputTypes
  /**
   * LeagueCountOutputType without action
   */
  export type LeagueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueCountOutputType
     */
    select?: LeagueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeagueCountOutputType without action
   */
  export type LeagueCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * LeagueCountOutputType without action
   */
  export type LeagueCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    homeGames: number
    awayGames: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    homeGames?: boolean | TeamCountOutputTypeCountHomeGamesArgs
    awayGames?: boolean | TeamCountOutputTypeCountAwayGamesArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountHomeGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountAwayGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }


  /**
   * Count Type GameCountOutputType
   */

  export type GameCountOutputType = {
    markets: number
  }

  export type GameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    markets?: boolean | GameCountOutputTypeCountMarketsArgs
  }

  // Custom InputTypes
  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCountOutputType
     */
    select?: GameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountMarketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetMarketWhereInput
  }


  /**
   * Count Type BetMarketCountOutputType
   */

  export type BetMarketCountOutputType = {
    selections: number
  }

  export type BetMarketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    selections?: boolean | BetMarketCountOutputTypeCountSelectionsArgs
  }

  // Custom InputTypes
  /**
   * BetMarketCountOutputType without action
   */
  export type BetMarketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetMarketCountOutputType
     */
    select?: BetMarketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BetMarketCountOutputType without action
   */
  export type BetMarketCountOutputTypeCountSelectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetSelectionWhereInput
  }


  /**
   * Count Type BetSelectionCountOutputType
   */

  export type BetSelectionCountOutputType = {
    betSelections: number
    oddsSnapshots: number
  }

  export type BetSelectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    betSelections?: boolean | BetSelectionCountOutputTypeCountBetSelectionsArgs
    oddsSnapshots?: boolean | BetSelectionCountOutputTypeCountOddsSnapshotsArgs
  }

  // Custom InputTypes
  /**
   * BetSelectionCountOutputType without action
   */
  export type BetSelectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelectionCountOutputType
     */
    select?: BetSelectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BetSelectionCountOutputType without action
   */
  export type BetSelectionCountOutputTypeCountBetSelectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetSelectionBetWhereInput
  }

  /**
   * BetSelectionCountOutputType without action
   */
  export type BetSelectionCountOutputTypeCountOddsSnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OddsSnapshotWhereInput
  }


  /**
   * Count Type BetCountOutputType
   */

  export type BetCountOutputType = {
    selections: number
  }

  export type BetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    selections?: boolean | BetCountOutputTypeCountSelectionsArgs
  }

  // Custom InputTypes
  /**
   * BetCountOutputType without action
   */
  export type BetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetCountOutputType
     */
    select?: BetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BetCountOutputType without action
   */
  export type BetCountOutputTypeCountSelectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetSelectionBetWhereInput
  }


  /**
   * Count Type FinancialAccountCountOutputType
   */

  export type FinancialAccountCountOutputType = {
    transactions: number
  }

  export type FinancialAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | FinancialAccountCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * FinancialAccountCountOutputType without action
   */
  export type FinancialAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAccountCountOutputType
     */
    select?: FinancialAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FinancialAccountCountOutputType without action
   */
  export type FinancialAccountCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type PaymentMethodCountOutputType
   */

  export type PaymentMethodCountOutputType = {
    transactions: number
    deposits: number
    withdrawals: number
  }

  export type PaymentMethodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | PaymentMethodCountOutputTypeCountTransactionsArgs
    deposits?: boolean | PaymentMethodCountOutputTypeCountDepositsArgs
    withdrawals?: boolean | PaymentMethodCountOutputTypeCountWithdrawalsArgs
  }

  // Custom InputTypes
  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodCountOutputType
     */
    select?: PaymentMethodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeCountDepositsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepositWhereInput
  }

  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeCountWithdrawalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WithdrawalWhereInput
  }


  /**
   * Count Type PromotionCountOutputType
   */

  export type PromotionCountOutputType = {
    userBonuses: number
  }

  export type PromotionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userBonuses?: boolean | PromotionCountOutputTypeCountUserBonusesArgs
  }

  // Custom InputTypes
  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionCountOutputType
     */
    select?: PromotionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeCountUserBonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBonusWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    riskScore: number | null
  }

  export type UserSumAggregateOutputType = {
    riskScore: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    accountStatus: string | null
    kycVerified: boolean | null
    kycLevel: string | null
    gdprConsentGiven: boolean | null
    marketingConsent: boolean | null
    riskScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    accountStatus: string | null
    kycVerified: boolean | null
    kycLevel: string | null
    gdprConsentGiven: boolean | null
    marketingConsent: boolean | null
    riskScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    accountStatus: number
    kycVerified: number
    kycLevel: number
    gdprConsentGiven: number
    marketingConsent: number
    riskScore: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    riskScore?: true
  }

  export type UserSumAggregateInputType = {
    riskScore?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    accountStatus?: true
    kycVerified?: true
    kycLevel?: true
    gdprConsentGiven?: true
    marketingConsent?: true
    riskScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    accountStatus?: true
    kycVerified?: true
    kycLevel?: true
    gdprConsentGiven?: true
    marketingConsent?: true
    riskScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    accountStatus?: true
    kycVerified?: true
    kycLevel?: true
    gdprConsentGiven?: true
    marketingConsent?: true
    riskScore?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string
    emailVerified: Date | null
    image: string | null
    accountStatus: string
    kycVerified: boolean
    kycLevel: string
    gdprConsentGiven: boolean
    marketingConsent: boolean
    riskScore: number
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    accountStatus?: boolean
    kycVerified?: boolean
    kycLevel?: boolean
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    password?: boolean | User$passwordArgs<ExtArgs>
    twoFactorAuth?: boolean | User$twoFactorAuthArgs<ExtArgs>
    userSessions?: boolean | User$userSessionsArgs<ExtArgs>
    financialAccounts?: boolean | User$financialAccountsArgs<ExtArgs>
    bets?: boolean | User$betsArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    paymentMethods?: boolean | User$paymentMethodsArgs<ExtArgs>
    fraudEvents?: boolean | User$fraudEventsArgs<ExtArgs>
    bettingPatterns?: boolean | User$bettingPatternsArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    devices?: boolean | User$devicesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    consents?: boolean | User$consentsArgs<ExtArgs>
    deletionRequests?: boolean | User$deletionRequestsArgs<ExtArgs>
    exportRequests?: boolean | User$exportRequestsArgs<ExtArgs>
    securityAlerts?: boolean | User$securityAlertsArgs<ExtArgs>
    bonuses?: boolean | User$bonusesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    accountStatus?: boolean
    kycVerified?: boolean
    kycLevel?: boolean
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    accountStatus?: boolean
    kycVerified?: boolean
    kycLevel?: boolean
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    accountStatus?: boolean
    kycVerified?: boolean
    kycLevel?: boolean
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "accountStatus" | "kycVerified" | "kycLevel" | "gdprConsentGiven" | "marketingConsent" | "riskScore" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    password?: boolean | User$passwordArgs<ExtArgs>
    twoFactorAuth?: boolean | User$twoFactorAuthArgs<ExtArgs>
    userSessions?: boolean | User$userSessionsArgs<ExtArgs>
    financialAccounts?: boolean | User$financialAccountsArgs<ExtArgs>
    bets?: boolean | User$betsArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    paymentMethods?: boolean | User$paymentMethodsArgs<ExtArgs>
    fraudEvents?: boolean | User$fraudEventsArgs<ExtArgs>
    bettingPatterns?: boolean | User$bettingPatternsArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    devices?: boolean | User$devicesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    consents?: boolean | User$consentsArgs<ExtArgs>
    deletionRequests?: boolean | User$deletionRequestsArgs<ExtArgs>
    exportRequests?: boolean | User$exportRequestsArgs<ExtArgs>
    securityAlerts?: boolean | User$securityAlertsArgs<ExtArgs>
    bonuses?: boolean | User$bonusesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      profile: Prisma.$UserProfilePayload<ExtArgs> | null
      password: Prisma.$UserPasswordPayload<ExtArgs> | null
      twoFactorAuth: Prisma.$TwoFactorAuthPayload<ExtArgs> | null
      userSessions: Prisma.$UserSessionPayload<ExtArgs>[]
      financialAccounts: Prisma.$FinancialAccountPayload<ExtArgs>[]
      bets: Prisma.$BetPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      paymentMethods: Prisma.$PaymentMethodPayload<ExtArgs>[]
      fraudEvents: Prisma.$FraudEventPayload<ExtArgs>[]
      bettingPatterns: Prisma.$BettingPatternPayload<ExtArgs>[]
      activityLogs: Prisma.$AccountActivityLogPayload<ExtArgs>[]
      devices: Prisma.$DeviceRegistryPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      consents: Prisma.$GdprConsentPayload<ExtArgs>[]
      deletionRequests: Prisma.$DataDeletionRequestPayload<ExtArgs>[]
      exportRequests: Prisma.$DataExportRequestPayload<ExtArgs>[]
      securityAlerts: Prisma.$SecurityAlertPayload<ExtArgs>[]
      bonuses: Prisma.$UserBonusPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string
      emailVerified: Date | null
      image: string | null
      accountStatus: string
      kycVerified: boolean
      kycLevel: string
      gdprConsentGiven: boolean
      marketingConsent: boolean
      riskScore: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    password<T extends User$passwordArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordArgs<ExtArgs>>): Prisma__UserPasswordClient<$Result.GetResult<Prisma.$UserPasswordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    twoFactorAuth<T extends User$twoFactorAuthArgs<ExtArgs> = {}>(args?: Subset<T, User$twoFactorAuthArgs<ExtArgs>>): Prisma__TwoFactorAuthClient<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userSessions<T extends User$userSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$userSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    financialAccounts<T extends User$financialAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$financialAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bets<T extends User$betsArgs<ExtArgs> = {}>(args?: Subset<T, User$betsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentMethods<T extends User$paymentMethodsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentMethodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fraudEvents<T extends User$fraudEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$fraudEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FraudEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bettingPatterns<T extends User$bettingPatternsArgs<ExtArgs> = {}>(args?: Subset<T, User$bettingPatternsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BettingPatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activityLogs<T extends User$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    devices<T extends User$devicesArgs<ExtArgs> = {}>(args?: Subset<T, User$devicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceRegistryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    consents<T extends User$consentsArgs<ExtArgs> = {}>(args?: Subset<T, User$consentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GdprConsentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deletionRequests<T extends User$deletionRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$deletionRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exportRequests<T extends User$exportRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$exportRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    securityAlerts<T extends User$securityAlertsArgs<ExtArgs> = {}>(args?: Subset<T, User$securityAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bonuses<T extends User$bonusesArgs<ExtArgs> = {}>(args?: Subset<T, User$bonusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly accountStatus: FieldRef<"User", 'String'>
    readonly kycVerified: FieldRef<"User", 'Boolean'>
    readonly kycLevel: FieldRef<"User", 'String'>
    readonly gdprConsentGiven: FieldRef<"User", 'Boolean'>
    readonly marketingConsent: FieldRef<"User", 'Boolean'>
    readonly riskScore: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
  }

  /**
   * User.password
   */
  export type User$passwordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPassword
     */
    omit?: UserPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPasswordInclude<ExtArgs> | null
    where?: UserPasswordWhereInput
  }

  /**
   * User.twoFactorAuth
   */
  export type User$twoFactorAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    where?: TwoFactorAuthWhereInput
  }

  /**
   * User.userSessions
   */
  export type User$userSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User.financialAccounts
   */
  export type User$financialAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAccount
     */
    select?: FinancialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAccount
     */
    omit?: FinancialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAccountInclude<ExtArgs> | null
    where?: FinancialAccountWhereInput
    orderBy?: FinancialAccountOrderByWithRelationInput | FinancialAccountOrderByWithRelationInput[]
    cursor?: FinancialAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialAccountScalarFieldEnum | FinancialAccountScalarFieldEnum[]
  }

  /**
   * User.bets
   */
  export type User$betsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bet
     */
    omit?: BetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    where?: BetWhereInput
    orderBy?: BetOrderByWithRelationInput | BetOrderByWithRelationInput[]
    cursor?: BetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BetScalarFieldEnum | BetScalarFieldEnum[]
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.paymentMethods
   */
  export type User$paymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    cursor?: PaymentMethodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * User.fraudEvents
   */
  export type User$fraudEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudEvent
     */
    select?: FraudEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudEvent
     */
    omit?: FraudEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudEventInclude<ExtArgs> | null
    where?: FraudEventWhereInput
    orderBy?: FraudEventOrderByWithRelationInput | FraudEventOrderByWithRelationInput[]
    cursor?: FraudEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FraudEventScalarFieldEnum | FraudEventScalarFieldEnum[]
  }

  /**
   * User.bettingPatterns
   */
  export type User$bettingPatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPattern
     */
    select?: BettingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPattern
     */
    omit?: BettingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPatternInclude<ExtArgs> | null
    where?: BettingPatternWhereInput
    orderBy?: BettingPatternOrderByWithRelationInput | BettingPatternOrderByWithRelationInput[]
    cursor?: BettingPatternWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BettingPatternScalarFieldEnum | BettingPatternScalarFieldEnum[]
  }

  /**
   * User.activityLogs
   */
  export type User$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountActivityLog
     */
    select?: AccountActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountActivityLog
     */
    omit?: AccountActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountActivityLogInclude<ExtArgs> | null
    where?: AccountActivityLogWhereInput
    orderBy?: AccountActivityLogOrderByWithRelationInput | AccountActivityLogOrderByWithRelationInput[]
    cursor?: AccountActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountActivityLogScalarFieldEnum | AccountActivityLogScalarFieldEnum[]
  }

  /**
   * User.devices
   */
  export type User$devicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRegistry
     */
    select?: DeviceRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRegistry
     */
    omit?: DeviceRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRegistryInclude<ExtArgs> | null
    where?: DeviceRegistryWhereInput
    orderBy?: DeviceRegistryOrderByWithRelationInput | DeviceRegistryOrderByWithRelationInput[]
    cursor?: DeviceRegistryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceRegistryScalarFieldEnum | DeviceRegistryScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.consents
   */
  export type User$consentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GdprConsent
     */
    select?: GdprConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GdprConsent
     */
    omit?: GdprConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GdprConsentInclude<ExtArgs> | null
    where?: GdprConsentWhereInput
    orderBy?: GdprConsentOrderByWithRelationInput | GdprConsentOrderByWithRelationInput[]
    cursor?: GdprConsentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GdprConsentScalarFieldEnum | GdprConsentScalarFieldEnum[]
  }

  /**
   * User.deletionRequests
   */
  export type User$deletionRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    where?: DataDeletionRequestWhereInput
    orderBy?: DataDeletionRequestOrderByWithRelationInput | DataDeletionRequestOrderByWithRelationInput[]
    cursor?: DataDeletionRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataDeletionRequestScalarFieldEnum | DataDeletionRequestScalarFieldEnum[]
  }

  /**
   * User.exportRequests
   */
  export type User$exportRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExportRequest
     */
    omit?: DataExportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
    where?: DataExportRequestWhereInput
    orderBy?: DataExportRequestOrderByWithRelationInput | DataExportRequestOrderByWithRelationInput[]
    cursor?: DataExportRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataExportRequestScalarFieldEnum | DataExportRequestScalarFieldEnum[]
  }

  /**
   * User.securityAlerts
   */
  export type User$securityAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    where?: SecurityAlertWhereInput
    orderBy?: SecurityAlertOrderByWithRelationInput | SecurityAlertOrderByWithRelationInput[]
    cursor?: SecurityAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SecurityAlertScalarFieldEnum | SecurityAlertScalarFieldEnum[]
  }

  /**
   * User.bonuses
   */
  export type User$bonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBonus
     */
    omit?: UserBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    where?: UserBonusWhereInput
    orderBy?: UserBonusOrderByWithRelationInput | UserBonusOrderByWithRelationInput[]
    cursor?: UserBonusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBonusScalarFieldEnum | UserBonusScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model UserProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    address: string | null
    phoneNumber: string | null
    country: string | null
    timezone: string | null
    language: string | null
    marketingOptIn: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    address: string | null
    phoneNumber: string | null
    country: string | null
    timezone: string | null
    language: string | null
    marketingOptIn: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    dateOfBirth: number
    address: number
    phoneNumber: number
    country: number
    timezone: number
    language: number
    marketingOptIn: number
    responsibleGamingSettings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserProfileMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    address?: true
    phoneNumber?: true
    country?: true
    timezone?: true
    language?: true
    marketingOptIn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    address?: true
    phoneNumber?: true
    country?: true
    timezone?: true
    language?: true
    marketingOptIn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    address?: true
    phoneNumber?: true
    country?: true
    timezone?: true
    language?: true
    marketingOptIn?: true
    responsibleGamingSettings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }

  export type UserProfileGroupByOutputType = {
    id: string
    userId: string
    firstName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    address: string | null
    phoneNumber: string | null
    country: string | null
    timezone: string | null
    language: string | null
    marketingOptIn: boolean
    responsibleGamingSettings: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    address?: boolean
    phoneNumber?: boolean
    country?: boolean
    timezone?: boolean
    language?: boolean
    marketingOptIn?: boolean
    responsibleGamingSettings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    address?: boolean
    phoneNumber?: boolean
    country?: boolean
    timezone?: boolean
    language?: boolean
    marketingOptIn?: boolean
    responsibleGamingSettings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    address?: boolean
    phoneNumber?: boolean
    country?: boolean
    timezone?: boolean
    language?: boolean
    marketingOptIn?: boolean
    responsibleGamingSettings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    address?: boolean
    phoneNumber?: boolean
    country?: boolean
    timezone?: boolean
    language?: boolean
    marketingOptIn?: boolean
    responsibleGamingSettings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "firstName" | "lastName" | "dateOfBirth" | "address" | "phoneNumber" | "country" | "timezone" | "language" | "marketingOptIn" | "responsibleGamingSettings" | "createdAt" | "updatedAt", ExtArgs["result"]["userProfile"]>
  export type UserProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      firstName: string | null
      lastName: string | null
      dateOfBirth: Date | null
      address: string | null
      phoneNumber: string | null
      country: string | null
      timezone: string | null
      language: string | null
      marketingOptIn: boolean
      responsibleGamingSettings: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userProfile"]>
    composites: {}
  }

  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileDefaultArgs> = $Result.GetResult<Prisma.$UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileFindUniqueArgs>(args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileFindFirstArgs>(args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProfileFindManyArgs>(args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
     */
    create<T extends UserProfileCreateArgs>(args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProfiles.
     * @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileCreateManyArgs>(args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProfiles and returns the data saved in the database.
     * @param {UserProfileCreateManyAndReturnArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
     */
    delete<T extends UserProfileDeleteArgs>(args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileUpdateArgs>(args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileDeleteManyArgs>(args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileUpdateManyArgs>(args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles and returns the data updated in the database.
     * @param {UserProfileUpdateManyAndReturnArgs} args - Arguments to update many UserProfiles.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileUpsertArgs>(args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfile model
   */
  interface UserProfileFieldRefs {
    readonly id: FieldRef<"UserProfile", 'String'>
    readonly userId: FieldRef<"UserProfile", 'String'>
    readonly firstName: FieldRef<"UserProfile", 'String'>
    readonly lastName: FieldRef<"UserProfile", 'String'>
    readonly dateOfBirth: FieldRef<"UserProfile", 'DateTime'>
    readonly address: FieldRef<"UserProfile", 'String'>
    readonly phoneNumber: FieldRef<"UserProfile", 'String'>
    readonly country: FieldRef<"UserProfile", 'String'>
    readonly timezone: FieldRef<"UserProfile", 'String'>
    readonly language: FieldRef<"UserProfile", 'String'>
    readonly marketingOptIn: FieldRef<"UserProfile", 'Boolean'>
    readonly responsibleGamingSettings: FieldRef<"UserProfile", 'Json'>
    readonly createdAt: FieldRef<"UserProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }

  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile createManyAndReturn
   */
  export type UserProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
  }

  /**
   * UserProfile updateManyAndReturn
   */
  export type UserProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }

  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to delete.
     */
    limit?: number
  }

  /**
   * UserProfile without action
   */
  export type UserProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
  }


  /**
   * Model UserPassword
   */

  export type AggregateUserPassword = {
    _count: UserPasswordCountAggregateOutputType | null
    _avg: UserPasswordAvgAggregateOutputType | null
    _sum: UserPasswordSumAggregateOutputType | null
    _min: UserPasswordMinAggregateOutputType | null
    _max: UserPasswordMaxAggregateOutputType | null
  }

  export type UserPasswordAvgAggregateOutputType = {
    failedLoginAttempts: number | null
  }

  export type UserPasswordSumAggregateOutputType = {
    failedLoginAttempts: number | null
  }

  export type UserPasswordMinAggregateOutputType = {
    id: string | null
    userId: string | null
    passwordHash: string | null
    resetToken: string | null
    resetTokenExpiresAt: Date | null
    passwordChangedAt: Date | null
    failedLoginAttempts: number | null
    lockedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPasswordMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    passwordHash: string | null
    resetToken: string | null
    resetTokenExpiresAt: Date | null
    passwordChangedAt: Date | null
    failedLoginAttempts: number | null
    lockedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPasswordCountAggregateOutputType = {
    id: number
    userId: number
    passwordHash: number
    passwordHistory: number
    resetToken: number
    resetTokenExpiresAt: number
    passwordChangedAt: number
    failedLoginAttempts: number
    lockedUntil: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPasswordAvgAggregateInputType = {
    failedLoginAttempts?: true
  }

  export type UserPasswordSumAggregateInputType = {
    failedLoginAttempts?: true
  }

  export type UserPasswordMinAggregateInputType = {
    id?: true
    userId?: true
    passwordHash?: true
    resetToken?: true
    resetTokenExpiresAt?: true
    passwordChangedAt?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPasswordMaxAggregateInputType = {
    id?: true
    userId?: true
    passwordHash?: true
    resetToken?: true
    resetTokenExpiresAt?: true
    passwordChangedAt?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPasswordCountAggregateInputType = {
    id?: true
    userId?: true
    passwordHash?: true
    passwordHistory?: true
    resetToken?: true
    resetTokenExpiresAt?: true
    passwordChangedAt?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPasswordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPassword to aggregate.
     */
    where?: UserPasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPasswords to fetch.
     */
    orderBy?: UserPasswordOrderByWithRelationInput | UserPasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPasswords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPasswords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPasswords
    **/
    _count?: true | UserPasswordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPasswordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPasswordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPasswordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPasswordMaxAggregateInputType
  }

  export type GetUserPasswordAggregateType<T extends UserPasswordAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPassword]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPassword[P]>
      : GetScalarType<T[P], AggregateUserPassword[P]>
  }




  export type UserPasswordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPasswordWhereInput
    orderBy?: UserPasswordOrderByWithAggregationInput | UserPasswordOrderByWithAggregationInput[]
    by: UserPasswordScalarFieldEnum[] | UserPasswordScalarFieldEnum
    having?: UserPasswordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPasswordCountAggregateInputType | true
    _avg?: UserPasswordAvgAggregateInputType
    _sum?: UserPasswordSumAggregateInputType
    _min?: UserPasswordMinAggregateInputType
    _max?: UserPasswordMaxAggregateInputType
  }

  export type UserPasswordGroupByOutputType = {
    id: string
    userId: string
    passwordHash: string
    passwordHistory: JsonValue | null
    resetToken: string | null
    resetTokenExpiresAt: Date | null
    passwordChangedAt: Date
    failedLoginAttempts: number
    lockedUntil: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserPasswordCountAggregateOutputType | null
    _avg: UserPasswordAvgAggregateOutputType | null
    _sum: UserPasswordSumAggregateOutputType | null
    _min: UserPasswordMinAggregateOutputType | null
    _max: UserPasswordMaxAggregateOutputType | null
  }

  type GetUserPasswordGroupByPayload<T extends UserPasswordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPasswordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPasswordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPasswordGroupByOutputType[P]>
            : GetScalarType<T[P], UserPasswordGroupByOutputType[P]>
        }
      >
    >


  export type UserPasswordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    passwordHash?: boolean
    passwordHistory?: boolean
    resetToken?: boolean
    resetTokenExpiresAt?: boolean
    passwordChangedAt?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPassword"]>

  export type UserPasswordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    passwordHash?: boolean
    passwordHistory?: boolean
    resetToken?: boolean
    resetTokenExpiresAt?: boolean
    passwordChangedAt?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPassword"]>

  export type UserPasswordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    passwordHash?: boolean
    passwordHistory?: boolean
    resetToken?: boolean
    resetTokenExpiresAt?: boolean
    passwordChangedAt?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPassword"]>

  export type UserPasswordSelectScalar = {
    id?: boolean
    userId?: boolean
    passwordHash?: boolean
    passwordHistory?: boolean
    resetToken?: boolean
    resetTokenExpiresAt?: boolean
    passwordChangedAt?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPasswordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "passwordHash" | "passwordHistory" | "resetToken" | "resetTokenExpiresAt" | "passwordChangedAt" | "failedLoginAttempts" | "lockedUntil" | "createdAt" | "updatedAt", ExtArgs["result"]["userPassword"]>
  export type UserPasswordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPasswordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPasswordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPasswordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPassword"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      passwordHash: string
      passwordHistory: Prisma.JsonValue | null
      resetToken: string | null
      resetTokenExpiresAt: Date | null
      passwordChangedAt: Date
      failedLoginAttempts: number
      lockedUntil: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPassword"]>
    composites: {}
  }

  type UserPasswordGetPayload<S extends boolean | null | undefined | UserPasswordDefaultArgs> = $Result.GetResult<Prisma.$UserPasswordPayload, S>

  type UserPasswordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPasswordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPasswordCountAggregateInputType | true
    }

  export interface UserPasswordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPassword'], meta: { name: 'UserPassword' } }
    /**
     * Find zero or one UserPassword that matches the filter.
     * @param {UserPasswordFindUniqueArgs} args - Arguments to find a UserPassword
     * @example
     * // Get one UserPassword
     * const userPassword = await prisma.userPassword.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPasswordFindUniqueArgs>(args: SelectSubset<T, UserPasswordFindUniqueArgs<ExtArgs>>): Prisma__UserPasswordClient<$Result.GetResult<Prisma.$UserPasswordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPassword that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPasswordFindUniqueOrThrowArgs} args - Arguments to find a UserPassword
     * @example
     * // Get one UserPassword
     * const userPassword = await prisma.userPassword.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPasswordFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPasswordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPasswordClient<$Result.GetResult<Prisma.$UserPasswordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPassword that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordFindFirstArgs} args - Arguments to find a UserPassword
     * @example
     * // Get one UserPassword
     * const userPassword = await prisma.userPassword.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPasswordFindFirstArgs>(args?: SelectSubset<T, UserPasswordFindFirstArgs<ExtArgs>>): Prisma__UserPasswordClient<$Result.GetResult<Prisma.$UserPasswordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPassword that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordFindFirstOrThrowArgs} args - Arguments to find a UserPassword
     * @example
     * // Get one UserPassword
     * const userPassword = await prisma.userPassword.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPasswordFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPasswordFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPasswordClient<$Result.GetResult<Prisma.$UserPasswordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPasswords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPasswords
     * const userPasswords = await prisma.userPassword.findMany()
     * 
     * // Get first 10 UserPasswords
     * const userPasswords = await prisma.userPassword.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPasswordWithIdOnly = await prisma.userPassword.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPasswordFindManyArgs>(args?: SelectSubset<T, UserPasswordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPasswordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPassword.
     * @param {UserPasswordCreateArgs} args - Arguments to create a UserPassword.
     * @example
     * // Create one UserPassword
     * const UserPassword = await prisma.userPassword.create({
     *   data: {
     *     // ... data to create a UserPassword
     *   }
     * })
     * 
     */
    create<T extends UserPasswordCreateArgs>(args: SelectSubset<T, UserPasswordCreateArgs<ExtArgs>>): Prisma__UserPasswordClient<$Result.GetResult<Prisma.$UserPasswordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPasswords.
     * @param {UserPasswordCreateManyArgs} args - Arguments to create many UserPasswords.
     * @example
     * // Create many UserPasswords
     * const userPassword = await prisma.userPassword.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPasswordCreateManyArgs>(args?: SelectSubset<T, UserPasswordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPasswords and returns the data saved in the database.
     * @param {UserPasswordCreateManyAndReturnArgs} args - Arguments to create many UserPasswords.
     * @example
     * // Create many UserPasswords
     * const userPassword = await prisma.userPassword.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPasswords and only return the `id`
     * const userPasswordWithIdOnly = await prisma.userPassword.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPasswordCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPasswordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPasswordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPassword.
     * @param {UserPasswordDeleteArgs} args - Arguments to delete one UserPassword.
     * @example
     * // Delete one UserPassword
     * const UserPassword = await prisma.userPassword.delete({
     *   where: {
     *     // ... filter to delete one UserPassword
     *   }
     * })
     * 
     */
    delete<T extends UserPasswordDeleteArgs>(args: SelectSubset<T, UserPasswordDeleteArgs<ExtArgs>>): Prisma__UserPasswordClient<$Result.GetResult<Prisma.$UserPasswordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPassword.
     * @param {UserPasswordUpdateArgs} args - Arguments to update one UserPassword.
     * @example
     * // Update one UserPassword
     * const userPassword = await prisma.userPassword.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPasswordUpdateArgs>(args: SelectSubset<T, UserPasswordUpdateArgs<ExtArgs>>): Prisma__UserPasswordClient<$Result.GetResult<Prisma.$UserPasswordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPasswords.
     * @param {UserPasswordDeleteManyArgs} args - Arguments to filter UserPasswords to delete.
     * @example
     * // Delete a few UserPasswords
     * const { count } = await prisma.userPassword.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPasswordDeleteManyArgs>(args?: SelectSubset<T, UserPasswordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPasswords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPasswords
     * const userPassword = await prisma.userPassword.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPasswordUpdateManyArgs>(args: SelectSubset<T, UserPasswordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPasswords and returns the data updated in the database.
     * @param {UserPasswordUpdateManyAndReturnArgs} args - Arguments to update many UserPasswords.
     * @example
     * // Update many UserPasswords
     * const userPassword = await prisma.userPassword.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPasswords and only return the `id`
     * const userPasswordWithIdOnly = await prisma.userPassword.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPasswordUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPasswordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPasswordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPassword.
     * @param {UserPasswordUpsertArgs} args - Arguments to update or create a UserPassword.
     * @example
     * // Update or create a UserPassword
     * const userPassword = await prisma.userPassword.upsert({
     *   create: {
     *     // ... data to create a UserPassword
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPassword we want to update
     *   }
     * })
     */
    upsert<T extends UserPasswordUpsertArgs>(args: SelectSubset<T, UserPasswordUpsertArgs<ExtArgs>>): Prisma__UserPasswordClient<$Result.GetResult<Prisma.$UserPasswordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPasswords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordCountArgs} args - Arguments to filter UserPasswords to count.
     * @example
     * // Count the number of UserPasswords
     * const count = await prisma.userPassword.count({
     *   where: {
     *     // ... the filter for the UserPasswords we want to count
     *   }
     * })
    **/
    count<T extends UserPasswordCountArgs>(
      args?: Subset<T, UserPasswordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPasswordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPassword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPasswordAggregateArgs>(args: Subset<T, UserPasswordAggregateArgs>): Prisma.PrismaPromise<GetUserPasswordAggregateType<T>>

    /**
     * Group by UserPassword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPasswordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPasswordGroupByArgs['orderBy'] }
        : { orderBy?: UserPasswordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPasswordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPasswordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPassword model
   */
  readonly fields: UserPasswordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPassword.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPasswordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPassword model
   */
  interface UserPasswordFieldRefs {
    readonly id: FieldRef<"UserPassword", 'String'>
    readonly userId: FieldRef<"UserPassword", 'String'>
    readonly passwordHash: FieldRef<"UserPassword", 'String'>
    readonly passwordHistory: FieldRef<"UserPassword", 'Json'>
    readonly resetToken: FieldRef<"UserPassword", 'String'>
    readonly resetTokenExpiresAt: FieldRef<"UserPassword", 'DateTime'>
    readonly passwordChangedAt: FieldRef<"UserPassword", 'DateTime'>
    readonly failedLoginAttempts: FieldRef<"UserPassword", 'Int'>
    readonly lockedUntil: FieldRef<"UserPassword", 'DateTime'>
    readonly createdAt: FieldRef<"UserPassword", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPassword", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPassword findUnique
   */
  export type UserPasswordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPassword
     */
    omit?: UserPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPasswordInclude<ExtArgs> | null
    /**
     * Filter, which UserPassword to fetch.
     */
    where: UserPasswordWhereUniqueInput
  }

  /**
   * UserPassword findUniqueOrThrow
   */
  export type UserPasswordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPassword
     */
    omit?: UserPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPasswordInclude<ExtArgs> | null
    /**
     * Filter, which UserPassword to fetch.
     */
    where: UserPasswordWhereUniqueInput
  }

  /**
   * UserPassword findFirst
   */
  export type UserPasswordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPassword
     */
    omit?: UserPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPasswordInclude<ExtArgs> | null
    /**
     * Filter, which UserPassword to fetch.
     */
    where?: UserPasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPasswords to fetch.
     */
    orderBy?: UserPasswordOrderByWithRelationInput | UserPasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPasswords.
     */
    cursor?: UserPasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPasswords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPasswords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPasswords.
     */
    distinct?: UserPasswordScalarFieldEnum | UserPasswordScalarFieldEnum[]
  }

  /**
   * UserPassword findFirstOrThrow
   */
  export type UserPasswordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPassword
     */
    omit?: UserPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPasswordInclude<ExtArgs> | null
    /**
     * Filter, which UserPassword to fetch.
     */
    where?: UserPasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPasswords to fetch.
     */
    orderBy?: UserPasswordOrderByWithRelationInput | UserPasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPasswords.
     */
    cursor?: UserPasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPasswords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPasswords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPasswords.
     */
    distinct?: UserPasswordScalarFieldEnum | UserPasswordScalarFieldEnum[]
  }

  /**
   * UserPassword findMany
   */
  export type UserPasswordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPassword
     */
    omit?: UserPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPasswordInclude<ExtArgs> | null
    /**
     * Filter, which UserPasswords to fetch.
     */
    where?: UserPasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPasswords to fetch.
     */
    orderBy?: UserPasswordOrderByWithRelationInput | UserPasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPasswords.
     */
    cursor?: UserPasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPasswords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPasswords.
     */
    skip?: number
    distinct?: UserPasswordScalarFieldEnum | UserPasswordScalarFieldEnum[]
  }

  /**
   * UserPassword create
   */
  export type UserPasswordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPassword
     */
    omit?: UserPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPasswordInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPassword.
     */
    data: XOR<UserPasswordCreateInput, UserPasswordUncheckedCreateInput>
  }

  /**
   * UserPassword createMany
   */
  export type UserPasswordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPasswords.
     */
    data: UserPasswordCreateManyInput | UserPasswordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPassword createManyAndReturn
   */
  export type UserPasswordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPassword
     */
    omit?: UserPasswordOmit<ExtArgs> | null
    /**
     * The data used to create many UserPasswords.
     */
    data: UserPasswordCreateManyInput | UserPasswordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPasswordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPassword update
   */
  export type UserPasswordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPassword
     */
    omit?: UserPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPasswordInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPassword.
     */
    data: XOR<UserPasswordUpdateInput, UserPasswordUncheckedUpdateInput>
    /**
     * Choose, which UserPassword to update.
     */
    where: UserPasswordWhereUniqueInput
  }

  /**
   * UserPassword updateMany
   */
  export type UserPasswordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPasswords.
     */
    data: XOR<UserPasswordUpdateManyMutationInput, UserPasswordUncheckedUpdateManyInput>
    /**
     * Filter which UserPasswords to update
     */
    where?: UserPasswordWhereInput
    /**
     * Limit how many UserPasswords to update.
     */
    limit?: number
  }

  /**
   * UserPassword updateManyAndReturn
   */
  export type UserPasswordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPassword
     */
    omit?: UserPasswordOmit<ExtArgs> | null
    /**
     * The data used to update UserPasswords.
     */
    data: XOR<UserPasswordUpdateManyMutationInput, UserPasswordUncheckedUpdateManyInput>
    /**
     * Filter which UserPasswords to update
     */
    where?: UserPasswordWhereInput
    /**
     * Limit how many UserPasswords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPasswordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPassword upsert
   */
  export type UserPasswordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPassword
     */
    omit?: UserPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPasswordInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPassword to update in case it exists.
     */
    where: UserPasswordWhereUniqueInput
    /**
     * In case the UserPassword found by the `where` argument doesn't exist, create a new UserPassword with this data.
     */
    create: XOR<UserPasswordCreateInput, UserPasswordUncheckedCreateInput>
    /**
     * In case the UserPassword was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPasswordUpdateInput, UserPasswordUncheckedUpdateInput>
  }

  /**
   * UserPassword delete
   */
  export type UserPasswordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPassword
     */
    omit?: UserPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPasswordInclude<ExtArgs> | null
    /**
     * Filter which UserPassword to delete.
     */
    where: UserPasswordWhereUniqueInput
  }

  /**
   * UserPassword deleteMany
   */
  export type UserPasswordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPasswords to delete
     */
    where?: UserPasswordWhereInput
    /**
     * Limit how many UserPasswords to delete.
     */
    limit?: number
  }

  /**
   * UserPassword without action
   */
  export type UserPasswordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPassword
     */
    omit?: UserPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPasswordInclude<ExtArgs> | null
  }


  /**
   * Model TwoFactorAuth
   */

  export type AggregateTwoFactorAuth = {
    _count: TwoFactorAuthCountAggregateOutputType | null
    _min: TwoFactorAuthMinAggregateOutputType | null
    _max: TwoFactorAuthMaxAggregateOutputType | null
  }

  export type TwoFactorAuthMinAggregateOutputType = {
    id: string | null
    userId: string | null
    method: string | null
    secretKey: string | null
    enabled: boolean | null
    lastVerifiedAt: Date | null
    recoveryEmail: string | null
    recoveryPhone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwoFactorAuthMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    method: string | null
    secretKey: string | null
    enabled: boolean | null
    lastVerifiedAt: Date | null
    recoveryEmail: string | null
    recoveryPhone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwoFactorAuthCountAggregateOutputType = {
    id: number
    userId: number
    method: number
    secretKey: number
    backupCodes: number
    enabled: number
    lastVerifiedAt: number
    recoveryEmail: number
    recoveryPhone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwoFactorAuthMinAggregateInputType = {
    id?: true
    userId?: true
    method?: true
    secretKey?: true
    enabled?: true
    lastVerifiedAt?: true
    recoveryEmail?: true
    recoveryPhone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwoFactorAuthMaxAggregateInputType = {
    id?: true
    userId?: true
    method?: true
    secretKey?: true
    enabled?: true
    lastVerifiedAt?: true
    recoveryEmail?: true
    recoveryPhone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwoFactorAuthCountAggregateInputType = {
    id?: true
    userId?: true
    method?: true
    secretKey?: true
    backupCodes?: true
    enabled?: true
    lastVerifiedAt?: true
    recoveryEmail?: true
    recoveryPhone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwoFactorAuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactorAuth to aggregate.
     */
    where?: TwoFactorAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorAuths to fetch.
     */
    orderBy?: TwoFactorAuthOrderByWithRelationInput | TwoFactorAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwoFactorAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwoFactorAuths
    **/
    _count?: true | TwoFactorAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwoFactorAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwoFactorAuthMaxAggregateInputType
  }

  export type GetTwoFactorAuthAggregateType<T extends TwoFactorAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateTwoFactorAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwoFactorAuth[P]>
      : GetScalarType<T[P], AggregateTwoFactorAuth[P]>
  }




  export type TwoFactorAuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwoFactorAuthWhereInput
    orderBy?: TwoFactorAuthOrderByWithAggregationInput | TwoFactorAuthOrderByWithAggregationInput[]
    by: TwoFactorAuthScalarFieldEnum[] | TwoFactorAuthScalarFieldEnum
    having?: TwoFactorAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwoFactorAuthCountAggregateInputType | true
    _min?: TwoFactorAuthMinAggregateInputType
    _max?: TwoFactorAuthMaxAggregateInputType
  }

  export type TwoFactorAuthGroupByOutputType = {
    id: string
    userId: string
    method: string
    secretKey: string | null
    backupCodes: JsonValue | null
    enabled: boolean
    lastVerifiedAt: Date | null
    recoveryEmail: string | null
    recoveryPhone: string | null
    createdAt: Date
    updatedAt: Date
    _count: TwoFactorAuthCountAggregateOutputType | null
    _min: TwoFactorAuthMinAggregateOutputType | null
    _max: TwoFactorAuthMaxAggregateOutputType | null
  }

  type GetTwoFactorAuthGroupByPayload<T extends TwoFactorAuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TwoFactorAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwoFactorAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwoFactorAuthGroupByOutputType[P]>
            : GetScalarType<T[P], TwoFactorAuthGroupByOutputType[P]>
        }
      >
    >


  export type TwoFactorAuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    method?: boolean
    secretKey?: boolean
    backupCodes?: boolean
    enabled?: boolean
    lastVerifiedAt?: boolean
    recoveryEmail?: boolean
    recoveryPhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twoFactorAuth"]>

  export type TwoFactorAuthSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    method?: boolean
    secretKey?: boolean
    backupCodes?: boolean
    enabled?: boolean
    lastVerifiedAt?: boolean
    recoveryEmail?: boolean
    recoveryPhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twoFactorAuth"]>

  export type TwoFactorAuthSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    method?: boolean
    secretKey?: boolean
    backupCodes?: boolean
    enabled?: boolean
    lastVerifiedAt?: boolean
    recoveryEmail?: boolean
    recoveryPhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twoFactorAuth"]>

  export type TwoFactorAuthSelectScalar = {
    id?: boolean
    userId?: boolean
    method?: boolean
    secretKey?: boolean
    backupCodes?: boolean
    enabled?: boolean
    lastVerifiedAt?: boolean
    recoveryEmail?: boolean
    recoveryPhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TwoFactorAuthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "method" | "secretKey" | "backupCodes" | "enabled" | "lastVerifiedAt" | "recoveryEmail" | "recoveryPhone" | "createdAt" | "updatedAt", ExtArgs["result"]["twoFactorAuth"]>
  export type TwoFactorAuthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TwoFactorAuthIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TwoFactorAuthIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TwoFactorAuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TwoFactorAuth"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      method: string
      secretKey: string | null
      backupCodes: Prisma.JsonValue | null
      enabled: boolean
      lastVerifiedAt: Date | null
      recoveryEmail: string | null
      recoveryPhone: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["twoFactorAuth"]>
    composites: {}
  }

  type TwoFactorAuthGetPayload<S extends boolean | null | undefined | TwoFactorAuthDefaultArgs> = $Result.GetResult<Prisma.$TwoFactorAuthPayload, S>

  type TwoFactorAuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TwoFactorAuthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TwoFactorAuthCountAggregateInputType | true
    }

  export interface TwoFactorAuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TwoFactorAuth'], meta: { name: 'TwoFactorAuth' } }
    /**
     * Find zero or one TwoFactorAuth that matches the filter.
     * @param {TwoFactorAuthFindUniqueArgs} args - Arguments to find a TwoFactorAuth
     * @example
     * // Get one TwoFactorAuth
     * const twoFactorAuth = await prisma.twoFactorAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TwoFactorAuthFindUniqueArgs>(args: SelectSubset<T, TwoFactorAuthFindUniqueArgs<ExtArgs>>): Prisma__TwoFactorAuthClient<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TwoFactorAuth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TwoFactorAuthFindUniqueOrThrowArgs} args - Arguments to find a TwoFactorAuth
     * @example
     * // Get one TwoFactorAuth
     * const twoFactorAuth = await prisma.twoFactorAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TwoFactorAuthFindUniqueOrThrowArgs>(args: SelectSubset<T, TwoFactorAuthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TwoFactorAuthClient<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TwoFactorAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAuthFindFirstArgs} args - Arguments to find a TwoFactorAuth
     * @example
     * // Get one TwoFactorAuth
     * const twoFactorAuth = await prisma.twoFactorAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TwoFactorAuthFindFirstArgs>(args?: SelectSubset<T, TwoFactorAuthFindFirstArgs<ExtArgs>>): Prisma__TwoFactorAuthClient<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TwoFactorAuth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAuthFindFirstOrThrowArgs} args - Arguments to find a TwoFactorAuth
     * @example
     * // Get one TwoFactorAuth
     * const twoFactorAuth = await prisma.twoFactorAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TwoFactorAuthFindFirstOrThrowArgs>(args?: SelectSubset<T, TwoFactorAuthFindFirstOrThrowArgs<ExtArgs>>): Prisma__TwoFactorAuthClient<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TwoFactorAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwoFactorAuths
     * const twoFactorAuths = await prisma.twoFactorAuth.findMany()
     * 
     * // Get first 10 TwoFactorAuths
     * const twoFactorAuths = await prisma.twoFactorAuth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twoFactorAuthWithIdOnly = await prisma.twoFactorAuth.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TwoFactorAuthFindManyArgs>(args?: SelectSubset<T, TwoFactorAuthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TwoFactorAuth.
     * @param {TwoFactorAuthCreateArgs} args - Arguments to create a TwoFactorAuth.
     * @example
     * // Create one TwoFactorAuth
     * const TwoFactorAuth = await prisma.twoFactorAuth.create({
     *   data: {
     *     // ... data to create a TwoFactorAuth
     *   }
     * })
     * 
     */
    create<T extends TwoFactorAuthCreateArgs>(args: SelectSubset<T, TwoFactorAuthCreateArgs<ExtArgs>>): Prisma__TwoFactorAuthClient<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TwoFactorAuths.
     * @param {TwoFactorAuthCreateManyArgs} args - Arguments to create many TwoFactorAuths.
     * @example
     * // Create many TwoFactorAuths
     * const twoFactorAuth = await prisma.twoFactorAuth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TwoFactorAuthCreateManyArgs>(args?: SelectSubset<T, TwoFactorAuthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TwoFactorAuths and returns the data saved in the database.
     * @param {TwoFactorAuthCreateManyAndReturnArgs} args - Arguments to create many TwoFactorAuths.
     * @example
     * // Create many TwoFactorAuths
     * const twoFactorAuth = await prisma.twoFactorAuth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TwoFactorAuths and only return the `id`
     * const twoFactorAuthWithIdOnly = await prisma.twoFactorAuth.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TwoFactorAuthCreateManyAndReturnArgs>(args?: SelectSubset<T, TwoFactorAuthCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TwoFactorAuth.
     * @param {TwoFactorAuthDeleteArgs} args - Arguments to delete one TwoFactorAuth.
     * @example
     * // Delete one TwoFactorAuth
     * const TwoFactorAuth = await prisma.twoFactorAuth.delete({
     *   where: {
     *     // ... filter to delete one TwoFactorAuth
     *   }
     * })
     * 
     */
    delete<T extends TwoFactorAuthDeleteArgs>(args: SelectSubset<T, TwoFactorAuthDeleteArgs<ExtArgs>>): Prisma__TwoFactorAuthClient<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TwoFactorAuth.
     * @param {TwoFactorAuthUpdateArgs} args - Arguments to update one TwoFactorAuth.
     * @example
     * // Update one TwoFactorAuth
     * const twoFactorAuth = await prisma.twoFactorAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TwoFactorAuthUpdateArgs>(args: SelectSubset<T, TwoFactorAuthUpdateArgs<ExtArgs>>): Prisma__TwoFactorAuthClient<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TwoFactorAuths.
     * @param {TwoFactorAuthDeleteManyArgs} args - Arguments to filter TwoFactorAuths to delete.
     * @example
     * // Delete a few TwoFactorAuths
     * const { count } = await prisma.twoFactorAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TwoFactorAuthDeleteManyArgs>(args?: SelectSubset<T, TwoFactorAuthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwoFactorAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwoFactorAuths
     * const twoFactorAuth = await prisma.twoFactorAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TwoFactorAuthUpdateManyArgs>(args: SelectSubset<T, TwoFactorAuthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwoFactorAuths and returns the data updated in the database.
     * @param {TwoFactorAuthUpdateManyAndReturnArgs} args - Arguments to update many TwoFactorAuths.
     * @example
     * // Update many TwoFactorAuths
     * const twoFactorAuth = await prisma.twoFactorAuth.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TwoFactorAuths and only return the `id`
     * const twoFactorAuthWithIdOnly = await prisma.twoFactorAuth.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TwoFactorAuthUpdateManyAndReturnArgs>(args: SelectSubset<T, TwoFactorAuthUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TwoFactorAuth.
     * @param {TwoFactorAuthUpsertArgs} args - Arguments to update or create a TwoFactorAuth.
     * @example
     * // Update or create a TwoFactorAuth
     * const twoFactorAuth = await prisma.twoFactorAuth.upsert({
     *   create: {
     *     // ... data to create a TwoFactorAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwoFactorAuth we want to update
     *   }
     * })
     */
    upsert<T extends TwoFactorAuthUpsertArgs>(args: SelectSubset<T, TwoFactorAuthUpsertArgs<ExtArgs>>): Prisma__TwoFactorAuthClient<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TwoFactorAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAuthCountArgs} args - Arguments to filter TwoFactorAuths to count.
     * @example
     * // Count the number of TwoFactorAuths
     * const count = await prisma.twoFactorAuth.count({
     *   where: {
     *     // ... the filter for the TwoFactorAuths we want to count
     *   }
     * })
    **/
    count<T extends TwoFactorAuthCountArgs>(
      args?: Subset<T, TwoFactorAuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwoFactorAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwoFactorAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwoFactorAuthAggregateArgs>(args: Subset<T, TwoFactorAuthAggregateArgs>): Prisma.PrismaPromise<GetTwoFactorAuthAggregateType<T>>

    /**
     * Group by TwoFactorAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwoFactorAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwoFactorAuthGroupByArgs['orderBy'] }
        : { orderBy?: TwoFactorAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwoFactorAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwoFactorAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TwoFactorAuth model
   */
  readonly fields: TwoFactorAuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TwoFactorAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TwoFactorAuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TwoFactorAuth model
   */
  interface TwoFactorAuthFieldRefs {
    readonly id: FieldRef<"TwoFactorAuth", 'String'>
    readonly userId: FieldRef<"TwoFactorAuth", 'String'>
    readonly method: FieldRef<"TwoFactorAuth", 'String'>
    readonly secretKey: FieldRef<"TwoFactorAuth", 'String'>
    readonly backupCodes: FieldRef<"TwoFactorAuth", 'Json'>
    readonly enabled: FieldRef<"TwoFactorAuth", 'Boolean'>
    readonly lastVerifiedAt: FieldRef<"TwoFactorAuth", 'DateTime'>
    readonly recoveryEmail: FieldRef<"TwoFactorAuth", 'String'>
    readonly recoveryPhone: FieldRef<"TwoFactorAuth", 'String'>
    readonly createdAt: FieldRef<"TwoFactorAuth", 'DateTime'>
    readonly updatedAt: FieldRef<"TwoFactorAuth", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TwoFactorAuth findUnique
   */
  export type TwoFactorAuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorAuth to fetch.
     */
    where: TwoFactorAuthWhereUniqueInput
  }

  /**
   * TwoFactorAuth findUniqueOrThrow
   */
  export type TwoFactorAuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorAuth to fetch.
     */
    where: TwoFactorAuthWhereUniqueInput
  }

  /**
   * TwoFactorAuth findFirst
   */
  export type TwoFactorAuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorAuth to fetch.
     */
    where?: TwoFactorAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorAuths to fetch.
     */
    orderBy?: TwoFactorAuthOrderByWithRelationInput | TwoFactorAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactorAuths.
     */
    cursor?: TwoFactorAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactorAuths.
     */
    distinct?: TwoFactorAuthScalarFieldEnum | TwoFactorAuthScalarFieldEnum[]
  }

  /**
   * TwoFactorAuth findFirstOrThrow
   */
  export type TwoFactorAuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorAuth to fetch.
     */
    where?: TwoFactorAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorAuths to fetch.
     */
    orderBy?: TwoFactorAuthOrderByWithRelationInput | TwoFactorAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactorAuths.
     */
    cursor?: TwoFactorAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactorAuths.
     */
    distinct?: TwoFactorAuthScalarFieldEnum | TwoFactorAuthScalarFieldEnum[]
  }

  /**
   * TwoFactorAuth findMany
   */
  export type TwoFactorAuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorAuths to fetch.
     */
    where?: TwoFactorAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorAuths to fetch.
     */
    orderBy?: TwoFactorAuthOrderByWithRelationInput | TwoFactorAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwoFactorAuths.
     */
    cursor?: TwoFactorAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorAuths.
     */
    skip?: number
    distinct?: TwoFactorAuthScalarFieldEnum | TwoFactorAuthScalarFieldEnum[]
  }

  /**
   * TwoFactorAuth create
   */
  export type TwoFactorAuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * The data needed to create a TwoFactorAuth.
     */
    data: XOR<TwoFactorAuthCreateInput, TwoFactorAuthUncheckedCreateInput>
  }

  /**
   * TwoFactorAuth createMany
   */
  export type TwoFactorAuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TwoFactorAuths.
     */
    data: TwoFactorAuthCreateManyInput | TwoFactorAuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TwoFactorAuth createManyAndReturn
   */
  export type TwoFactorAuthCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * The data used to create many TwoFactorAuths.
     */
    data: TwoFactorAuthCreateManyInput | TwoFactorAuthCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TwoFactorAuth update
   */
  export type TwoFactorAuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * The data needed to update a TwoFactorAuth.
     */
    data: XOR<TwoFactorAuthUpdateInput, TwoFactorAuthUncheckedUpdateInput>
    /**
     * Choose, which TwoFactorAuth to update.
     */
    where: TwoFactorAuthWhereUniqueInput
  }

  /**
   * TwoFactorAuth updateMany
   */
  export type TwoFactorAuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TwoFactorAuths.
     */
    data: XOR<TwoFactorAuthUpdateManyMutationInput, TwoFactorAuthUncheckedUpdateManyInput>
    /**
     * Filter which TwoFactorAuths to update
     */
    where?: TwoFactorAuthWhereInput
    /**
     * Limit how many TwoFactorAuths to update.
     */
    limit?: number
  }

  /**
   * TwoFactorAuth updateManyAndReturn
   */
  export type TwoFactorAuthUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * The data used to update TwoFactorAuths.
     */
    data: XOR<TwoFactorAuthUpdateManyMutationInput, TwoFactorAuthUncheckedUpdateManyInput>
    /**
     * Filter which TwoFactorAuths to update
     */
    where?: TwoFactorAuthWhereInput
    /**
     * Limit how many TwoFactorAuths to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TwoFactorAuth upsert
   */
  export type TwoFactorAuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * The filter to search for the TwoFactorAuth to update in case it exists.
     */
    where: TwoFactorAuthWhereUniqueInput
    /**
     * In case the TwoFactorAuth found by the `where` argument doesn't exist, create a new TwoFactorAuth with this data.
     */
    create: XOR<TwoFactorAuthCreateInput, TwoFactorAuthUncheckedCreateInput>
    /**
     * In case the TwoFactorAuth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwoFactorAuthUpdateInput, TwoFactorAuthUncheckedUpdateInput>
  }

  /**
   * TwoFactorAuth delete
   */
  export type TwoFactorAuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * Filter which TwoFactorAuth to delete.
     */
    where: TwoFactorAuthWhereUniqueInput
  }

  /**
   * TwoFactorAuth deleteMany
   */
  export type TwoFactorAuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactorAuths to delete
     */
    where?: TwoFactorAuthWhereInput
    /**
     * Limit how many TwoFactorAuths to delete.
     */
    limit?: number
  }

  /**
   * TwoFactorAuth without action
   */
  export type TwoFactorAuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    deviceFingerprint: string | null
    ipAddressHash: string | null
    userAgent: string | null
    lastActivityAt: Date | null
    expiresAt: Date | null
    revoked: boolean | null
    createdAt: Date | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    deviceFingerprint: string | null
    ipAddressHash: string | null
    userAgent: string | null
    lastActivityAt: Date | null
    expiresAt: Date | null
    revoked: boolean | null
    createdAt: Date | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    deviceFingerprint: number
    ipAddressHash: number
    userAgent: number
    lastActivityAt: number
    expiresAt: number
    revoked: number
    createdAt: number
    _all: number
  }


  export type UserSessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    deviceFingerprint?: true
    ipAddressHash?: true
    userAgent?: true
    lastActivityAt?: true
    expiresAt?: true
    revoked?: true
    createdAt?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    deviceFingerprint?: true
    ipAddressHash?: true
    userAgent?: true
    lastActivityAt?: true
    expiresAt?: true
    revoked?: true
    createdAt?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    deviceFingerprint?: true
    ipAddressHash?: true
    userAgent?: true
    lastActivityAt?: true
    expiresAt?: true
    revoked?: true
    createdAt?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    deviceFingerprint: string
    ipAddressHash: string
    userAgent: string | null
    lastActivityAt: Date
    expiresAt: Date
    revoked: boolean
    createdAt: Date
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    deviceFingerprint?: boolean
    ipAddressHash?: boolean
    userAgent?: boolean
    lastActivityAt?: boolean
    expiresAt?: boolean
    revoked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    deviceFingerprint?: boolean
    ipAddressHash?: boolean
    userAgent?: boolean
    lastActivityAt?: boolean
    expiresAt?: boolean
    revoked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    deviceFingerprint?: boolean
    ipAddressHash?: boolean
    userAgent?: boolean
    lastActivityAt?: boolean
    expiresAt?: boolean
    revoked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    deviceFingerprint?: boolean
    ipAddressHash?: boolean
    userAgent?: boolean
    lastActivityAt?: boolean
    expiresAt?: boolean
    revoked?: boolean
    createdAt?: boolean
  }

  export type UserSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "deviceFingerprint" | "ipAddressHash" | "userAgent" | "lastActivityAt" | "expiresAt" | "revoked" | "createdAt", ExtArgs["result"]["userSession"]>
  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      deviceFingerprint: string
      ipAddressHash: string
      userAgent: string | null
      lastActivityAt: Date
      expiresAt: Date
      revoked: boolean
      createdAt: Date
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions and returns the data updated in the database.
     * @param {UserSessionUpdateManyAndReturnArgs} args - Arguments to update many UserSessions.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'String'>
    readonly userId: FieldRef<"UserSession", 'String'>
    readonly token: FieldRef<"UserSession", 'String'>
    readonly deviceFingerprint: FieldRef<"UserSession", 'String'>
    readonly ipAddressHash: FieldRef<"UserSession", 'String'>
    readonly userAgent: FieldRef<"UserSession", 'String'>
    readonly lastActivityAt: FieldRef<"UserSession", 'DateTime'>
    readonly expiresAt: FieldRef<"UserSession", 'DateTime'>
    readonly revoked: FieldRef<"UserSession", 'Boolean'>
    readonly createdAt: FieldRef<"UserSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
  }

  /**
   * UserSession updateManyAndReturn
   */
  export type UserSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to delete.
     */
    limit?: number
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model LoginAttempt
   */

  export type AggregateLoginAttempt = {
    _count: LoginAttemptCountAggregateOutputType | null
    _avg: LoginAttemptAvgAggregateOutputType | null
    _sum: LoginAttemptSumAggregateOutputType | null
    _min: LoginAttemptMinAggregateOutputType | null
    _max: LoginAttemptMaxAggregateOutputType | null
  }

  export type LoginAttemptAvgAggregateOutputType = {
    riskScore: number | null
  }

  export type LoginAttemptSumAggregateOutputType = {
    riskScore: number | null
  }

  export type LoginAttemptMinAggregateOutputType = {
    id: string | null
    emailHash: string | null
    ipAddressHash: string | null
    success: boolean | null
    deviceFingerprint: string | null
    country: string | null
    region: string | null
    city: string | null
    riskScore: number | null
    userId: string | null
    createdAt: Date | null
  }

  export type LoginAttemptMaxAggregateOutputType = {
    id: string | null
    emailHash: string | null
    ipAddressHash: string | null
    success: boolean | null
    deviceFingerprint: string | null
    country: string | null
    region: string | null
    city: string | null
    riskScore: number | null
    userId: string | null
    createdAt: Date | null
  }

  export type LoginAttemptCountAggregateOutputType = {
    id: number
    emailHash: number
    ipAddressHash: number
    success: number
    deviceFingerprint: number
    country: number
    region: number
    city: number
    riskScore: number
    userId: number
    createdAt: number
    _all: number
  }


  export type LoginAttemptAvgAggregateInputType = {
    riskScore?: true
  }

  export type LoginAttemptSumAggregateInputType = {
    riskScore?: true
  }

  export type LoginAttemptMinAggregateInputType = {
    id?: true
    emailHash?: true
    ipAddressHash?: true
    success?: true
    deviceFingerprint?: true
    country?: true
    region?: true
    city?: true
    riskScore?: true
    userId?: true
    createdAt?: true
  }

  export type LoginAttemptMaxAggregateInputType = {
    id?: true
    emailHash?: true
    ipAddressHash?: true
    success?: true
    deviceFingerprint?: true
    country?: true
    region?: true
    city?: true
    riskScore?: true
    userId?: true
    createdAt?: true
  }

  export type LoginAttemptCountAggregateInputType = {
    id?: true
    emailHash?: true
    ipAddressHash?: true
    success?: true
    deviceFingerprint?: true
    country?: true
    region?: true
    city?: true
    riskScore?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type LoginAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoginAttempt to aggregate.
     */
    where?: LoginAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginAttempts to fetch.
     */
    orderBy?: LoginAttemptOrderByWithRelationInput | LoginAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoginAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoginAttempts
    **/
    _count?: true | LoginAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoginAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoginAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoginAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoginAttemptMaxAggregateInputType
  }

  export type GetLoginAttemptAggregateType<T extends LoginAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateLoginAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoginAttempt[P]>
      : GetScalarType<T[P], AggregateLoginAttempt[P]>
  }




  export type LoginAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoginAttemptWhereInput
    orderBy?: LoginAttemptOrderByWithAggregationInput | LoginAttemptOrderByWithAggregationInput[]
    by: LoginAttemptScalarFieldEnum[] | LoginAttemptScalarFieldEnum
    having?: LoginAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoginAttemptCountAggregateInputType | true
    _avg?: LoginAttemptAvgAggregateInputType
    _sum?: LoginAttemptSumAggregateInputType
    _min?: LoginAttemptMinAggregateInputType
    _max?: LoginAttemptMaxAggregateInputType
  }

  export type LoginAttemptGroupByOutputType = {
    id: string
    emailHash: string
    ipAddressHash: string
    success: boolean
    deviceFingerprint: string | null
    country: string | null
    region: string | null
    city: string | null
    riskScore: number | null
    userId: string | null
    createdAt: Date
    _count: LoginAttemptCountAggregateOutputType | null
    _avg: LoginAttemptAvgAggregateOutputType | null
    _sum: LoginAttemptSumAggregateOutputType | null
    _min: LoginAttemptMinAggregateOutputType | null
    _max: LoginAttemptMaxAggregateOutputType | null
  }

  type GetLoginAttemptGroupByPayload<T extends LoginAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoginAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoginAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoginAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], LoginAttemptGroupByOutputType[P]>
        }
      >
    >


  export type LoginAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailHash?: boolean
    ipAddressHash?: boolean
    success?: boolean
    deviceFingerprint?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    riskScore?: boolean
    userId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["loginAttempt"]>

  export type LoginAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailHash?: boolean
    ipAddressHash?: boolean
    success?: boolean
    deviceFingerprint?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    riskScore?: boolean
    userId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["loginAttempt"]>

  export type LoginAttemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailHash?: boolean
    ipAddressHash?: boolean
    success?: boolean
    deviceFingerprint?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    riskScore?: boolean
    userId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["loginAttempt"]>

  export type LoginAttemptSelectScalar = {
    id?: boolean
    emailHash?: boolean
    ipAddressHash?: boolean
    success?: boolean
    deviceFingerprint?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    riskScore?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type LoginAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "emailHash" | "ipAddressHash" | "success" | "deviceFingerprint" | "country" | "region" | "city" | "riskScore" | "userId" | "createdAt", ExtArgs["result"]["loginAttempt"]>

  export type $LoginAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoginAttempt"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      emailHash: string
      ipAddressHash: string
      success: boolean
      deviceFingerprint: string | null
      country: string | null
      region: string | null
      city: string | null
      riskScore: number | null
      userId: string | null
      createdAt: Date
    }, ExtArgs["result"]["loginAttempt"]>
    composites: {}
  }

  type LoginAttemptGetPayload<S extends boolean | null | undefined | LoginAttemptDefaultArgs> = $Result.GetResult<Prisma.$LoginAttemptPayload, S>

  type LoginAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoginAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoginAttemptCountAggregateInputType | true
    }

  export interface LoginAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoginAttempt'], meta: { name: 'LoginAttempt' } }
    /**
     * Find zero or one LoginAttempt that matches the filter.
     * @param {LoginAttemptFindUniqueArgs} args - Arguments to find a LoginAttempt
     * @example
     * // Get one LoginAttempt
     * const loginAttempt = await prisma.loginAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoginAttemptFindUniqueArgs>(args: SelectSubset<T, LoginAttemptFindUniqueArgs<ExtArgs>>): Prisma__LoginAttemptClient<$Result.GetResult<Prisma.$LoginAttemptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoginAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoginAttemptFindUniqueOrThrowArgs} args - Arguments to find a LoginAttempt
     * @example
     * // Get one LoginAttempt
     * const loginAttempt = await prisma.loginAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoginAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, LoginAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoginAttemptClient<$Result.GetResult<Prisma.$LoginAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoginAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAttemptFindFirstArgs} args - Arguments to find a LoginAttempt
     * @example
     * // Get one LoginAttempt
     * const loginAttempt = await prisma.loginAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoginAttemptFindFirstArgs>(args?: SelectSubset<T, LoginAttemptFindFirstArgs<ExtArgs>>): Prisma__LoginAttemptClient<$Result.GetResult<Prisma.$LoginAttemptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoginAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAttemptFindFirstOrThrowArgs} args - Arguments to find a LoginAttempt
     * @example
     * // Get one LoginAttempt
     * const loginAttempt = await prisma.loginAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoginAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, LoginAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoginAttemptClient<$Result.GetResult<Prisma.$LoginAttemptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoginAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoginAttempts
     * const loginAttempts = await prisma.loginAttempt.findMany()
     * 
     * // Get first 10 LoginAttempts
     * const loginAttempts = await prisma.loginAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loginAttemptWithIdOnly = await prisma.loginAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoginAttemptFindManyArgs>(args?: SelectSubset<T, LoginAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoginAttempt.
     * @param {LoginAttemptCreateArgs} args - Arguments to create a LoginAttempt.
     * @example
     * // Create one LoginAttempt
     * const LoginAttempt = await prisma.loginAttempt.create({
     *   data: {
     *     // ... data to create a LoginAttempt
     *   }
     * })
     * 
     */
    create<T extends LoginAttemptCreateArgs>(args: SelectSubset<T, LoginAttemptCreateArgs<ExtArgs>>): Prisma__LoginAttemptClient<$Result.GetResult<Prisma.$LoginAttemptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoginAttempts.
     * @param {LoginAttemptCreateManyArgs} args - Arguments to create many LoginAttempts.
     * @example
     * // Create many LoginAttempts
     * const loginAttempt = await prisma.loginAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoginAttemptCreateManyArgs>(args?: SelectSubset<T, LoginAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoginAttempts and returns the data saved in the database.
     * @param {LoginAttemptCreateManyAndReturnArgs} args - Arguments to create many LoginAttempts.
     * @example
     * // Create many LoginAttempts
     * const loginAttempt = await prisma.loginAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoginAttempts and only return the `id`
     * const loginAttemptWithIdOnly = await prisma.loginAttempt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoginAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, LoginAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginAttemptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LoginAttempt.
     * @param {LoginAttemptDeleteArgs} args - Arguments to delete one LoginAttempt.
     * @example
     * // Delete one LoginAttempt
     * const LoginAttempt = await prisma.loginAttempt.delete({
     *   where: {
     *     // ... filter to delete one LoginAttempt
     *   }
     * })
     * 
     */
    delete<T extends LoginAttemptDeleteArgs>(args: SelectSubset<T, LoginAttemptDeleteArgs<ExtArgs>>): Prisma__LoginAttemptClient<$Result.GetResult<Prisma.$LoginAttemptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoginAttempt.
     * @param {LoginAttemptUpdateArgs} args - Arguments to update one LoginAttempt.
     * @example
     * // Update one LoginAttempt
     * const loginAttempt = await prisma.loginAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoginAttemptUpdateArgs>(args: SelectSubset<T, LoginAttemptUpdateArgs<ExtArgs>>): Prisma__LoginAttemptClient<$Result.GetResult<Prisma.$LoginAttemptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoginAttempts.
     * @param {LoginAttemptDeleteManyArgs} args - Arguments to filter LoginAttempts to delete.
     * @example
     * // Delete a few LoginAttempts
     * const { count } = await prisma.loginAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoginAttemptDeleteManyArgs>(args?: SelectSubset<T, LoginAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoginAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoginAttempts
     * const loginAttempt = await prisma.loginAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoginAttemptUpdateManyArgs>(args: SelectSubset<T, LoginAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoginAttempts and returns the data updated in the database.
     * @param {LoginAttemptUpdateManyAndReturnArgs} args - Arguments to update many LoginAttempts.
     * @example
     * // Update many LoginAttempts
     * const loginAttempt = await prisma.loginAttempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LoginAttempts and only return the `id`
     * const loginAttemptWithIdOnly = await prisma.loginAttempt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoginAttemptUpdateManyAndReturnArgs>(args: SelectSubset<T, LoginAttemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginAttemptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LoginAttempt.
     * @param {LoginAttemptUpsertArgs} args - Arguments to update or create a LoginAttempt.
     * @example
     * // Update or create a LoginAttempt
     * const loginAttempt = await prisma.loginAttempt.upsert({
     *   create: {
     *     // ... data to create a LoginAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoginAttempt we want to update
     *   }
     * })
     */
    upsert<T extends LoginAttemptUpsertArgs>(args: SelectSubset<T, LoginAttemptUpsertArgs<ExtArgs>>): Prisma__LoginAttemptClient<$Result.GetResult<Prisma.$LoginAttemptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoginAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAttemptCountArgs} args - Arguments to filter LoginAttempts to count.
     * @example
     * // Count the number of LoginAttempts
     * const count = await prisma.loginAttempt.count({
     *   where: {
     *     // ... the filter for the LoginAttempts we want to count
     *   }
     * })
    **/
    count<T extends LoginAttemptCountArgs>(
      args?: Subset<T, LoginAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoginAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoginAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoginAttemptAggregateArgs>(args: Subset<T, LoginAttemptAggregateArgs>): Prisma.PrismaPromise<GetLoginAttemptAggregateType<T>>

    /**
     * Group by LoginAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoginAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoginAttemptGroupByArgs['orderBy'] }
        : { orderBy?: LoginAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoginAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoginAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoginAttempt model
   */
  readonly fields: LoginAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoginAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoginAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoginAttempt model
   */
  interface LoginAttemptFieldRefs {
    readonly id: FieldRef<"LoginAttempt", 'String'>
    readonly emailHash: FieldRef<"LoginAttempt", 'String'>
    readonly ipAddressHash: FieldRef<"LoginAttempt", 'String'>
    readonly success: FieldRef<"LoginAttempt", 'Boolean'>
    readonly deviceFingerprint: FieldRef<"LoginAttempt", 'String'>
    readonly country: FieldRef<"LoginAttempt", 'String'>
    readonly region: FieldRef<"LoginAttempt", 'String'>
    readonly city: FieldRef<"LoginAttempt", 'String'>
    readonly riskScore: FieldRef<"LoginAttempt", 'Int'>
    readonly userId: FieldRef<"LoginAttempt", 'String'>
    readonly createdAt: FieldRef<"LoginAttempt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoginAttempt findUnique
   */
  export type LoginAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAttempt
     */
    select?: LoginAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAttempt
     */
    omit?: LoginAttemptOmit<ExtArgs> | null
    /**
     * Filter, which LoginAttempt to fetch.
     */
    where: LoginAttemptWhereUniqueInput
  }

  /**
   * LoginAttempt findUniqueOrThrow
   */
  export type LoginAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAttempt
     */
    select?: LoginAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAttempt
     */
    omit?: LoginAttemptOmit<ExtArgs> | null
    /**
     * Filter, which LoginAttempt to fetch.
     */
    where: LoginAttemptWhereUniqueInput
  }

  /**
   * LoginAttempt findFirst
   */
  export type LoginAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAttempt
     */
    select?: LoginAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAttempt
     */
    omit?: LoginAttemptOmit<ExtArgs> | null
    /**
     * Filter, which LoginAttempt to fetch.
     */
    where?: LoginAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginAttempts to fetch.
     */
    orderBy?: LoginAttemptOrderByWithRelationInput | LoginAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoginAttempts.
     */
    cursor?: LoginAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoginAttempts.
     */
    distinct?: LoginAttemptScalarFieldEnum | LoginAttemptScalarFieldEnum[]
  }

  /**
   * LoginAttempt findFirstOrThrow
   */
  export type LoginAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAttempt
     */
    select?: LoginAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAttempt
     */
    omit?: LoginAttemptOmit<ExtArgs> | null
    /**
     * Filter, which LoginAttempt to fetch.
     */
    where?: LoginAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginAttempts to fetch.
     */
    orderBy?: LoginAttemptOrderByWithRelationInput | LoginAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoginAttempts.
     */
    cursor?: LoginAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoginAttempts.
     */
    distinct?: LoginAttemptScalarFieldEnum | LoginAttemptScalarFieldEnum[]
  }

  /**
   * LoginAttempt findMany
   */
  export type LoginAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAttempt
     */
    select?: LoginAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAttempt
     */
    omit?: LoginAttemptOmit<ExtArgs> | null
    /**
     * Filter, which LoginAttempts to fetch.
     */
    where?: LoginAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginAttempts to fetch.
     */
    orderBy?: LoginAttemptOrderByWithRelationInput | LoginAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoginAttempts.
     */
    cursor?: LoginAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginAttempts.
     */
    skip?: number
    distinct?: LoginAttemptScalarFieldEnum | LoginAttemptScalarFieldEnum[]
  }

  /**
   * LoginAttempt create
   */
  export type LoginAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAttempt
     */
    select?: LoginAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAttempt
     */
    omit?: LoginAttemptOmit<ExtArgs> | null
    /**
     * The data needed to create a LoginAttempt.
     */
    data: XOR<LoginAttemptCreateInput, LoginAttemptUncheckedCreateInput>
  }

  /**
   * LoginAttempt createMany
   */
  export type LoginAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoginAttempts.
     */
    data: LoginAttemptCreateManyInput | LoginAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoginAttempt createManyAndReturn
   */
  export type LoginAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAttempt
     */
    select?: LoginAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAttempt
     */
    omit?: LoginAttemptOmit<ExtArgs> | null
    /**
     * The data used to create many LoginAttempts.
     */
    data: LoginAttemptCreateManyInput | LoginAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoginAttempt update
   */
  export type LoginAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAttempt
     */
    select?: LoginAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAttempt
     */
    omit?: LoginAttemptOmit<ExtArgs> | null
    /**
     * The data needed to update a LoginAttempt.
     */
    data: XOR<LoginAttemptUpdateInput, LoginAttemptUncheckedUpdateInput>
    /**
     * Choose, which LoginAttempt to update.
     */
    where: LoginAttemptWhereUniqueInput
  }

  /**
   * LoginAttempt updateMany
   */
  export type LoginAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoginAttempts.
     */
    data: XOR<LoginAttemptUpdateManyMutationInput, LoginAttemptUncheckedUpdateManyInput>
    /**
     * Filter which LoginAttempts to update
     */
    where?: LoginAttemptWhereInput
    /**
     * Limit how many LoginAttempts to update.
     */
    limit?: number
  }

  /**
   * LoginAttempt updateManyAndReturn
   */
  export type LoginAttemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAttempt
     */
    select?: LoginAttemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAttempt
     */
    omit?: LoginAttemptOmit<ExtArgs> | null
    /**
     * The data used to update LoginAttempts.
     */
    data: XOR<LoginAttemptUpdateManyMutationInput, LoginAttemptUncheckedUpdateManyInput>
    /**
     * Filter which LoginAttempts to update
     */
    where?: LoginAttemptWhereInput
    /**
     * Limit how many LoginAttempts to update.
     */
    limit?: number
  }

  /**
   * LoginAttempt upsert
   */
  export type LoginAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAttempt
     */
    select?: LoginAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAttempt
     */
    omit?: LoginAttemptOmit<ExtArgs> | null
    /**
     * The filter to search for the LoginAttempt to update in case it exists.
     */
    where: LoginAttemptWhereUniqueInput
    /**
     * In case the LoginAttempt found by the `where` argument doesn't exist, create a new LoginAttempt with this data.
     */
    create: XOR<LoginAttemptCreateInput, LoginAttemptUncheckedCreateInput>
    /**
     * In case the LoginAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoginAttemptUpdateInput, LoginAttemptUncheckedUpdateInput>
  }

  /**
   * LoginAttempt delete
   */
  export type LoginAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAttempt
     */
    select?: LoginAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAttempt
     */
    omit?: LoginAttemptOmit<ExtArgs> | null
    /**
     * Filter which LoginAttempt to delete.
     */
    where: LoginAttemptWhereUniqueInput
  }

  /**
   * LoginAttempt deleteMany
   */
  export type LoginAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoginAttempts to delete
     */
    where?: LoginAttemptWhereInput
    /**
     * Limit how many LoginAttempts to delete.
     */
    limit?: number
  }

  /**
   * LoginAttempt without action
   */
  export type LoginAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAttempt
     */
    select?: LoginAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAttempt
     */
    omit?: LoginAttemptOmit<ExtArgs> | null
  }


  /**
   * Model Sport
   */

  export type AggregateSport = {
    _count: SportCountAggregateOutputType | null
    _avg: SportAvgAggregateOutputType | null
    _sum: SportSumAggregateOutputType | null
    _min: SportMinAggregateOutputType | null
    _max: SportMaxAggregateOutputType | null
  }

  export type SportAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type SportSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type SportMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    active: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SportMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    active: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SportCountAggregateOutputType = {
    id: number
    name: number
    code: number
    active: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SportAvgAggregateInputType = {
    displayOrder?: true
  }

  export type SportSumAggregateInputType = {
    displayOrder?: true
  }

  export type SportMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    active?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SportMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    active?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SportCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    active?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sport to aggregate.
     */
    where?: SportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sports to fetch.
     */
    orderBy?: SportOrderByWithRelationInput | SportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sports
    **/
    _count?: true | SportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SportMaxAggregateInputType
  }

  export type GetSportAggregateType<T extends SportAggregateArgs> = {
        [P in keyof T & keyof AggregateSport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSport[P]>
      : GetScalarType<T[P], AggregateSport[P]>
  }




  export type SportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SportWhereInput
    orderBy?: SportOrderByWithAggregationInput | SportOrderByWithAggregationInput[]
    by: SportScalarFieldEnum[] | SportScalarFieldEnum
    having?: SportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SportCountAggregateInputType | true
    _avg?: SportAvgAggregateInputType
    _sum?: SportSumAggregateInputType
    _min?: SportMinAggregateInputType
    _max?: SportMaxAggregateInputType
  }

  export type SportGroupByOutputType = {
    id: string
    name: string
    code: string
    active: boolean
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: SportCountAggregateOutputType | null
    _avg: SportAvgAggregateOutputType | null
    _sum: SportSumAggregateOutputType | null
    _min: SportMinAggregateOutputType | null
    _max: SportMaxAggregateOutputType | null
  }

  type GetSportGroupByPayload<T extends SportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SportGroupByOutputType[P]>
            : GetScalarType<T[P], SportGroupByOutputType[P]>
        }
      >
    >


  export type SportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    active?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    leagues?: boolean | Sport$leaguesArgs<ExtArgs>
    games?: boolean | Sport$gamesArgs<ExtArgs>
    _count?: boolean | SportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sport"]>

  export type SportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    active?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sport"]>

  export type SportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    active?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sport"]>

  export type SportSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    active?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "active" | "displayOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["sport"]>
  export type SportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leagues?: boolean | Sport$leaguesArgs<ExtArgs>
    games?: boolean | Sport$gamesArgs<ExtArgs>
    _count?: boolean | SportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sport"
    objects: {
      leagues: Prisma.$LeaguePayload<ExtArgs>[]
      games: Prisma.$GamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      active: boolean
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sport"]>
    composites: {}
  }

  type SportGetPayload<S extends boolean | null | undefined | SportDefaultArgs> = $Result.GetResult<Prisma.$SportPayload, S>

  type SportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SportCountAggregateInputType | true
    }

  export interface SportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sport'], meta: { name: 'Sport' } }
    /**
     * Find zero or one Sport that matches the filter.
     * @param {SportFindUniqueArgs} args - Arguments to find a Sport
     * @example
     * // Get one Sport
     * const sport = await prisma.sport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SportFindUniqueArgs>(args: SelectSubset<T, SportFindUniqueArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SportFindUniqueOrThrowArgs} args - Arguments to find a Sport
     * @example
     * // Get one Sport
     * const sport = await prisma.sport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SportFindUniqueOrThrowArgs>(args: SelectSubset<T, SportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportFindFirstArgs} args - Arguments to find a Sport
     * @example
     * // Get one Sport
     * const sport = await prisma.sport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SportFindFirstArgs>(args?: SelectSubset<T, SportFindFirstArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportFindFirstOrThrowArgs} args - Arguments to find a Sport
     * @example
     * // Get one Sport
     * const sport = await prisma.sport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SportFindFirstOrThrowArgs>(args?: SelectSubset<T, SportFindFirstOrThrowArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sports
     * const sports = await prisma.sport.findMany()
     * 
     * // Get first 10 Sports
     * const sports = await prisma.sport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sportWithIdOnly = await prisma.sport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SportFindManyArgs>(args?: SelectSubset<T, SportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sport.
     * @param {SportCreateArgs} args - Arguments to create a Sport.
     * @example
     * // Create one Sport
     * const Sport = await prisma.sport.create({
     *   data: {
     *     // ... data to create a Sport
     *   }
     * })
     * 
     */
    create<T extends SportCreateArgs>(args: SelectSubset<T, SportCreateArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sports.
     * @param {SportCreateManyArgs} args - Arguments to create many Sports.
     * @example
     * // Create many Sports
     * const sport = await prisma.sport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SportCreateManyArgs>(args?: SelectSubset<T, SportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sports and returns the data saved in the database.
     * @param {SportCreateManyAndReturnArgs} args - Arguments to create many Sports.
     * @example
     * // Create many Sports
     * const sport = await prisma.sport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sports and only return the `id`
     * const sportWithIdOnly = await prisma.sport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SportCreateManyAndReturnArgs>(args?: SelectSubset<T, SportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sport.
     * @param {SportDeleteArgs} args - Arguments to delete one Sport.
     * @example
     * // Delete one Sport
     * const Sport = await prisma.sport.delete({
     *   where: {
     *     // ... filter to delete one Sport
     *   }
     * })
     * 
     */
    delete<T extends SportDeleteArgs>(args: SelectSubset<T, SportDeleteArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sport.
     * @param {SportUpdateArgs} args - Arguments to update one Sport.
     * @example
     * // Update one Sport
     * const sport = await prisma.sport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SportUpdateArgs>(args: SelectSubset<T, SportUpdateArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sports.
     * @param {SportDeleteManyArgs} args - Arguments to filter Sports to delete.
     * @example
     * // Delete a few Sports
     * const { count } = await prisma.sport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SportDeleteManyArgs>(args?: SelectSubset<T, SportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sports
     * const sport = await prisma.sport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SportUpdateManyArgs>(args: SelectSubset<T, SportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sports and returns the data updated in the database.
     * @param {SportUpdateManyAndReturnArgs} args - Arguments to update many Sports.
     * @example
     * // Update many Sports
     * const sport = await prisma.sport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sports and only return the `id`
     * const sportWithIdOnly = await prisma.sport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SportUpdateManyAndReturnArgs>(args: SelectSubset<T, SportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sport.
     * @param {SportUpsertArgs} args - Arguments to update or create a Sport.
     * @example
     * // Update or create a Sport
     * const sport = await prisma.sport.upsert({
     *   create: {
     *     // ... data to create a Sport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sport we want to update
     *   }
     * })
     */
    upsert<T extends SportUpsertArgs>(args: SelectSubset<T, SportUpsertArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportCountArgs} args - Arguments to filter Sports to count.
     * @example
     * // Count the number of Sports
     * const count = await prisma.sport.count({
     *   where: {
     *     // ... the filter for the Sports we want to count
     *   }
     * })
    **/
    count<T extends SportCountArgs>(
      args?: Subset<T, SportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SportAggregateArgs>(args: Subset<T, SportAggregateArgs>): Prisma.PrismaPromise<GetSportAggregateType<T>>

    /**
     * Group by Sport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SportGroupByArgs['orderBy'] }
        : { orderBy?: SportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sport model
   */
  readonly fields: SportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    leagues<T extends Sport$leaguesArgs<ExtArgs> = {}>(args?: Subset<T, Sport$leaguesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    games<T extends Sport$gamesArgs<ExtArgs> = {}>(args?: Subset<T, Sport$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sport model
   */
  interface SportFieldRefs {
    readonly id: FieldRef<"Sport", 'String'>
    readonly name: FieldRef<"Sport", 'String'>
    readonly code: FieldRef<"Sport", 'String'>
    readonly active: FieldRef<"Sport", 'Boolean'>
    readonly displayOrder: FieldRef<"Sport", 'Int'>
    readonly createdAt: FieldRef<"Sport", 'DateTime'>
    readonly updatedAt: FieldRef<"Sport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sport findUnique
   */
  export type SportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter, which Sport to fetch.
     */
    where: SportWhereUniqueInput
  }

  /**
   * Sport findUniqueOrThrow
   */
  export type SportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter, which Sport to fetch.
     */
    where: SportWhereUniqueInput
  }

  /**
   * Sport findFirst
   */
  export type SportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter, which Sport to fetch.
     */
    where?: SportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sports to fetch.
     */
    orderBy?: SportOrderByWithRelationInput | SportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sports.
     */
    cursor?: SportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sports.
     */
    distinct?: SportScalarFieldEnum | SportScalarFieldEnum[]
  }

  /**
   * Sport findFirstOrThrow
   */
  export type SportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter, which Sport to fetch.
     */
    where?: SportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sports to fetch.
     */
    orderBy?: SportOrderByWithRelationInput | SportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sports.
     */
    cursor?: SportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sports.
     */
    distinct?: SportScalarFieldEnum | SportScalarFieldEnum[]
  }

  /**
   * Sport findMany
   */
  export type SportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter, which Sports to fetch.
     */
    where?: SportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sports to fetch.
     */
    orderBy?: SportOrderByWithRelationInput | SportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sports.
     */
    cursor?: SportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sports.
     */
    skip?: number
    distinct?: SportScalarFieldEnum | SportScalarFieldEnum[]
  }

  /**
   * Sport create
   */
  export type SportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * The data needed to create a Sport.
     */
    data: XOR<SportCreateInput, SportUncheckedCreateInput>
  }

  /**
   * Sport createMany
   */
  export type SportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sports.
     */
    data: SportCreateManyInput | SportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sport createManyAndReturn
   */
  export type SportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * The data used to create many Sports.
     */
    data: SportCreateManyInput | SportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sport update
   */
  export type SportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * The data needed to update a Sport.
     */
    data: XOR<SportUpdateInput, SportUncheckedUpdateInput>
    /**
     * Choose, which Sport to update.
     */
    where: SportWhereUniqueInput
  }

  /**
   * Sport updateMany
   */
  export type SportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sports.
     */
    data: XOR<SportUpdateManyMutationInput, SportUncheckedUpdateManyInput>
    /**
     * Filter which Sports to update
     */
    where?: SportWhereInput
    /**
     * Limit how many Sports to update.
     */
    limit?: number
  }

  /**
   * Sport updateManyAndReturn
   */
  export type SportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * The data used to update Sports.
     */
    data: XOR<SportUpdateManyMutationInput, SportUncheckedUpdateManyInput>
    /**
     * Filter which Sports to update
     */
    where?: SportWhereInput
    /**
     * Limit how many Sports to update.
     */
    limit?: number
  }

  /**
   * Sport upsert
   */
  export type SportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * The filter to search for the Sport to update in case it exists.
     */
    where: SportWhereUniqueInput
    /**
     * In case the Sport found by the `where` argument doesn't exist, create a new Sport with this data.
     */
    create: XOR<SportCreateInput, SportUncheckedCreateInput>
    /**
     * In case the Sport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SportUpdateInput, SportUncheckedUpdateInput>
  }

  /**
   * Sport delete
   */
  export type SportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter which Sport to delete.
     */
    where: SportWhereUniqueInput
  }

  /**
   * Sport deleteMany
   */
  export type SportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sports to delete
     */
    where?: SportWhereInput
    /**
     * Limit how many Sports to delete.
     */
    limit?: number
  }

  /**
   * Sport.leagues
   */
  export type Sport$leaguesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    where?: LeagueWhereInput
    orderBy?: LeagueOrderByWithRelationInput | LeagueOrderByWithRelationInput[]
    cursor?: LeagueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeagueScalarFieldEnum | LeagueScalarFieldEnum[]
  }

  /**
   * Sport.games
   */
  export type Sport$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Sport without action
   */
  export type SportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
  }


  /**
   * Model League
   */

  export type AggregateLeague = {
    _count: LeagueCountAggregateOutputType | null
    _min: LeagueMinAggregateOutputType | null
    _max: LeagueMaxAggregateOutputType | null
  }

  export type LeagueMinAggregateOutputType = {
    id: string | null
    sportId: string | null
    name: string | null
    code: string | null
    country: string | null
    region: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeagueMaxAggregateOutputType = {
    id: string | null
    sportId: string | null
    name: string | null
    code: string | null
    country: string | null
    region: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeagueCountAggregateOutputType = {
    id: number
    sportId: number
    name: number
    code: number
    country: number
    region: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeagueMinAggregateInputType = {
    id?: true
    sportId?: true
    name?: true
    code?: true
    country?: true
    region?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeagueMaxAggregateInputType = {
    id?: true
    sportId?: true
    name?: true
    code?: true
    country?: true
    region?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeagueCountAggregateInputType = {
    id?: true
    sportId?: true
    name?: true
    code?: true
    country?: true
    region?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeagueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which League to aggregate.
     */
    where?: LeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leagues to fetch.
     */
    orderBy?: LeagueOrderByWithRelationInput | LeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leagues
    **/
    _count?: true | LeagueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeagueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeagueMaxAggregateInputType
  }

  export type GetLeagueAggregateType<T extends LeagueAggregateArgs> = {
        [P in keyof T & keyof AggregateLeague]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeague[P]>
      : GetScalarType<T[P], AggregateLeague[P]>
  }




  export type LeagueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeagueWhereInput
    orderBy?: LeagueOrderByWithAggregationInput | LeagueOrderByWithAggregationInput[]
    by: LeagueScalarFieldEnum[] | LeagueScalarFieldEnum
    having?: LeagueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeagueCountAggregateInputType | true
    _min?: LeagueMinAggregateInputType
    _max?: LeagueMaxAggregateInputType
  }

  export type LeagueGroupByOutputType = {
    id: string
    sportId: string
    name: string
    code: string
    country: string | null
    region: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: LeagueCountAggregateOutputType | null
    _min: LeagueMinAggregateOutputType | null
    _max: LeagueMaxAggregateOutputType | null
  }

  type GetLeagueGroupByPayload<T extends LeagueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeagueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeagueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeagueGroupByOutputType[P]>
            : GetScalarType<T[P], LeagueGroupByOutputType[P]>
        }
      >
    >


  export type LeagueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sportId?: boolean
    name?: boolean
    code?: boolean
    country?: boolean
    region?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sport?: boolean | SportDefaultArgs<ExtArgs>
    teams?: boolean | League$teamsArgs<ExtArgs>
    games?: boolean | League$gamesArgs<ExtArgs>
    _count?: boolean | LeagueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["league"]>

  export type LeagueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sportId?: boolean
    name?: boolean
    code?: boolean
    country?: boolean
    region?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sport?: boolean | SportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["league"]>

  export type LeagueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sportId?: boolean
    name?: boolean
    code?: boolean
    country?: boolean
    region?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sport?: boolean | SportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["league"]>

  export type LeagueSelectScalar = {
    id?: boolean
    sportId?: boolean
    name?: boolean
    code?: boolean
    country?: boolean
    region?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeagueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sportId" | "name" | "code" | "country" | "region" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["league"]>
  export type LeagueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sport?: boolean | SportDefaultArgs<ExtArgs>
    teams?: boolean | League$teamsArgs<ExtArgs>
    games?: boolean | League$gamesArgs<ExtArgs>
    _count?: boolean | LeagueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeagueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sport?: boolean | SportDefaultArgs<ExtArgs>
  }
  export type LeagueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sport?: boolean | SportDefaultArgs<ExtArgs>
  }

  export type $LeaguePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "League"
    objects: {
      sport: Prisma.$SportPayload<ExtArgs>
      teams: Prisma.$TeamPayload<ExtArgs>[]
      games: Prisma.$GamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sportId: string
      name: string
      code: string
      country: string | null
      region: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["league"]>
    composites: {}
  }

  type LeagueGetPayload<S extends boolean | null | undefined | LeagueDefaultArgs> = $Result.GetResult<Prisma.$LeaguePayload, S>

  type LeagueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeagueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeagueCountAggregateInputType | true
    }

  export interface LeagueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['League'], meta: { name: 'League' } }
    /**
     * Find zero or one League that matches the filter.
     * @param {LeagueFindUniqueArgs} args - Arguments to find a League
     * @example
     * // Get one League
     * const league = await prisma.league.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeagueFindUniqueArgs>(args: SelectSubset<T, LeagueFindUniqueArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one League that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeagueFindUniqueOrThrowArgs} args - Arguments to find a League
     * @example
     * // Get one League
     * const league = await prisma.league.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeagueFindUniqueOrThrowArgs>(args: SelectSubset<T, LeagueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first League that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueFindFirstArgs} args - Arguments to find a League
     * @example
     * // Get one League
     * const league = await prisma.league.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeagueFindFirstArgs>(args?: SelectSubset<T, LeagueFindFirstArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first League that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueFindFirstOrThrowArgs} args - Arguments to find a League
     * @example
     * // Get one League
     * const league = await prisma.league.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeagueFindFirstOrThrowArgs>(args?: SelectSubset<T, LeagueFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leagues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leagues
     * const leagues = await prisma.league.findMany()
     * 
     * // Get first 10 Leagues
     * const leagues = await prisma.league.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leagueWithIdOnly = await prisma.league.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeagueFindManyArgs>(args?: SelectSubset<T, LeagueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a League.
     * @param {LeagueCreateArgs} args - Arguments to create a League.
     * @example
     * // Create one League
     * const League = await prisma.league.create({
     *   data: {
     *     // ... data to create a League
     *   }
     * })
     * 
     */
    create<T extends LeagueCreateArgs>(args: SelectSubset<T, LeagueCreateArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leagues.
     * @param {LeagueCreateManyArgs} args - Arguments to create many Leagues.
     * @example
     * // Create many Leagues
     * const league = await prisma.league.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeagueCreateManyArgs>(args?: SelectSubset<T, LeagueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leagues and returns the data saved in the database.
     * @param {LeagueCreateManyAndReturnArgs} args - Arguments to create many Leagues.
     * @example
     * // Create many Leagues
     * const league = await prisma.league.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leagues and only return the `id`
     * const leagueWithIdOnly = await prisma.league.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeagueCreateManyAndReturnArgs>(args?: SelectSubset<T, LeagueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a League.
     * @param {LeagueDeleteArgs} args - Arguments to delete one League.
     * @example
     * // Delete one League
     * const League = await prisma.league.delete({
     *   where: {
     *     // ... filter to delete one League
     *   }
     * })
     * 
     */
    delete<T extends LeagueDeleteArgs>(args: SelectSubset<T, LeagueDeleteArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one League.
     * @param {LeagueUpdateArgs} args - Arguments to update one League.
     * @example
     * // Update one League
     * const league = await prisma.league.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeagueUpdateArgs>(args: SelectSubset<T, LeagueUpdateArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leagues.
     * @param {LeagueDeleteManyArgs} args - Arguments to filter Leagues to delete.
     * @example
     * // Delete a few Leagues
     * const { count } = await prisma.league.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeagueDeleteManyArgs>(args?: SelectSubset<T, LeagueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leagues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leagues
     * const league = await prisma.league.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeagueUpdateManyArgs>(args: SelectSubset<T, LeagueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leagues and returns the data updated in the database.
     * @param {LeagueUpdateManyAndReturnArgs} args - Arguments to update many Leagues.
     * @example
     * // Update many Leagues
     * const league = await prisma.league.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leagues and only return the `id`
     * const leagueWithIdOnly = await prisma.league.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeagueUpdateManyAndReturnArgs>(args: SelectSubset<T, LeagueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one League.
     * @param {LeagueUpsertArgs} args - Arguments to update or create a League.
     * @example
     * // Update or create a League
     * const league = await prisma.league.upsert({
     *   create: {
     *     // ... data to create a League
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the League we want to update
     *   }
     * })
     */
    upsert<T extends LeagueUpsertArgs>(args: SelectSubset<T, LeagueUpsertArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leagues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueCountArgs} args - Arguments to filter Leagues to count.
     * @example
     * // Count the number of Leagues
     * const count = await prisma.league.count({
     *   where: {
     *     // ... the filter for the Leagues we want to count
     *   }
     * })
    **/
    count<T extends LeagueCountArgs>(
      args?: Subset<T, LeagueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeagueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a League.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeagueAggregateArgs>(args: Subset<T, LeagueAggregateArgs>): Prisma.PrismaPromise<GetLeagueAggregateType<T>>

    /**
     * Group by League.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeagueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeagueGroupByArgs['orderBy'] }
        : { orderBy?: LeagueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeagueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeagueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the League model
   */
  readonly fields: LeagueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for League.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeagueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sport<T extends SportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SportDefaultArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teams<T extends League$teamsArgs<ExtArgs> = {}>(args?: Subset<T, League$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    games<T extends League$gamesArgs<ExtArgs> = {}>(args?: Subset<T, League$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the League model
   */
  interface LeagueFieldRefs {
    readonly id: FieldRef<"League", 'String'>
    readonly sportId: FieldRef<"League", 'String'>
    readonly name: FieldRef<"League", 'String'>
    readonly code: FieldRef<"League", 'String'>
    readonly country: FieldRef<"League", 'String'>
    readonly region: FieldRef<"League", 'String'>
    readonly active: FieldRef<"League", 'Boolean'>
    readonly createdAt: FieldRef<"League", 'DateTime'>
    readonly updatedAt: FieldRef<"League", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * League findUnique
   */
  export type LeagueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter, which League to fetch.
     */
    where: LeagueWhereUniqueInput
  }

  /**
   * League findUniqueOrThrow
   */
  export type LeagueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter, which League to fetch.
     */
    where: LeagueWhereUniqueInput
  }

  /**
   * League findFirst
   */
  export type LeagueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter, which League to fetch.
     */
    where?: LeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leagues to fetch.
     */
    orderBy?: LeagueOrderByWithRelationInput | LeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leagues.
     */
    cursor?: LeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leagues.
     */
    distinct?: LeagueScalarFieldEnum | LeagueScalarFieldEnum[]
  }

  /**
   * League findFirstOrThrow
   */
  export type LeagueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter, which League to fetch.
     */
    where?: LeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leagues to fetch.
     */
    orderBy?: LeagueOrderByWithRelationInput | LeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leagues.
     */
    cursor?: LeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leagues.
     */
    distinct?: LeagueScalarFieldEnum | LeagueScalarFieldEnum[]
  }

  /**
   * League findMany
   */
  export type LeagueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter, which Leagues to fetch.
     */
    where?: LeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leagues to fetch.
     */
    orderBy?: LeagueOrderByWithRelationInput | LeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leagues.
     */
    cursor?: LeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leagues.
     */
    skip?: number
    distinct?: LeagueScalarFieldEnum | LeagueScalarFieldEnum[]
  }

  /**
   * League create
   */
  export type LeagueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * The data needed to create a League.
     */
    data: XOR<LeagueCreateInput, LeagueUncheckedCreateInput>
  }

  /**
   * League createMany
   */
  export type LeagueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leagues.
     */
    data: LeagueCreateManyInput | LeagueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * League createManyAndReturn
   */
  export type LeagueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * The data used to create many Leagues.
     */
    data: LeagueCreateManyInput | LeagueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * League update
   */
  export type LeagueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * The data needed to update a League.
     */
    data: XOR<LeagueUpdateInput, LeagueUncheckedUpdateInput>
    /**
     * Choose, which League to update.
     */
    where: LeagueWhereUniqueInput
  }

  /**
   * League updateMany
   */
  export type LeagueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leagues.
     */
    data: XOR<LeagueUpdateManyMutationInput, LeagueUncheckedUpdateManyInput>
    /**
     * Filter which Leagues to update
     */
    where?: LeagueWhereInput
    /**
     * Limit how many Leagues to update.
     */
    limit?: number
  }

  /**
   * League updateManyAndReturn
   */
  export type LeagueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * The data used to update Leagues.
     */
    data: XOR<LeagueUpdateManyMutationInput, LeagueUncheckedUpdateManyInput>
    /**
     * Filter which Leagues to update
     */
    where?: LeagueWhereInput
    /**
     * Limit how many Leagues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * League upsert
   */
  export type LeagueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * The filter to search for the League to update in case it exists.
     */
    where: LeagueWhereUniqueInput
    /**
     * In case the League found by the `where` argument doesn't exist, create a new League with this data.
     */
    create: XOR<LeagueCreateInput, LeagueUncheckedCreateInput>
    /**
     * In case the League was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeagueUpdateInput, LeagueUncheckedUpdateInput>
  }

  /**
   * League delete
   */
  export type LeagueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter which League to delete.
     */
    where: LeagueWhereUniqueInput
  }

  /**
   * League deleteMany
   */
  export type LeagueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leagues to delete
     */
    where?: LeagueWhereInput
    /**
     * Limit how many Leagues to delete.
     */
    limit?: number
  }

  /**
   * League.teams
   */
  export type League$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * League.games
   */
  export type League$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * League without action
   */
  export type LeagueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    leagueId: string | null
    name: string | null
    code: string | null
    logoUrl: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    leagueId: string | null
    name: string | null
    code: string | null
    logoUrl: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    leagueId: number
    name: number
    code: number
    logoUrl: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    leagueId?: true
    name?: true
    code?: true
    logoUrl?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    leagueId?: true
    name?: true
    code?: true
    logoUrl?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    leagueId?: true
    name?: true
    code?: true
    logoUrl?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    leagueId: string
    name: string
    code: string
    logoUrl: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    name?: boolean
    code?: boolean
    logoUrl?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    homeGames?: boolean | Team$homeGamesArgs<ExtArgs>
    awayGames?: boolean | Team$awayGamesArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    name?: boolean
    code?: boolean
    logoUrl?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    name?: boolean
    code?: boolean
    logoUrl?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    leagueId?: boolean
    name?: boolean
    code?: boolean
    logoUrl?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leagueId" | "name" | "code" | "logoUrl" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    homeGames?: boolean | Team$homeGamesArgs<ExtArgs>
    awayGames?: boolean | Team$awayGamesArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      league: Prisma.$LeaguePayload<ExtArgs>
      homeGames: Prisma.$GamePayload<ExtArgs>[]
      awayGames: Prisma.$GamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leagueId: string
      name: string
      code: string
      logoUrl: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    league<T extends LeagueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeagueDefaultArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    homeGames<T extends Team$homeGamesArgs<ExtArgs> = {}>(args?: Subset<T, Team$homeGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    awayGames<T extends Team$awayGamesArgs<ExtArgs> = {}>(args?: Subset<T, Team$awayGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly leagueId: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly code: FieldRef<"Team", 'String'>
    readonly logoUrl: FieldRef<"Team", 'String'>
    readonly active: FieldRef<"Team", 'Boolean'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.homeGames
   */
  export type Team$homeGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Team.awayGames
   */
  export type Team$awayGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model Game
   */

  export type AggregateGame = {
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  export type GameAvgAggregateOutputType = {
    homeScore: number | null
    awayScore: number | null
  }

  export type GameSumAggregateOutputType = {
    homeScore: number | null
    awayScore: number | null
  }

  export type GameMinAggregateOutputType = {
    id: string | null
    sportId: string | null
    leagueId: string | null
    homeTeamId: string | null
    awayTeamId: string | null
    scheduledStartAt: Date | null
    actualStartAt: Date | null
    status: string | null
    homeScore: number | null
    awayScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameMaxAggregateOutputType = {
    id: string | null
    sportId: string | null
    leagueId: string | null
    homeTeamId: string | null
    awayTeamId: string | null
    scheduledStartAt: Date | null
    actualStartAt: Date | null
    status: string | null
    homeScore: number | null
    awayScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameCountAggregateOutputType = {
    id: number
    sportId: number
    leagueId: number
    homeTeamId: number
    awayTeamId: number
    scheduledStartAt: number
    actualStartAt: number
    status: number
    homeScore: number
    awayScore: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameAvgAggregateInputType = {
    homeScore?: true
    awayScore?: true
  }

  export type GameSumAggregateInputType = {
    homeScore?: true
    awayScore?: true
  }

  export type GameMinAggregateInputType = {
    id?: true
    sportId?: true
    leagueId?: true
    homeTeamId?: true
    awayTeamId?: true
    scheduledStartAt?: true
    actualStartAt?: true
    status?: true
    homeScore?: true
    awayScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameMaxAggregateInputType = {
    id?: true
    sportId?: true
    leagueId?: true
    homeTeamId?: true
    awayTeamId?: true
    scheduledStartAt?: true
    actualStartAt?: true
    status?: true
    homeScore?: true
    awayScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameCountAggregateInputType = {
    id?: true
    sportId?: true
    leagueId?: true
    homeTeamId?: true
    awayTeamId?: true
    scheduledStartAt?: true
    actualStartAt?: true
    status?: true
    homeScore?: true
    awayScore?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Game to aggregate.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Games
    **/
    _count?: true | GameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameMaxAggregateInputType
  }

  export type GetGameAggregateType<T extends GameAggregateArgs> = {
        [P in keyof T & keyof AggregateGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame[P]>
      : GetScalarType<T[P], AggregateGame[P]>
  }




  export type GameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
    orderBy?: GameOrderByWithAggregationInput | GameOrderByWithAggregationInput[]
    by: GameScalarFieldEnum[] | GameScalarFieldEnum
    having?: GameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCountAggregateInputType | true
    _avg?: GameAvgAggregateInputType
    _sum?: GameSumAggregateInputType
    _min?: GameMinAggregateInputType
    _max?: GameMaxAggregateInputType
  }

  export type GameGroupByOutputType = {
    id: string
    sportId: string
    leagueId: string
    homeTeamId: string
    awayTeamId: string
    scheduledStartAt: Date
    actualStartAt: Date | null
    status: string
    homeScore: number | null
    awayScore: number | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  type GetGameGroupByPayload<T extends GameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameGroupByOutputType[P]>
            : GetScalarType<T[P], GameGroupByOutputType[P]>
        }
      >
    >


  export type GameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sportId?: boolean
    leagueId?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    scheduledStartAt?: boolean
    actualStartAt?: boolean
    status?: boolean
    homeScore?: boolean
    awayScore?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sport?: boolean | SportDefaultArgs<ExtArgs>
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    homeTeam?: boolean | TeamDefaultArgs<ExtArgs>
    awayTeam?: boolean | TeamDefaultArgs<ExtArgs>
    markets?: boolean | Game$marketsArgs<ExtArgs>
    syncStatus?: boolean | Game$syncStatusArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sportId?: boolean
    leagueId?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    scheduledStartAt?: boolean
    actualStartAt?: boolean
    status?: boolean
    homeScore?: boolean
    awayScore?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sport?: boolean | SportDefaultArgs<ExtArgs>
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    homeTeam?: boolean | TeamDefaultArgs<ExtArgs>
    awayTeam?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sportId?: boolean
    leagueId?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    scheduledStartAt?: boolean
    actualStartAt?: boolean
    status?: boolean
    homeScore?: boolean
    awayScore?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sport?: boolean | SportDefaultArgs<ExtArgs>
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    homeTeam?: boolean | TeamDefaultArgs<ExtArgs>
    awayTeam?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectScalar = {
    id?: boolean
    sportId?: boolean
    leagueId?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    scheduledStartAt?: boolean
    actualStartAt?: boolean
    status?: boolean
    homeScore?: boolean
    awayScore?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sportId" | "leagueId" | "homeTeamId" | "awayTeamId" | "scheduledStartAt" | "actualStartAt" | "status" | "homeScore" | "awayScore" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["game"]>
  export type GameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sport?: boolean | SportDefaultArgs<ExtArgs>
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    homeTeam?: boolean | TeamDefaultArgs<ExtArgs>
    awayTeam?: boolean | TeamDefaultArgs<ExtArgs>
    markets?: boolean | Game$marketsArgs<ExtArgs>
    syncStatus?: boolean | Game$syncStatusArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sport?: boolean | SportDefaultArgs<ExtArgs>
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    homeTeam?: boolean | TeamDefaultArgs<ExtArgs>
    awayTeam?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type GameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sport?: boolean | SportDefaultArgs<ExtArgs>
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    homeTeam?: boolean | TeamDefaultArgs<ExtArgs>
    awayTeam?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $GamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Game"
    objects: {
      sport: Prisma.$SportPayload<ExtArgs>
      league: Prisma.$LeaguePayload<ExtArgs>
      homeTeam: Prisma.$TeamPayload<ExtArgs>
      awayTeam: Prisma.$TeamPayload<ExtArgs>
      markets: Prisma.$BetMarketPayload<ExtArgs>[]
      syncStatus: Prisma.$OddsSyncStatusPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sportId: string
      leagueId: string
      homeTeamId: string
      awayTeamId: string
      scheduledStartAt: Date
      actualStartAt: Date | null
      status: string
      homeScore: number | null
      awayScore: number | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["game"]>
    composites: {}
  }

  type GameGetPayload<S extends boolean | null | undefined | GameDefaultArgs> = $Result.GetResult<Prisma.$GamePayload, S>

  type GameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameCountAggregateInputType | true
    }

  export interface GameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Game'], meta: { name: 'Game' } }
    /**
     * Find zero or one Game that matches the filter.
     * @param {GameFindUniqueArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameFindUniqueArgs>(args: SelectSubset<T, GameFindUniqueArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Game that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameFindUniqueOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameFindUniqueOrThrowArgs>(args: SelectSubset<T, GameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameFindFirstArgs>(args?: SelectSubset<T, GameFindFirstArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameFindFirstOrThrowArgs>(args?: SelectSubset<T, GameFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.game.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameWithIdOnly = await prisma.game.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameFindManyArgs>(args?: SelectSubset<T, GameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Game.
     * @param {GameCreateArgs} args - Arguments to create a Game.
     * @example
     * // Create one Game
     * const Game = await prisma.game.create({
     *   data: {
     *     // ... data to create a Game
     *   }
     * })
     * 
     */
    create<T extends GameCreateArgs>(args: SelectSubset<T, GameCreateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Games.
     * @param {GameCreateManyArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameCreateManyArgs>(args?: SelectSubset<T, GameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Games and returns the data saved in the database.
     * @param {GameCreateManyAndReturnArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameCreateManyAndReturnArgs>(args?: SelectSubset<T, GameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Game.
     * @param {GameDeleteArgs} args - Arguments to delete one Game.
     * @example
     * // Delete one Game
     * const Game = await prisma.game.delete({
     *   where: {
     *     // ... filter to delete one Game
     *   }
     * })
     * 
     */
    delete<T extends GameDeleteArgs>(args: SelectSubset<T, GameDeleteArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Game.
     * @param {GameUpdateArgs} args - Arguments to update one Game.
     * @example
     * // Update one Game
     * const game = await prisma.game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameUpdateArgs>(args: SelectSubset<T, GameUpdateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Games.
     * @param {GameDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameDeleteManyArgs>(args?: SelectSubset<T, GameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameUpdateManyArgs>(args: SelectSubset<T, GameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games and returns the data updated in the database.
     * @param {GameUpdateManyAndReturnArgs} args - Arguments to update many Games.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameUpdateManyAndReturnArgs>(args: SelectSubset<T, GameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Game.
     * @param {GameUpsertArgs} args - Arguments to update or create a Game.
     * @example
     * // Update or create a Game
     * const game = await prisma.game.upsert({
     *   create: {
     *     // ... data to create a Game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game we want to update
     *   }
     * })
     */
    upsert<T extends GameUpsertArgs>(args: SelectSubset<T, GameUpsertArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.game.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends GameCountArgs>(
      args?: Subset<T, GameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAggregateArgs>(args: Subset<T, GameAggregateArgs>): Prisma.PrismaPromise<GetGameAggregateType<T>>

    /**
     * Group by Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameGroupByArgs['orderBy'] }
        : { orderBy?: GameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Game model
   */
  readonly fields: GameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sport<T extends SportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SportDefaultArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    league<T extends LeagueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeagueDefaultArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    homeTeam<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    awayTeam<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    markets<T extends Game$marketsArgs<ExtArgs> = {}>(args?: Subset<T, Game$marketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetMarketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    syncStatus<T extends Game$syncStatusArgs<ExtArgs> = {}>(args?: Subset<T, Game$syncStatusArgs<ExtArgs>>): Prisma__OddsSyncStatusClient<$Result.GetResult<Prisma.$OddsSyncStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Game model
   */
  interface GameFieldRefs {
    readonly id: FieldRef<"Game", 'String'>
    readonly sportId: FieldRef<"Game", 'String'>
    readonly leagueId: FieldRef<"Game", 'String'>
    readonly homeTeamId: FieldRef<"Game", 'String'>
    readonly awayTeamId: FieldRef<"Game", 'String'>
    readonly scheduledStartAt: FieldRef<"Game", 'DateTime'>
    readonly actualStartAt: FieldRef<"Game", 'DateTime'>
    readonly status: FieldRef<"Game", 'String'>
    readonly homeScore: FieldRef<"Game", 'Int'>
    readonly awayScore: FieldRef<"Game", 'Int'>
    readonly metadata: FieldRef<"Game", 'Json'>
    readonly createdAt: FieldRef<"Game", 'DateTime'>
    readonly updatedAt: FieldRef<"Game", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Game findUnique
   */
  export type GameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findUniqueOrThrow
   */
  export type GameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findFirst
   */
  export type GameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findFirstOrThrow
   */
  export type GameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findMany
   */
  export type GameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Games to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game create
   */
  export type GameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to create a Game.
     */
    data: XOR<GameCreateInput, GameUncheckedCreateInput>
  }

  /**
   * Game createMany
   */
  export type GameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Game createManyAndReturn
   */
  export type GameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Game update
   */
  export type GameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to update a Game.
     */
    data: XOR<GameUpdateInput, GameUncheckedUpdateInput>
    /**
     * Choose, which Game to update.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game updateMany
   */
  export type GameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to update.
     */
    limit?: number
  }

  /**
   * Game updateManyAndReturn
   */
  export type GameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Game upsert
   */
  export type GameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The filter to search for the Game to update in case it exists.
     */
    where: GameWhereUniqueInput
    /**
     * In case the Game found by the `where` argument doesn't exist, create a new Game with this data.
     */
    create: XOR<GameCreateInput, GameUncheckedCreateInput>
    /**
     * In case the Game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameUpdateInput, GameUncheckedUpdateInput>
  }

  /**
   * Game delete
   */
  export type GameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter which Game to delete.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game deleteMany
   */
  export type GameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Games to delete
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to delete.
     */
    limit?: number
  }

  /**
   * Game.markets
   */
  export type Game$marketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetMarket
     */
    select?: BetMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetMarket
     */
    omit?: BetMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetMarketInclude<ExtArgs> | null
    where?: BetMarketWhereInput
    orderBy?: BetMarketOrderByWithRelationInput | BetMarketOrderByWithRelationInput[]
    cursor?: BetMarketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BetMarketScalarFieldEnum | BetMarketScalarFieldEnum[]
  }

  /**
   * Game.syncStatus
   */
  export type Game$syncStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSyncStatus
     */
    select?: OddsSyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSyncStatus
     */
    omit?: OddsSyncStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSyncStatusInclude<ExtArgs> | null
    where?: OddsSyncStatusWhereInput
  }

  /**
   * Game without action
   */
  export type GameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
  }


  /**
   * Model BetMarket
   */

  export type AggregateBetMarket = {
    _count: BetMarketCountAggregateOutputType | null
    _min: BetMarketMinAggregateOutputType | null
    _max: BetMarketMaxAggregateOutputType | null
  }

  export type BetMarketMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    marketType: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BetMarketMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    marketType: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BetMarketCountAggregateOutputType = {
    id: number
    gameId: number
    marketType: number
    name: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BetMarketMinAggregateInputType = {
    id?: true
    gameId?: true
    marketType?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BetMarketMaxAggregateInputType = {
    id?: true
    gameId?: true
    marketType?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BetMarketCountAggregateInputType = {
    id?: true
    gameId?: true
    marketType?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BetMarketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BetMarket to aggregate.
     */
    where?: BetMarketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetMarkets to fetch.
     */
    orderBy?: BetMarketOrderByWithRelationInput | BetMarketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BetMarketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetMarkets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetMarkets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BetMarkets
    **/
    _count?: true | BetMarketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BetMarketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BetMarketMaxAggregateInputType
  }

  export type GetBetMarketAggregateType<T extends BetMarketAggregateArgs> = {
        [P in keyof T & keyof AggregateBetMarket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBetMarket[P]>
      : GetScalarType<T[P], AggregateBetMarket[P]>
  }




  export type BetMarketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetMarketWhereInput
    orderBy?: BetMarketOrderByWithAggregationInput | BetMarketOrderByWithAggregationInput[]
    by: BetMarketScalarFieldEnum[] | BetMarketScalarFieldEnum
    having?: BetMarketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BetMarketCountAggregateInputType | true
    _min?: BetMarketMinAggregateInputType
    _max?: BetMarketMaxAggregateInputType
  }

  export type BetMarketGroupByOutputType = {
    id: string
    gameId: string
    marketType: string
    name: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: BetMarketCountAggregateOutputType | null
    _min: BetMarketMinAggregateOutputType | null
    _max: BetMarketMaxAggregateOutputType | null
  }

  type GetBetMarketGroupByPayload<T extends BetMarketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BetMarketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BetMarketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BetMarketGroupByOutputType[P]>
            : GetScalarType<T[P], BetMarketGroupByOutputType[P]>
        }
      >
    >


  export type BetMarketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    marketType?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    selections?: boolean | BetMarket$selectionsArgs<ExtArgs>
    _count?: boolean | BetMarketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["betMarket"]>

  export type BetMarketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    marketType?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["betMarket"]>

  export type BetMarketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    marketType?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["betMarket"]>

  export type BetMarketSelectScalar = {
    id?: boolean
    gameId?: boolean
    marketType?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BetMarketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gameId" | "marketType" | "name" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["betMarket"]>
  export type BetMarketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    selections?: boolean | BetMarket$selectionsArgs<ExtArgs>
    _count?: boolean | BetMarketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BetMarketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type BetMarketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
  }

  export type $BetMarketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BetMarket"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
      selections: Prisma.$BetSelectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      marketType: string
      name: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["betMarket"]>
    composites: {}
  }

  type BetMarketGetPayload<S extends boolean | null | undefined | BetMarketDefaultArgs> = $Result.GetResult<Prisma.$BetMarketPayload, S>

  type BetMarketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BetMarketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BetMarketCountAggregateInputType | true
    }

  export interface BetMarketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BetMarket'], meta: { name: 'BetMarket' } }
    /**
     * Find zero or one BetMarket that matches the filter.
     * @param {BetMarketFindUniqueArgs} args - Arguments to find a BetMarket
     * @example
     * // Get one BetMarket
     * const betMarket = await prisma.betMarket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BetMarketFindUniqueArgs>(args: SelectSubset<T, BetMarketFindUniqueArgs<ExtArgs>>): Prisma__BetMarketClient<$Result.GetResult<Prisma.$BetMarketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BetMarket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BetMarketFindUniqueOrThrowArgs} args - Arguments to find a BetMarket
     * @example
     * // Get one BetMarket
     * const betMarket = await prisma.betMarket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BetMarketFindUniqueOrThrowArgs>(args: SelectSubset<T, BetMarketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BetMarketClient<$Result.GetResult<Prisma.$BetMarketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BetMarket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetMarketFindFirstArgs} args - Arguments to find a BetMarket
     * @example
     * // Get one BetMarket
     * const betMarket = await prisma.betMarket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BetMarketFindFirstArgs>(args?: SelectSubset<T, BetMarketFindFirstArgs<ExtArgs>>): Prisma__BetMarketClient<$Result.GetResult<Prisma.$BetMarketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BetMarket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetMarketFindFirstOrThrowArgs} args - Arguments to find a BetMarket
     * @example
     * // Get one BetMarket
     * const betMarket = await prisma.betMarket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BetMarketFindFirstOrThrowArgs>(args?: SelectSubset<T, BetMarketFindFirstOrThrowArgs<ExtArgs>>): Prisma__BetMarketClient<$Result.GetResult<Prisma.$BetMarketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BetMarkets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetMarketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BetMarkets
     * const betMarkets = await prisma.betMarket.findMany()
     * 
     * // Get first 10 BetMarkets
     * const betMarkets = await prisma.betMarket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const betMarketWithIdOnly = await prisma.betMarket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BetMarketFindManyArgs>(args?: SelectSubset<T, BetMarketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetMarketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BetMarket.
     * @param {BetMarketCreateArgs} args - Arguments to create a BetMarket.
     * @example
     * // Create one BetMarket
     * const BetMarket = await prisma.betMarket.create({
     *   data: {
     *     // ... data to create a BetMarket
     *   }
     * })
     * 
     */
    create<T extends BetMarketCreateArgs>(args: SelectSubset<T, BetMarketCreateArgs<ExtArgs>>): Prisma__BetMarketClient<$Result.GetResult<Prisma.$BetMarketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BetMarkets.
     * @param {BetMarketCreateManyArgs} args - Arguments to create many BetMarkets.
     * @example
     * // Create many BetMarkets
     * const betMarket = await prisma.betMarket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BetMarketCreateManyArgs>(args?: SelectSubset<T, BetMarketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BetMarkets and returns the data saved in the database.
     * @param {BetMarketCreateManyAndReturnArgs} args - Arguments to create many BetMarkets.
     * @example
     * // Create many BetMarkets
     * const betMarket = await prisma.betMarket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BetMarkets and only return the `id`
     * const betMarketWithIdOnly = await prisma.betMarket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BetMarketCreateManyAndReturnArgs>(args?: SelectSubset<T, BetMarketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetMarketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BetMarket.
     * @param {BetMarketDeleteArgs} args - Arguments to delete one BetMarket.
     * @example
     * // Delete one BetMarket
     * const BetMarket = await prisma.betMarket.delete({
     *   where: {
     *     // ... filter to delete one BetMarket
     *   }
     * })
     * 
     */
    delete<T extends BetMarketDeleteArgs>(args: SelectSubset<T, BetMarketDeleteArgs<ExtArgs>>): Prisma__BetMarketClient<$Result.GetResult<Prisma.$BetMarketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BetMarket.
     * @param {BetMarketUpdateArgs} args - Arguments to update one BetMarket.
     * @example
     * // Update one BetMarket
     * const betMarket = await prisma.betMarket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BetMarketUpdateArgs>(args: SelectSubset<T, BetMarketUpdateArgs<ExtArgs>>): Prisma__BetMarketClient<$Result.GetResult<Prisma.$BetMarketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BetMarkets.
     * @param {BetMarketDeleteManyArgs} args - Arguments to filter BetMarkets to delete.
     * @example
     * // Delete a few BetMarkets
     * const { count } = await prisma.betMarket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BetMarketDeleteManyArgs>(args?: SelectSubset<T, BetMarketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BetMarkets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetMarketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BetMarkets
     * const betMarket = await prisma.betMarket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BetMarketUpdateManyArgs>(args: SelectSubset<T, BetMarketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BetMarkets and returns the data updated in the database.
     * @param {BetMarketUpdateManyAndReturnArgs} args - Arguments to update many BetMarkets.
     * @example
     * // Update many BetMarkets
     * const betMarket = await prisma.betMarket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BetMarkets and only return the `id`
     * const betMarketWithIdOnly = await prisma.betMarket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BetMarketUpdateManyAndReturnArgs>(args: SelectSubset<T, BetMarketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetMarketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BetMarket.
     * @param {BetMarketUpsertArgs} args - Arguments to update or create a BetMarket.
     * @example
     * // Update or create a BetMarket
     * const betMarket = await prisma.betMarket.upsert({
     *   create: {
     *     // ... data to create a BetMarket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BetMarket we want to update
     *   }
     * })
     */
    upsert<T extends BetMarketUpsertArgs>(args: SelectSubset<T, BetMarketUpsertArgs<ExtArgs>>): Prisma__BetMarketClient<$Result.GetResult<Prisma.$BetMarketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BetMarkets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetMarketCountArgs} args - Arguments to filter BetMarkets to count.
     * @example
     * // Count the number of BetMarkets
     * const count = await prisma.betMarket.count({
     *   where: {
     *     // ... the filter for the BetMarkets we want to count
     *   }
     * })
    **/
    count<T extends BetMarketCountArgs>(
      args?: Subset<T, BetMarketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BetMarketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BetMarket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetMarketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BetMarketAggregateArgs>(args: Subset<T, BetMarketAggregateArgs>): Prisma.PrismaPromise<GetBetMarketAggregateType<T>>

    /**
     * Group by BetMarket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetMarketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BetMarketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BetMarketGroupByArgs['orderBy'] }
        : { orderBy?: BetMarketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BetMarketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBetMarketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BetMarket model
   */
  readonly fields: BetMarketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BetMarket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BetMarketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    selections<T extends BetMarket$selectionsArgs<ExtArgs> = {}>(args?: Subset<T, BetMarket$selectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetSelectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BetMarket model
   */
  interface BetMarketFieldRefs {
    readonly id: FieldRef<"BetMarket", 'String'>
    readonly gameId: FieldRef<"BetMarket", 'String'>
    readonly marketType: FieldRef<"BetMarket", 'String'>
    readonly name: FieldRef<"BetMarket", 'String'>
    readonly active: FieldRef<"BetMarket", 'Boolean'>
    readonly createdAt: FieldRef<"BetMarket", 'DateTime'>
    readonly updatedAt: FieldRef<"BetMarket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BetMarket findUnique
   */
  export type BetMarketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetMarket
     */
    select?: BetMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetMarket
     */
    omit?: BetMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetMarketInclude<ExtArgs> | null
    /**
     * Filter, which BetMarket to fetch.
     */
    where: BetMarketWhereUniqueInput
  }

  /**
   * BetMarket findUniqueOrThrow
   */
  export type BetMarketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetMarket
     */
    select?: BetMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetMarket
     */
    omit?: BetMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetMarketInclude<ExtArgs> | null
    /**
     * Filter, which BetMarket to fetch.
     */
    where: BetMarketWhereUniqueInput
  }

  /**
   * BetMarket findFirst
   */
  export type BetMarketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetMarket
     */
    select?: BetMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetMarket
     */
    omit?: BetMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetMarketInclude<ExtArgs> | null
    /**
     * Filter, which BetMarket to fetch.
     */
    where?: BetMarketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetMarkets to fetch.
     */
    orderBy?: BetMarketOrderByWithRelationInput | BetMarketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BetMarkets.
     */
    cursor?: BetMarketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetMarkets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetMarkets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BetMarkets.
     */
    distinct?: BetMarketScalarFieldEnum | BetMarketScalarFieldEnum[]
  }

  /**
   * BetMarket findFirstOrThrow
   */
  export type BetMarketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetMarket
     */
    select?: BetMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetMarket
     */
    omit?: BetMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetMarketInclude<ExtArgs> | null
    /**
     * Filter, which BetMarket to fetch.
     */
    where?: BetMarketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetMarkets to fetch.
     */
    orderBy?: BetMarketOrderByWithRelationInput | BetMarketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BetMarkets.
     */
    cursor?: BetMarketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetMarkets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetMarkets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BetMarkets.
     */
    distinct?: BetMarketScalarFieldEnum | BetMarketScalarFieldEnum[]
  }

  /**
   * BetMarket findMany
   */
  export type BetMarketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetMarket
     */
    select?: BetMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetMarket
     */
    omit?: BetMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetMarketInclude<ExtArgs> | null
    /**
     * Filter, which BetMarkets to fetch.
     */
    where?: BetMarketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetMarkets to fetch.
     */
    orderBy?: BetMarketOrderByWithRelationInput | BetMarketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BetMarkets.
     */
    cursor?: BetMarketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetMarkets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetMarkets.
     */
    skip?: number
    distinct?: BetMarketScalarFieldEnum | BetMarketScalarFieldEnum[]
  }

  /**
   * BetMarket create
   */
  export type BetMarketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetMarket
     */
    select?: BetMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetMarket
     */
    omit?: BetMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetMarketInclude<ExtArgs> | null
    /**
     * The data needed to create a BetMarket.
     */
    data: XOR<BetMarketCreateInput, BetMarketUncheckedCreateInput>
  }

  /**
   * BetMarket createMany
   */
  export type BetMarketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BetMarkets.
     */
    data: BetMarketCreateManyInput | BetMarketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BetMarket createManyAndReturn
   */
  export type BetMarketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetMarket
     */
    select?: BetMarketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BetMarket
     */
    omit?: BetMarketOmit<ExtArgs> | null
    /**
     * The data used to create many BetMarkets.
     */
    data: BetMarketCreateManyInput | BetMarketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetMarketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BetMarket update
   */
  export type BetMarketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetMarket
     */
    select?: BetMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetMarket
     */
    omit?: BetMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetMarketInclude<ExtArgs> | null
    /**
     * The data needed to update a BetMarket.
     */
    data: XOR<BetMarketUpdateInput, BetMarketUncheckedUpdateInput>
    /**
     * Choose, which BetMarket to update.
     */
    where: BetMarketWhereUniqueInput
  }

  /**
   * BetMarket updateMany
   */
  export type BetMarketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BetMarkets.
     */
    data: XOR<BetMarketUpdateManyMutationInput, BetMarketUncheckedUpdateManyInput>
    /**
     * Filter which BetMarkets to update
     */
    where?: BetMarketWhereInput
    /**
     * Limit how many BetMarkets to update.
     */
    limit?: number
  }

  /**
   * BetMarket updateManyAndReturn
   */
  export type BetMarketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetMarket
     */
    select?: BetMarketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BetMarket
     */
    omit?: BetMarketOmit<ExtArgs> | null
    /**
     * The data used to update BetMarkets.
     */
    data: XOR<BetMarketUpdateManyMutationInput, BetMarketUncheckedUpdateManyInput>
    /**
     * Filter which BetMarkets to update
     */
    where?: BetMarketWhereInput
    /**
     * Limit how many BetMarkets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetMarketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BetMarket upsert
   */
  export type BetMarketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetMarket
     */
    select?: BetMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetMarket
     */
    omit?: BetMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetMarketInclude<ExtArgs> | null
    /**
     * The filter to search for the BetMarket to update in case it exists.
     */
    where: BetMarketWhereUniqueInput
    /**
     * In case the BetMarket found by the `where` argument doesn't exist, create a new BetMarket with this data.
     */
    create: XOR<BetMarketCreateInput, BetMarketUncheckedCreateInput>
    /**
     * In case the BetMarket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BetMarketUpdateInput, BetMarketUncheckedUpdateInput>
  }

  /**
   * BetMarket delete
   */
  export type BetMarketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetMarket
     */
    select?: BetMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetMarket
     */
    omit?: BetMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetMarketInclude<ExtArgs> | null
    /**
     * Filter which BetMarket to delete.
     */
    where: BetMarketWhereUniqueInput
  }

  /**
   * BetMarket deleteMany
   */
  export type BetMarketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BetMarkets to delete
     */
    where?: BetMarketWhereInput
    /**
     * Limit how many BetMarkets to delete.
     */
    limit?: number
  }

  /**
   * BetMarket.selections
   */
  export type BetMarket$selectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelection
     */
    select?: BetSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelection
     */
    omit?: BetSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionInclude<ExtArgs> | null
    where?: BetSelectionWhereInput
    orderBy?: BetSelectionOrderByWithRelationInput | BetSelectionOrderByWithRelationInput[]
    cursor?: BetSelectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BetSelectionScalarFieldEnum | BetSelectionScalarFieldEnum[]
  }

  /**
   * BetMarket without action
   */
  export type BetMarketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetMarket
     */
    select?: BetMarketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetMarket
     */
    omit?: BetMarketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetMarketInclude<ExtArgs> | null
  }


  /**
   * Model BetSelection
   */

  export type AggregateBetSelection = {
    _count: BetSelectionCountAggregateOutputType | null
    _avg: BetSelectionAvgAggregateOutputType | null
    _sum: BetSelectionSumAggregateOutputType | null
    _min: BetSelectionMinAggregateOutputType | null
    _max: BetSelectionMaxAggregateOutputType | null
  }

  export type BetSelectionAvgAggregateOutputType = {
    odds: Decimal | null
  }

  export type BetSelectionSumAggregateOutputType = {
    odds: Decimal | null
  }

  export type BetSelectionMinAggregateOutputType = {
    id: string | null
    marketId: string | null
    name: string | null
    odds: Decimal | null
    status: string | null
    result: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BetSelectionMaxAggregateOutputType = {
    id: string | null
    marketId: string | null
    name: string | null
    odds: Decimal | null
    status: string | null
    result: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BetSelectionCountAggregateOutputType = {
    id: number
    marketId: number
    name: number
    odds: number
    status: number
    result: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BetSelectionAvgAggregateInputType = {
    odds?: true
  }

  export type BetSelectionSumAggregateInputType = {
    odds?: true
  }

  export type BetSelectionMinAggregateInputType = {
    id?: true
    marketId?: true
    name?: true
    odds?: true
    status?: true
    result?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BetSelectionMaxAggregateInputType = {
    id?: true
    marketId?: true
    name?: true
    odds?: true
    status?: true
    result?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BetSelectionCountAggregateInputType = {
    id?: true
    marketId?: true
    name?: true
    odds?: true
    status?: true
    result?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BetSelectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BetSelection to aggregate.
     */
    where?: BetSelectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetSelections to fetch.
     */
    orderBy?: BetSelectionOrderByWithRelationInput | BetSelectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BetSelectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetSelections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetSelections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BetSelections
    **/
    _count?: true | BetSelectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BetSelectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BetSelectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BetSelectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BetSelectionMaxAggregateInputType
  }

  export type GetBetSelectionAggregateType<T extends BetSelectionAggregateArgs> = {
        [P in keyof T & keyof AggregateBetSelection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBetSelection[P]>
      : GetScalarType<T[P], AggregateBetSelection[P]>
  }




  export type BetSelectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetSelectionWhereInput
    orderBy?: BetSelectionOrderByWithAggregationInput | BetSelectionOrderByWithAggregationInput[]
    by: BetSelectionScalarFieldEnum[] | BetSelectionScalarFieldEnum
    having?: BetSelectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BetSelectionCountAggregateInputType | true
    _avg?: BetSelectionAvgAggregateInputType
    _sum?: BetSelectionSumAggregateInputType
    _min?: BetSelectionMinAggregateInputType
    _max?: BetSelectionMaxAggregateInputType
  }

  export type BetSelectionGroupByOutputType = {
    id: string
    marketId: string
    name: string
    odds: Decimal
    status: string
    result: string | null
    createdAt: Date
    updatedAt: Date
    _count: BetSelectionCountAggregateOutputType | null
    _avg: BetSelectionAvgAggregateOutputType | null
    _sum: BetSelectionSumAggregateOutputType | null
    _min: BetSelectionMinAggregateOutputType | null
    _max: BetSelectionMaxAggregateOutputType | null
  }

  type GetBetSelectionGroupByPayload<T extends BetSelectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BetSelectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BetSelectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BetSelectionGroupByOutputType[P]>
            : GetScalarType<T[P], BetSelectionGroupByOutputType[P]>
        }
      >
    >


  export type BetSelectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketId?: boolean
    name?: boolean
    odds?: boolean
    status?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    market?: boolean | BetMarketDefaultArgs<ExtArgs>
    betSelections?: boolean | BetSelection$betSelectionsArgs<ExtArgs>
    currentOdds?: boolean | BetSelection$currentOddsArgs<ExtArgs>
    oddsSnapshots?: boolean | BetSelection$oddsSnapshotsArgs<ExtArgs>
    _count?: boolean | BetSelectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["betSelection"]>

  export type BetSelectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketId?: boolean
    name?: boolean
    odds?: boolean
    status?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    market?: boolean | BetMarketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["betSelection"]>

  export type BetSelectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketId?: boolean
    name?: boolean
    odds?: boolean
    status?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    market?: boolean | BetMarketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["betSelection"]>

  export type BetSelectionSelectScalar = {
    id?: boolean
    marketId?: boolean
    name?: boolean
    odds?: boolean
    status?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BetSelectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "marketId" | "name" | "odds" | "status" | "result" | "createdAt" | "updatedAt", ExtArgs["result"]["betSelection"]>
  export type BetSelectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market?: boolean | BetMarketDefaultArgs<ExtArgs>
    betSelections?: boolean | BetSelection$betSelectionsArgs<ExtArgs>
    currentOdds?: boolean | BetSelection$currentOddsArgs<ExtArgs>
    oddsSnapshots?: boolean | BetSelection$oddsSnapshotsArgs<ExtArgs>
    _count?: boolean | BetSelectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BetSelectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market?: boolean | BetMarketDefaultArgs<ExtArgs>
  }
  export type BetSelectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market?: boolean | BetMarketDefaultArgs<ExtArgs>
  }

  export type $BetSelectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BetSelection"
    objects: {
      market: Prisma.$BetMarketPayload<ExtArgs>
      betSelections: Prisma.$BetSelectionBetPayload<ExtArgs>[]
      currentOdds: Prisma.$CurrentOddsPayload<ExtArgs> | null
      oddsSnapshots: Prisma.$OddsSnapshotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      marketId: string
      name: string
      odds: Prisma.Decimal
      status: string
      result: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["betSelection"]>
    composites: {}
  }

  type BetSelectionGetPayload<S extends boolean | null | undefined | BetSelectionDefaultArgs> = $Result.GetResult<Prisma.$BetSelectionPayload, S>

  type BetSelectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BetSelectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BetSelectionCountAggregateInputType | true
    }

  export interface BetSelectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BetSelection'], meta: { name: 'BetSelection' } }
    /**
     * Find zero or one BetSelection that matches the filter.
     * @param {BetSelectionFindUniqueArgs} args - Arguments to find a BetSelection
     * @example
     * // Get one BetSelection
     * const betSelection = await prisma.betSelection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BetSelectionFindUniqueArgs>(args: SelectSubset<T, BetSelectionFindUniqueArgs<ExtArgs>>): Prisma__BetSelectionClient<$Result.GetResult<Prisma.$BetSelectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BetSelection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BetSelectionFindUniqueOrThrowArgs} args - Arguments to find a BetSelection
     * @example
     * // Get one BetSelection
     * const betSelection = await prisma.betSelection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BetSelectionFindUniqueOrThrowArgs>(args: SelectSubset<T, BetSelectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BetSelectionClient<$Result.GetResult<Prisma.$BetSelectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BetSelection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetSelectionFindFirstArgs} args - Arguments to find a BetSelection
     * @example
     * // Get one BetSelection
     * const betSelection = await prisma.betSelection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BetSelectionFindFirstArgs>(args?: SelectSubset<T, BetSelectionFindFirstArgs<ExtArgs>>): Prisma__BetSelectionClient<$Result.GetResult<Prisma.$BetSelectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BetSelection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetSelectionFindFirstOrThrowArgs} args - Arguments to find a BetSelection
     * @example
     * // Get one BetSelection
     * const betSelection = await prisma.betSelection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BetSelectionFindFirstOrThrowArgs>(args?: SelectSubset<T, BetSelectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BetSelectionClient<$Result.GetResult<Prisma.$BetSelectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BetSelections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetSelectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BetSelections
     * const betSelections = await prisma.betSelection.findMany()
     * 
     * // Get first 10 BetSelections
     * const betSelections = await prisma.betSelection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const betSelectionWithIdOnly = await prisma.betSelection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BetSelectionFindManyArgs>(args?: SelectSubset<T, BetSelectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetSelectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BetSelection.
     * @param {BetSelectionCreateArgs} args - Arguments to create a BetSelection.
     * @example
     * // Create one BetSelection
     * const BetSelection = await prisma.betSelection.create({
     *   data: {
     *     // ... data to create a BetSelection
     *   }
     * })
     * 
     */
    create<T extends BetSelectionCreateArgs>(args: SelectSubset<T, BetSelectionCreateArgs<ExtArgs>>): Prisma__BetSelectionClient<$Result.GetResult<Prisma.$BetSelectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BetSelections.
     * @param {BetSelectionCreateManyArgs} args - Arguments to create many BetSelections.
     * @example
     * // Create many BetSelections
     * const betSelection = await prisma.betSelection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BetSelectionCreateManyArgs>(args?: SelectSubset<T, BetSelectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BetSelections and returns the data saved in the database.
     * @param {BetSelectionCreateManyAndReturnArgs} args - Arguments to create many BetSelections.
     * @example
     * // Create many BetSelections
     * const betSelection = await prisma.betSelection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BetSelections and only return the `id`
     * const betSelectionWithIdOnly = await prisma.betSelection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BetSelectionCreateManyAndReturnArgs>(args?: SelectSubset<T, BetSelectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetSelectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BetSelection.
     * @param {BetSelectionDeleteArgs} args - Arguments to delete one BetSelection.
     * @example
     * // Delete one BetSelection
     * const BetSelection = await prisma.betSelection.delete({
     *   where: {
     *     // ... filter to delete one BetSelection
     *   }
     * })
     * 
     */
    delete<T extends BetSelectionDeleteArgs>(args: SelectSubset<T, BetSelectionDeleteArgs<ExtArgs>>): Prisma__BetSelectionClient<$Result.GetResult<Prisma.$BetSelectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BetSelection.
     * @param {BetSelectionUpdateArgs} args - Arguments to update one BetSelection.
     * @example
     * // Update one BetSelection
     * const betSelection = await prisma.betSelection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BetSelectionUpdateArgs>(args: SelectSubset<T, BetSelectionUpdateArgs<ExtArgs>>): Prisma__BetSelectionClient<$Result.GetResult<Prisma.$BetSelectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BetSelections.
     * @param {BetSelectionDeleteManyArgs} args - Arguments to filter BetSelections to delete.
     * @example
     * // Delete a few BetSelections
     * const { count } = await prisma.betSelection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BetSelectionDeleteManyArgs>(args?: SelectSubset<T, BetSelectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BetSelections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetSelectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BetSelections
     * const betSelection = await prisma.betSelection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BetSelectionUpdateManyArgs>(args: SelectSubset<T, BetSelectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BetSelections and returns the data updated in the database.
     * @param {BetSelectionUpdateManyAndReturnArgs} args - Arguments to update many BetSelections.
     * @example
     * // Update many BetSelections
     * const betSelection = await prisma.betSelection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BetSelections and only return the `id`
     * const betSelectionWithIdOnly = await prisma.betSelection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BetSelectionUpdateManyAndReturnArgs>(args: SelectSubset<T, BetSelectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetSelectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BetSelection.
     * @param {BetSelectionUpsertArgs} args - Arguments to update or create a BetSelection.
     * @example
     * // Update or create a BetSelection
     * const betSelection = await prisma.betSelection.upsert({
     *   create: {
     *     // ... data to create a BetSelection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BetSelection we want to update
     *   }
     * })
     */
    upsert<T extends BetSelectionUpsertArgs>(args: SelectSubset<T, BetSelectionUpsertArgs<ExtArgs>>): Prisma__BetSelectionClient<$Result.GetResult<Prisma.$BetSelectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BetSelections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetSelectionCountArgs} args - Arguments to filter BetSelections to count.
     * @example
     * // Count the number of BetSelections
     * const count = await prisma.betSelection.count({
     *   where: {
     *     // ... the filter for the BetSelections we want to count
     *   }
     * })
    **/
    count<T extends BetSelectionCountArgs>(
      args?: Subset<T, BetSelectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BetSelectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BetSelection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetSelectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BetSelectionAggregateArgs>(args: Subset<T, BetSelectionAggregateArgs>): Prisma.PrismaPromise<GetBetSelectionAggregateType<T>>

    /**
     * Group by BetSelection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetSelectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BetSelectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BetSelectionGroupByArgs['orderBy'] }
        : { orderBy?: BetSelectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BetSelectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBetSelectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BetSelection model
   */
  readonly fields: BetSelectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BetSelection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BetSelectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    market<T extends BetMarketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BetMarketDefaultArgs<ExtArgs>>): Prisma__BetMarketClient<$Result.GetResult<Prisma.$BetMarketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    betSelections<T extends BetSelection$betSelectionsArgs<ExtArgs> = {}>(args?: Subset<T, BetSelection$betSelectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetSelectionBetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    currentOdds<T extends BetSelection$currentOddsArgs<ExtArgs> = {}>(args?: Subset<T, BetSelection$currentOddsArgs<ExtArgs>>): Prisma__CurrentOddsClient<$Result.GetResult<Prisma.$CurrentOddsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    oddsSnapshots<T extends BetSelection$oddsSnapshotsArgs<ExtArgs> = {}>(args?: Subset<T, BetSelection$oddsSnapshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OddsSnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BetSelection model
   */
  interface BetSelectionFieldRefs {
    readonly id: FieldRef<"BetSelection", 'String'>
    readonly marketId: FieldRef<"BetSelection", 'String'>
    readonly name: FieldRef<"BetSelection", 'String'>
    readonly odds: FieldRef<"BetSelection", 'Decimal'>
    readonly status: FieldRef<"BetSelection", 'String'>
    readonly result: FieldRef<"BetSelection", 'String'>
    readonly createdAt: FieldRef<"BetSelection", 'DateTime'>
    readonly updatedAt: FieldRef<"BetSelection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BetSelection findUnique
   */
  export type BetSelectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelection
     */
    select?: BetSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelection
     */
    omit?: BetSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionInclude<ExtArgs> | null
    /**
     * Filter, which BetSelection to fetch.
     */
    where: BetSelectionWhereUniqueInput
  }

  /**
   * BetSelection findUniqueOrThrow
   */
  export type BetSelectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelection
     */
    select?: BetSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelection
     */
    omit?: BetSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionInclude<ExtArgs> | null
    /**
     * Filter, which BetSelection to fetch.
     */
    where: BetSelectionWhereUniqueInput
  }

  /**
   * BetSelection findFirst
   */
  export type BetSelectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelection
     */
    select?: BetSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelection
     */
    omit?: BetSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionInclude<ExtArgs> | null
    /**
     * Filter, which BetSelection to fetch.
     */
    where?: BetSelectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetSelections to fetch.
     */
    orderBy?: BetSelectionOrderByWithRelationInput | BetSelectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BetSelections.
     */
    cursor?: BetSelectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetSelections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetSelections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BetSelections.
     */
    distinct?: BetSelectionScalarFieldEnum | BetSelectionScalarFieldEnum[]
  }

  /**
   * BetSelection findFirstOrThrow
   */
  export type BetSelectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelection
     */
    select?: BetSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelection
     */
    omit?: BetSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionInclude<ExtArgs> | null
    /**
     * Filter, which BetSelection to fetch.
     */
    where?: BetSelectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetSelections to fetch.
     */
    orderBy?: BetSelectionOrderByWithRelationInput | BetSelectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BetSelections.
     */
    cursor?: BetSelectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetSelections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetSelections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BetSelections.
     */
    distinct?: BetSelectionScalarFieldEnum | BetSelectionScalarFieldEnum[]
  }

  /**
   * BetSelection findMany
   */
  export type BetSelectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelection
     */
    select?: BetSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelection
     */
    omit?: BetSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionInclude<ExtArgs> | null
    /**
     * Filter, which BetSelections to fetch.
     */
    where?: BetSelectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetSelections to fetch.
     */
    orderBy?: BetSelectionOrderByWithRelationInput | BetSelectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BetSelections.
     */
    cursor?: BetSelectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetSelections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetSelections.
     */
    skip?: number
    distinct?: BetSelectionScalarFieldEnum | BetSelectionScalarFieldEnum[]
  }

  /**
   * BetSelection create
   */
  export type BetSelectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelection
     */
    select?: BetSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelection
     */
    omit?: BetSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionInclude<ExtArgs> | null
    /**
     * The data needed to create a BetSelection.
     */
    data: XOR<BetSelectionCreateInput, BetSelectionUncheckedCreateInput>
  }

  /**
   * BetSelection createMany
   */
  export type BetSelectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BetSelections.
     */
    data: BetSelectionCreateManyInput | BetSelectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BetSelection createManyAndReturn
   */
  export type BetSelectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelection
     */
    select?: BetSelectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelection
     */
    omit?: BetSelectionOmit<ExtArgs> | null
    /**
     * The data used to create many BetSelections.
     */
    data: BetSelectionCreateManyInput | BetSelectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BetSelection update
   */
  export type BetSelectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelection
     */
    select?: BetSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelection
     */
    omit?: BetSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionInclude<ExtArgs> | null
    /**
     * The data needed to update a BetSelection.
     */
    data: XOR<BetSelectionUpdateInput, BetSelectionUncheckedUpdateInput>
    /**
     * Choose, which BetSelection to update.
     */
    where: BetSelectionWhereUniqueInput
  }

  /**
   * BetSelection updateMany
   */
  export type BetSelectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BetSelections.
     */
    data: XOR<BetSelectionUpdateManyMutationInput, BetSelectionUncheckedUpdateManyInput>
    /**
     * Filter which BetSelections to update
     */
    where?: BetSelectionWhereInput
    /**
     * Limit how many BetSelections to update.
     */
    limit?: number
  }

  /**
   * BetSelection updateManyAndReturn
   */
  export type BetSelectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelection
     */
    select?: BetSelectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelection
     */
    omit?: BetSelectionOmit<ExtArgs> | null
    /**
     * The data used to update BetSelections.
     */
    data: XOR<BetSelectionUpdateManyMutationInput, BetSelectionUncheckedUpdateManyInput>
    /**
     * Filter which BetSelections to update
     */
    where?: BetSelectionWhereInput
    /**
     * Limit how many BetSelections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BetSelection upsert
   */
  export type BetSelectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelection
     */
    select?: BetSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelection
     */
    omit?: BetSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionInclude<ExtArgs> | null
    /**
     * The filter to search for the BetSelection to update in case it exists.
     */
    where: BetSelectionWhereUniqueInput
    /**
     * In case the BetSelection found by the `where` argument doesn't exist, create a new BetSelection with this data.
     */
    create: XOR<BetSelectionCreateInput, BetSelectionUncheckedCreateInput>
    /**
     * In case the BetSelection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BetSelectionUpdateInput, BetSelectionUncheckedUpdateInput>
  }

  /**
   * BetSelection delete
   */
  export type BetSelectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelection
     */
    select?: BetSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelection
     */
    omit?: BetSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionInclude<ExtArgs> | null
    /**
     * Filter which BetSelection to delete.
     */
    where: BetSelectionWhereUniqueInput
  }

  /**
   * BetSelection deleteMany
   */
  export type BetSelectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BetSelections to delete
     */
    where?: BetSelectionWhereInput
    /**
     * Limit how many BetSelections to delete.
     */
    limit?: number
  }

  /**
   * BetSelection.betSelections
   */
  export type BetSelection$betSelectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelectionBet
     */
    select?: BetSelectionBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelectionBet
     */
    omit?: BetSelectionBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionBetInclude<ExtArgs> | null
    where?: BetSelectionBetWhereInput
    orderBy?: BetSelectionBetOrderByWithRelationInput | BetSelectionBetOrderByWithRelationInput[]
    cursor?: BetSelectionBetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BetSelectionBetScalarFieldEnum | BetSelectionBetScalarFieldEnum[]
  }

  /**
   * BetSelection.currentOdds
   */
  export type BetSelection$currentOddsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentOdds
     */
    select?: CurrentOddsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentOdds
     */
    omit?: CurrentOddsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentOddsInclude<ExtArgs> | null
    where?: CurrentOddsWhereInput
  }

  /**
   * BetSelection.oddsSnapshots
   */
  export type BetSelection$oddsSnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSnapshot
     */
    select?: OddsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSnapshot
     */
    omit?: OddsSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSnapshotInclude<ExtArgs> | null
    where?: OddsSnapshotWhereInput
    orderBy?: OddsSnapshotOrderByWithRelationInput | OddsSnapshotOrderByWithRelationInput[]
    cursor?: OddsSnapshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OddsSnapshotScalarFieldEnum | OddsSnapshotScalarFieldEnum[]
  }

  /**
   * BetSelection without action
   */
  export type BetSelectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelection
     */
    select?: BetSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelection
     */
    omit?: BetSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionInclude<ExtArgs> | null
  }


  /**
   * Model Bet
   */

  export type AggregateBet = {
    _count: BetCountAggregateOutputType | null
    _avg: BetAvgAggregateOutputType | null
    _sum: BetSumAggregateOutputType | null
    _min: BetMinAggregateOutputType | null
    _max: BetMaxAggregateOutputType | null
  }

  export type BetAvgAggregateOutputType = {
    totalStake: Decimal | null
    potentialPayout: Decimal | null
    actualPayout: Decimal | null
  }

  export type BetSumAggregateOutputType = {
    totalStake: Decimal | null
    potentialPayout: Decimal | null
    actualPayout: Decimal | null
  }

  export type BetMinAggregateOutputType = {
    id: string | null
    userId: string | null
    betType: string | null
    totalStake: Decimal | null
    potentialPayout: Decimal | null
    actualPayout: Decimal | null
    status: string | null
    placedAt: Date | null
    settledAt: Date | null
    cashoutAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BetMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    betType: string | null
    totalStake: Decimal | null
    potentialPayout: Decimal | null
    actualPayout: Decimal | null
    status: string | null
    placedAt: Date | null
    settledAt: Date | null
    cashoutAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BetCountAggregateOutputType = {
    id: number
    userId: number
    betType: number
    totalStake: number
    potentialPayout: number
    actualPayout: number
    status: number
    placedAt: number
    settledAt: number
    cashoutAt: number
    oddsSnapshot: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BetAvgAggregateInputType = {
    totalStake?: true
    potentialPayout?: true
    actualPayout?: true
  }

  export type BetSumAggregateInputType = {
    totalStake?: true
    potentialPayout?: true
    actualPayout?: true
  }

  export type BetMinAggregateInputType = {
    id?: true
    userId?: true
    betType?: true
    totalStake?: true
    potentialPayout?: true
    actualPayout?: true
    status?: true
    placedAt?: true
    settledAt?: true
    cashoutAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BetMaxAggregateInputType = {
    id?: true
    userId?: true
    betType?: true
    totalStake?: true
    potentialPayout?: true
    actualPayout?: true
    status?: true
    placedAt?: true
    settledAt?: true
    cashoutAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BetCountAggregateInputType = {
    id?: true
    userId?: true
    betType?: true
    totalStake?: true
    potentialPayout?: true
    actualPayout?: true
    status?: true
    placedAt?: true
    settledAt?: true
    cashoutAt?: true
    oddsSnapshot?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bet to aggregate.
     */
    where?: BetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bets to fetch.
     */
    orderBy?: BetOrderByWithRelationInput | BetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bets
    **/
    _count?: true | BetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BetMaxAggregateInputType
  }

  export type GetBetAggregateType<T extends BetAggregateArgs> = {
        [P in keyof T & keyof AggregateBet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBet[P]>
      : GetScalarType<T[P], AggregateBet[P]>
  }




  export type BetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetWhereInput
    orderBy?: BetOrderByWithAggregationInput | BetOrderByWithAggregationInput[]
    by: BetScalarFieldEnum[] | BetScalarFieldEnum
    having?: BetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BetCountAggregateInputType | true
    _avg?: BetAvgAggregateInputType
    _sum?: BetSumAggregateInputType
    _min?: BetMinAggregateInputType
    _max?: BetMaxAggregateInputType
  }

  export type BetGroupByOutputType = {
    id: string
    userId: string
    betType: string
    totalStake: Decimal
    potentialPayout: Decimal
    actualPayout: Decimal | null
    status: string
    placedAt: Date
    settledAt: Date | null
    cashoutAt: Date | null
    oddsSnapshot: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: BetCountAggregateOutputType | null
    _avg: BetAvgAggregateOutputType | null
    _sum: BetSumAggregateOutputType | null
    _min: BetMinAggregateOutputType | null
    _max: BetMaxAggregateOutputType | null
  }

  type GetBetGroupByPayload<T extends BetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BetGroupByOutputType[P]>
            : GetScalarType<T[P], BetGroupByOutputType[P]>
        }
      >
    >


  export type BetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    betType?: boolean
    totalStake?: boolean
    potentialPayout?: boolean
    actualPayout?: boolean
    status?: boolean
    placedAt?: boolean
    settledAt?: boolean
    cashoutAt?: boolean
    oddsSnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    selections?: boolean | Bet$selectionsArgs<ExtArgs>
    _count?: boolean | BetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bet"]>

  export type BetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    betType?: boolean
    totalStake?: boolean
    potentialPayout?: boolean
    actualPayout?: boolean
    status?: boolean
    placedAt?: boolean
    settledAt?: boolean
    cashoutAt?: boolean
    oddsSnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bet"]>

  export type BetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    betType?: boolean
    totalStake?: boolean
    potentialPayout?: boolean
    actualPayout?: boolean
    status?: boolean
    placedAt?: boolean
    settledAt?: boolean
    cashoutAt?: boolean
    oddsSnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bet"]>

  export type BetSelectScalar = {
    id?: boolean
    userId?: boolean
    betType?: boolean
    totalStake?: boolean
    potentialPayout?: boolean
    actualPayout?: boolean
    status?: boolean
    placedAt?: boolean
    settledAt?: boolean
    cashoutAt?: boolean
    oddsSnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "betType" | "totalStake" | "potentialPayout" | "actualPayout" | "status" | "placedAt" | "settledAt" | "cashoutAt" | "oddsSnapshot" | "createdAt" | "updatedAt", ExtArgs["result"]["bet"]>
  export type BetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    selections?: boolean | Bet$selectionsArgs<ExtArgs>
    _count?: boolean | BetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bet"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      selections: Prisma.$BetSelectionBetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      betType: string
      totalStake: Prisma.Decimal
      potentialPayout: Prisma.Decimal
      actualPayout: Prisma.Decimal | null
      status: string
      placedAt: Date
      settledAt: Date | null
      cashoutAt: Date | null
      oddsSnapshot: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bet"]>
    composites: {}
  }

  type BetGetPayload<S extends boolean | null | undefined | BetDefaultArgs> = $Result.GetResult<Prisma.$BetPayload, S>

  type BetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BetCountAggregateInputType | true
    }

  export interface BetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bet'], meta: { name: 'Bet' } }
    /**
     * Find zero or one Bet that matches the filter.
     * @param {BetFindUniqueArgs} args - Arguments to find a Bet
     * @example
     * // Get one Bet
     * const bet = await prisma.bet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BetFindUniqueArgs>(args: SelectSubset<T, BetFindUniqueArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BetFindUniqueOrThrowArgs} args - Arguments to find a Bet
     * @example
     * // Get one Bet
     * const bet = await prisma.bet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BetFindUniqueOrThrowArgs>(args: SelectSubset<T, BetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetFindFirstArgs} args - Arguments to find a Bet
     * @example
     * // Get one Bet
     * const bet = await prisma.bet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BetFindFirstArgs>(args?: SelectSubset<T, BetFindFirstArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetFindFirstOrThrowArgs} args - Arguments to find a Bet
     * @example
     * // Get one Bet
     * const bet = await prisma.bet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BetFindFirstOrThrowArgs>(args?: SelectSubset<T, BetFindFirstOrThrowArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bets
     * const bets = await prisma.bet.findMany()
     * 
     * // Get first 10 Bets
     * const bets = await prisma.bet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const betWithIdOnly = await prisma.bet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BetFindManyArgs>(args?: SelectSubset<T, BetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bet.
     * @param {BetCreateArgs} args - Arguments to create a Bet.
     * @example
     * // Create one Bet
     * const Bet = await prisma.bet.create({
     *   data: {
     *     // ... data to create a Bet
     *   }
     * })
     * 
     */
    create<T extends BetCreateArgs>(args: SelectSubset<T, BetCreateArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bets.
     * @param {BetCreateManyArgs} args - Arguments to create many Bets.
     * @example
     * // Create many Bets
     * const bet = await prisma.bet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BetCreateManyArgs>(args?: SelectSubset<T, BetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bets and returns the data saved in the database.
     * @param {BetCreateManyAndReturnArgs} args - Arguments to create many Bets.
     * @example
     * // Create many Bets
     * const bet = await prisma.bet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bets and only return the `id`
     * const betWithIdOnly = await prisma.bet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BetCreateManyAndReturnArgs>(args?: SelectSubset<T, BetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bet.
     * @param {BetDeleteArgs} args - Arguments to delete one Bet.
     * @example
     * // Delete one Bet
     * const Bet = await prisma.bet.delete({
     *   where: {
     *     // ... filter to delete one Bet
     *   }
     * })
     * 
     */
    delete<T extends BetDeleteArgs>(args: SelectSubset<T, BetDeleteArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bet.
     * @param {BetUpdateArgs} args - Arguments to update one Bet.
     * @example
     * // Update one Bet
     * const bet = await prisma.bet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BetUpdateArgs>(args: SelectSubset<T, BetUpdateArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bets.
     * @param {BetDeleteManyArgs} args - Arguments to filter Bets to delete.
     * @example
     * // Delete a few Bets
     * const { count } = await prisma.bet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BetDeleteManyArgs>(args?: SelectSubset<T, BetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bets
     * const bet = await prisma.bet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BetUpdateManyArgs>(args: SelectSubset<T, BetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bets and returns the data updated in the database.
     * @param {BetUpdateManyAndReturnArgs} args - Arguments to update many Bets.
     * @example
     * // Update many Bets
     * const bet = await prisma.bet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bets and only return the `id`
     * const betWithIdOnly = await prisma.bet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BetUpdateManyAndReturnArgs>(args: SelectSubset<T, BetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bet.
     * @param {BetUpsertArgs} args - Arguments to update or create a Bet.
     * @example
     * // Update or create a Bet
     * const bet = await prisma.bet.upsert({
     *   create: {
     *     // ... data to create a Bet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bet we want to update
     *   }
     * })
     */
    upsert<T extends BetUpsertArgs>(args: SelectSubset<T, BetUpsertArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetCountArgs} args - Arguments to filter Bets to count.
     * @example
     * // Count the number of Bets
     * const count = await prisma.bet.count({
     *   where: {
     *     // ... the filter for the Bets we want to count
     *   }
     * })
    **/
    count<T extends BetCountArgs>(
      args?: Subset<T, BetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BetAggregateArgs>(args: Subset<T, BetAggregateArgs>): Prisma.PrismaPromise<GetBetAggregateType<T>>

    /**
     * Group by Bet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BetGroupByArgs['orderBy'] }
        : { orderBy?: BetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bet model
   */
  readonly fields: BetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    selections<T extends Bet$selectionsArgs<ExtArgs> = {}>(args?: Subset<T, Bet$selectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetSelectionBetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bet model
   */
  interface BetFieldRefs {
    readonly id: FieldRef<"Bet", 'String'>
    readonly userId: FieldRef<"Bet", 'String'>
    readonly betType: FieldRef<"Bet", 'String'>
    readonly totalStake: FieldRef<"Bet", 'Decimal'>
    readonly potentialPayout: FieldRef<"Bet", 'Decimal'>
    readonly actualPayout: FieldRef<"Bet", 'Decimal'>
    readonly status: FieldRef<"Bet", 'String'>
    readonly placedAt: FieldRef<"Bet", 'DateTime'>
    readonly settledAt: FieldRef<"Bet", 'DateTime'>
    readonly cashoutAt: FieldRef<"Bet", 'DateTime'>
    readonly oddsSnapshot: FieldRef<"Bet", 'Json'>
    readonly createdAt: FieldRef<"Bet", 'DateTime'>
    readonly updatedAt: FieldRef<"Bet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bet findUnique
   */
  export type BetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bet
     */
    omit?: BetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * Filter, which Bet to fetch.
     */
    where: BetWhereUniqueInput
  }

  /**
   * Bet findUniqueOrThrow
   */
  export type BetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bet
     */
    omit?: BetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * Filter, which Bet to fetch.
     */
    where: BetWhereUniqueInput
  }

  /**
   * Bet findFirst
   */
  export type BetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bet
     */
    omit?: BetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * Filter, which Bet to fetch.
     */
    where?: BetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bets to fetch.
     */
    orderBy?: BetOrderByWithRelationInput | BetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bets.
     */
    cursor?: BetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bets.
     */
    distinct?: BetScalarFieldEnum | BetScalarFieldEnum[]
  }

  /**
   * Bet findFirstOrThrow
   */
  export type BetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bet
     */
    omit?: BetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * Filter, which Bet to fetch.
     */
    where?: BetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bets to fetch.
     */
    orderBy?: BetOrderByWithRelationInput | BetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bets.
     */
    cursor?: BetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bets.
     */
    distinct?: BetScalarFieldEnum | BetScalarFieldEnum[]
  }

  /**
   * Bet findMany
   */
  export type BetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bet
     */
    omit?: BetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * Filter, which Bets to fetch.
     */
    where?: BetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bets to fetch.
     */
    orderBy?: BetOrderByWithRelationInput | BetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bets.
     */
    cursor?: BetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bets.
     */
    skip?: number
    distinct?: BetScalarFieldEnum | BetScalarFieldEnum[]
  }

  /**
   * Bet create
   */
  export type BetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bet
     */
    omit?: BetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * The data needed to create a Bet.
     */
    data: XOR<BetCreateInput, BetUncheckedCreateInput>
  }

  /**
   * Bet createMany
   */
  export type BetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bets.
     */
    data: BetCreateManyInput | BetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bet createManyAndReturn
   */
  export type BetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bet
     */
    omit?: BetOmit<ExtArgs> | null
    /**
     * The data used to create many Bets.
     */
    data: BetCreateManyInput | BetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bet update
   */
  export type BetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bet
     */
    omit?: BetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * The data needed to update a Bet.
     */
    data: XOR<BetUpdateInput, BetUncheckedUpdateInput>
    /**
     * Choose, which Bet to update.
     */
    where: BetWhereUniqueInput
  }

  /**
   * Bet updateMany
   */
  export type BetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bets.
     */
    data: XOR<BetUpdateManyMutationInput, BetUncheckedUpdateManyInput>
    /**
     * Filter which Bets to update
     */
    where?: BetWhereInput
    /**
     * Limit how many Bets to update.
     */
    limit?: number
  }

  /**
   * Bet updateManyAndReturn
   */
  export type BetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bet
     */
    omit?: BetOmit<ExtArgs> | null
    /**
     * The data used to update Bets.
     */
    data: XOR<BetUpdateManyMutationInput, BetUncheckedUpdateManyInput>
    /**
     * Filter which Bets to update
     */
    where?: BetWhereInput
    /**
     * Limit how many Bets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bet upsert
   */
  export type BetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bet
     */
    omit?: BetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * The filter to search for the Bet to update in case it exists.
     */
    where: BetWhereUniqueInput
    /**
     * In case the Bet found by the `where` argument doesn't exist, create a new Bet with this data.
     */
    create: XOR<BetCreateInput, BetUncheckedCreateInput>
    /**
     * In case the Bet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BetUpdateInput, BetUncheckedUpdateInput>
  }

  /**
   * Bet delete
   */
  export type BetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bet
     */
    omit?: BetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * Filter which Bet to delete.
     */
    where: BetWhereUniqueInput
  }

  /**
   * Bet deleteMany
   */
  export type BetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bets to delete
     */
    where?: BetWhereInput
    /**
     * Limit how many Bets to delete.
     */
    limit?: number
  }

  /**
   * Bet.selections
   */
  export type Bet$selectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelectionBet
     */
    select?: BetSelectionBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelectionBet
     */
    omit?: BetSelectionBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionBetInclude<ExtArgs> | null
    where?: BetSelectionBetWhereInput
    orderBy?: BetSelectionBetOrderByWithRelationInput | BetSelectionBetOrderByWithRelationInput[]
    cursor?: BetSelectionBetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BetSelectionBetScalarFieldEnum | BetSelectionBetScalarFieldEnum[]
  }

  /**
   * Bet without action
   */
  export type BetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bet
     */
    omit?: BetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
  }


  /**
   * Model BetSelectionBet
   */

  export type AggregateBetSelectionBet = {
    _count: BetSelectionBetCountAggregateOutputType | null
    _avg: BetSelectionBetAvgAggregateOutputType | null
    _sum: BetSelectionBetSumAggregateOutputType | null
    _min: BetSelectionBetMinAggregateOutputType | null
    _max: BetSelectionBetMaxAggregateOutputType | null
  }

  export type BetSelectionBetAvgAggregateOutputType = {
    oddsAtBet: Decimal | null
  }

  export type BetSelectionBetSumAggregateOutputType = {
    oddsAtBet: Decimal | null
  }

  export type BetSelectionBetMinAggregateOutputType = {
    id: string | null
    betId: string | null
    selectionId: string | null
    oddsAtBet: Decimal | null
    result: string | null
    createdAt: Date | null
  }

  export type BetSelectionBetMaxAggregateOutputType = {
    id: string | null
    betId: string | null
    selectionId: string | null
    oddsAtBet: Decimal | null
    result: string | null
    createdAt: Date | null
  }

  export type BetSelectionBetCountAggregateOutputType = {
    id: number
    betId: number
    selectionId: number
    oddsAtBet: number
    result: number
    createdAt: number
    _all: number
  }


  export type BetSelectionBetAvgAggregateInputType = {
    oddsAtBet?: true
  }

  export type BetSelectionBetSumAggregateInputType = {
    oddsAtBet?: true
  }

  export type BetSelectionBetMinAggregateInputType = {
    id?: true
    betId?: true
    selectionId?: true
    oddsAtBet?: true
    result?: true
    createdAt?: true
  }

  export type BetSelectionBetMaxAggregateInputType = {
    id?: true
    betId?: true
    selectionId?: true
    oddsAtBet?: true
    result?: true
    createdAt?: true
  }

  export type BetSelectionBetCountAggregateInputType = {
    id?: true
    betId?: true
    selectionId?: true
    oddsAtBet?: true
    result?: true
    createdAt?: true
    _all?: true
  }

  export type BetSelectionBetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BetSelectionBet to aggregate.
     */
    where?: BetSelectionBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetSelectionBets to fetch.
     */
    orderBy?: BetSelectionBetOrderByWithRelationInput | BetSelectionBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BetSelectionBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetSelectionBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetSelectionBets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BetSelectionBets
    **/
    _count?: true | BetSelectionBetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BetSelectionBetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BetSelectionBetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BetSelectionBetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BetSelectionBetMaxAggregateInputType
  }

  export type GetBetSelectionBetAggregateType<T extends BetSelectionBetAggregateArgs> = {
        [P in keyof T & keyof AggregateBetSelectionBet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBetSelectionBet[P]>
      : GetScalarType<T[P], AggregateBetSelectionBet[P]>
  }




  export type BetSelectionBetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetSelectionBetWhereInput
    orderBy?: BetSelectionBetOrderByWithAggregationInput | BetSelectionBetOrderByWithAggregationInput[]
    by: BetSelectionBetScalarFieldEnum[] | BetSelectionBetScalarFieldEnum
    having?: BetSelectionBetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BetSelectionBetCountAggregateInputType | true
    _avg?: BetSelectionBetAvgAggregateInputType
    _sum?: BetSelectionBetSumAggregateInputType
    _min?: BetSelectionBetMinAggregateInputType
    _max?: BetSelectionBetMaxAggregateInputType
  }

  export type BetSelectionBetGroupByOutputType = {
    id: string
    betId: string
    selectionId: string
    oddsAtBet: Decimal
    result: string | null
    createdAt: Date
    _count: BetSelectionBetCountAggregateOutputType | null
    _avg: BetSelectionBetAvgAggregateOutputType | null
    _sum: BetSelectionBetSumAggregateOutputType | null
    _min: BetSelectionBetMinAggregateOutputType | null
    _max: BetSelectionBetMaxAggregateOutputType | null
  }

  type GetBetSelectionBetGroupByPayload<T extends BetSelectionBetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BetSelectionBetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BetSelectionBetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BetSelectionBetGroupByOutputType[P]>
            : GetScalarType<T[P], BetSelectionBetGroupByOutputType[P]>
        }
      >
    >


  export type BetSelectionBetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    betId?: boolean
    selectionId?: boolean
    oddsAtBet?: boolean
    result?: boolean
    createdAt?: boolean
    bet?: boolean | BetDefaultArgs<ExtArgs>
    selection?: boolean | BetSelectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["betSelectionBet"]>

  export type BetSelectionBetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    betId?: boolean
    selectionId?: boolean
    oddsAtBet?: boolean
    result?: boolean
    createdAt?: boolean
    bet?: boolean | BetDefaultArgs<ExtArgs>
    selection?: boolean | BetSelectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["betSelectionBet"]>

  export type BetSelectionBetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    betId?: boolean
    selectionId?: boolean
    oddsAtBet?: boolean
    result?: boolean
    createdAt?: boolean
    bet?: boolean | BetDefaultArgs<ExtArgs>
    selection?: boolean | BetSelectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["betSelectionBet"]>

  export type BetSelectionBetSelectScalar = {
    id?: boolean
    betId?: boolean
    selectionId?: boolean
    oddsAtBet?: boolean
    result?: boolean
    createdAt?: boolean
  }

  export type BetSelectionBetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "betId" | "selectionId" | "oddsAtBet" | "result" | "createdAt", ExtArgs["result"]["betSelectionBet"]>
  export type BetSelectionBetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bet?: boolean | BetDefaultArgs<ExtArgs>
    selection?: boolean | BetSelectionDefaultArgs<ExtArgs>
  }
  export type BetSelectionBetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bet?: boolean | BetDefaultArgs<ExtArgs>
    selection?: boolean | BetSelectionDefaultArgs<ExtArgs>
  }
  export type BetSelectionBetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bet?: boolean | BetDefaultArgs<ExtArgs>
    selection?: boolean | BetSelectionDefaultArgs<ExtArgs>
  }

  export type $BetSelectionBetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BetSelectionBet"
    objects: {
      bet: Prisma.$BetPayload<ExtArgs>
      selection: Prisma.$BetSelectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      betId: string
      selectionId: string
      oddsAtBet: Prisma.Decimal
      result: string | null
      createdAt: Date
    }, ExtArgs["result"]["betSelectionBet"]>
    composites: {}
  }

  type BetSelectionBetGetPayload<S extends boolean | null | undefined | BetSelectionBetDefaultArgs> = $Result.GetResult<Prisma.$BetSelectionBetPayload, S>

  type BetSelectionBetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BetSelectionBetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BetSelectionBetCountAggregateInputType | true
    }

  export interface BetSelectionBetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BetSelectionBet'], meta: { name: 'BetSelectionBet' } }
    /**
     * Find zero or one BetSelectionBet that matches the filter.
     * @param {BetSelectionBetFindUniqueArgs} args - Arguments to find a BetSelectionBet
     * @example
     * // Get one BetSelectionBet
     * const betSelectionBet = await prisma.betSelectionBet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BetSelectionBetFindUniqueArgs>(args: SelectSubset<T, BetSelectionBetFindUniqueArgs<ExtArgs>>): Prisma__BetSelectionBetClient<$Result.GetResult<Prisma.$BetSelectionBetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BetSelectionBet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BetSelectionBetFindUniqueOrThrowArgs} args - Arguments to find a BetSelectionBet
     * @example
     * // Get one BetSelectionBet
     * const betSelectionBet = await prisma.betSelectionBet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BetSelectionBetFindUniqueOrThrowArgs>(args: SelectSubset<T, BetSelectionBetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BetSelectionBetClient<$Result.GetResult<Prisma.$BetSelectionBetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BetSelectionBet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetSelectionBetFindFirstArgs} args - Arguments to find a BetSelectionBet
     * @example
     * // Get one BetSelectionBet
     * const betSelectionBet = await prisma.betSelectionBet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BetSelectionBetFindFirstArgs>(args?: SelectSubset<T, BetSelectionBetFindFirstArgs<ExtArgs>>): Prisma__BetSelectionBetClient<$Result.GetResult<Prisma.$BetSelectionBetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BetSelectionBet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetSelectionBetFindFirstOrThrowArgs} args - Arguments to find a BetSelectionBet
     * @example
     * // Get one BetSelectionBet
     * const betSelectionBet = await prisma.betSelectionBet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BetSelectionBetFindFirstOrThrowArgs>(args?: SelectSubset<T, BetSelectionBetFindFirstOrThrowArgs<ExtArgs>>): Prisma__BetSelectionBetClient<$Result.GetResult<Prisma.$BetSelectionBetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BetSelectionBets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetSelectionBetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BetSelectionBets
     * const betSelectionBets = await prisma.betSelectionBet.findMany()
     * 
     * // Get first 10 BetSelectionBets
     * const betSelectionBets = await prisma.betSelectionBet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const betSelectionBetWithIdOnly = await prisma.betSelectionBet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BetSelectionBetFindManyArgs>(args?: SelectSubset<T, BetSelectionBetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetSelectionBetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BetSelectionBet.
     * @param {BetSelectionBetCreateArgs} args - Arguments to create a BetSelectionBet.
     * @example
     * // Create one BetSelectionBet
     * const BetSelectionBet = await prisma.betSelectionBet.create({
     *   data: {
     *     // ... data to create a BetSelectionBet
     *   }
     * })
     * 
     */
    create<T extends BetSelectionBetCreateArgs>(args: SelectSubset<T, BetSelectionBetCreateArgs<ExtArgs>>): Prisma__BetSelectionBetClient<$Result.GetResult<Prisma.$BetSelectionBetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BetSelectionBets.
     * @param {BetSelectionBetCreateManyArgs} args - Arguments to create many BetSelectionBets.
     * @example
     * // Create many BetSelectionBets
     * const betSelectionBet = await prisma.betSelectionBet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BetSelectionBetCreateManyArgs>(args?: SelectSubset<T, BetSelectionBetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BetSelectionBets and returns the data saved in the database.
     * @param {BetSelectionBetCreateManyAndReturnArgs} args - Arguments to create many BetSelectionBets.
     * @example
     * // Create many BetSelectionBets
     * const betSelectionBet = await prisma.betSelectionBet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BetSelectionBets and only return the `id`
     * const betSelectionBetWithIdOnly = await prisma.betSelectionBet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BetSelectionBetCreateManyAndReturnArgs>(args?: SelectSubset<T, BetSelectionBetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetSelectionBetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BetSelectionBet.
     * @param {BetSelectionBetDeleteArgs} args - Arguments to delete one BetSelectionBet.
     * @example
     * // Delete one BetSelectionBet
     * const BetSelectionBet = await prisma.betSelectionBet.delete({
     *   where: {
     *     // ... filter to delete one BetSelectionBet
     *   }
     * })
     * 
     */
    delete<T extends BetSelectionBetDeleteArgs>(args: SelectSubset<T, BetSelectionBetDeleteArgs<ExtArgs>>): Prisma__BetSelectionBetClient<$Result.GetResult<Prisma.$BetSelectionBetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BetSelectionBet.
     * @param {BetSelectionBetUpdateArgs} args - Arguments to update one BetSelectionBet.
     * @example
     * // Update one BetSelectionBet
     * const betSelectionBet = await prisma.betSelectionBet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BetSelectionBetUpdateArgs>(args: SelectSubset<T, BetSelectionBetUpdateArgs<ExtArgs>>): Prisma__BetSelectionBetClient<$Result.GetResult<Prisma.$BetSelectionBetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BetSelectionBets.
     * @param {BetSelectionBetDeleteManyArgs} args - Arguments to filter BetSelectionBets to delete.
     * @example
     * // Delete a few BetSelectionBets
     * const { count } = await prisma.betSelectionBet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BetSelectionBetDeleteManyArgs>(args?: SelectSubset<T, BetSelectionBetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BetSelectionBets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetSelectionBetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BetSelectionBets
     * const betSelectionBet = await prisma.betSelectionBet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BetSelectionBetUpdateManyArgs>(args: SelectSubset<T, BetSelectionBetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BetSelectionBets and returns the data updated in the database.
     * @param {BetSelectionBetUpdateManyAndReturnArgs} args - Arguments to update many BetSelectionBets.
     * @example
     * // Update many BetSelectionBets
     * const betSelectionBet = await prisma.betSelectionBet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BetSelectionBets and only return the `id`
     * const betSelectionBetWithIdOnly = await prisma.betSelectionBet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BetSelectionBetUpdateManyAndReturnArgs>(args: SelectSubset<T, BetSelectionBetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetSelectionBetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BetSelectionBet.
     * @param {BetSelectionBetUpsertArgs} args - Arguments to update or create a BetSelectionBet.
     * @example
     * // Update or create a BetSelectionBet
     * const betSelectionBet = await prisma.betSelectionBet.upsert({
     *   create: {
     *     // ... data to create a BetSelectionBet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BetSelectionBet we want to update
     *   }
     * })
     */
    upsert<T extends BetSelectionBetUpsertArgs>(args: SelectSubset<T, BetSelectionBetUpsertArgs<ExtArgs>>): Prisma__BetSelectionBetClient<$Result.GetResult<Prisma.$BetSelectionBetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BetSelectionBets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetSelectionBetCountArgs} args - Arguments to filter BetSelectionBets to count.
     * @example
     * // Count the number of BetSelectionBets
     * const count = await prisma.betSelectionBet.count({
     *   where: {
     *     // ... the filter for the BetSelectionBets we want to count
     *   }
     * })
    **/
    count<T extends BetSelectionBetCountArgs>(
      args?: Subset<T, BetSelectionBetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BetSelectionBetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BetSelectionBet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetSelectionBetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BetSelectionBetAggregateArgs>(args: Subset<T, BetSelectionBetAggregateArgs>): Prisma.PrismaPromise<GetBetSelectionBetAggregateType<T>>

    /**
     * Group by BetSelectionBet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetSelectionBetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BetSelectionBetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BetSelectionBetGroupByArgs['orderBy'] }
        : { orderBy?: BetSelectionBetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BetSelectionBetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBetSelectionBetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BetSelectionBet model
   */
  readonly fields: BetSelectionBetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BetSelectionBet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BetSelectionBetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bet<T extends BetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BetDefaultArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    selection<T extends BetSelectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BetSelectionDefaultArgs<ExtArgs>>): Prisma__BetSelectionClient<$Result.GetResult<Prisma.$BetSelectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BetSelectionBet model
   */
  interface BetSelectionBetFieldRefs {
    readonly id: FieldRef<"BetSelectionBet", 'String'>
    readonly betId: FieldRef<"BetSelectionBet", 'String'>
    readonly selectionId: FieldRef<"BetSelectionBet", 'String'>
    readonly oddsAtBet: FieldRef<"BetSelectionBet", 'Decimal'>
    readonly result: FieldRef<"BetSelectionBet", 'String'>
    readonly createdAt: FieldRef<"BetSelectionBet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BetSelectionBet findUnique
   */
  export type BetSelectionBetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelectionBet
     */
    select?: BetSelectionBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelectionBet
     */
    omit?: BetSelectionBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionBetInclude<ExtArgs> | null
    /**
     * Filter, which BetSelectionBet to fetch.
     */
    where: BetSelectionBetWhereUniqueInput
  }

  /**
   * BetSelectionBet findUniqueOrThrow
   */
  export type BetSelectionBetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelectionBet
     */
    select?: BetSelectionBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelectionBet
     */
    omit?: BetSelectionBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionBetInclude<ExtArgs> | null
    /**
     * Filter, which BetSelectionBet to fetch.
     */
    where: BetSelectionBetWhereUniqueInput
  }

  /**
   * BetSelectionBet findFirst
   */
  export type BetSelectionBetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelectionBet
     */
    select?: BetSelectionBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelectionBet
     */
    omit?: BetSelectionBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionBetInclude<ExtArgs> | null
    /**
     * Filter, which BetSelectionBet to fetch.
     */
    where?: BetSelectionBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetSelectionBets to fetch.
     */
    orderBy?: BetSelectionBetOrderByWithRelationInput | BetSelectionBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BetSelectionBets.
     */
    cursor?: BetSelectionBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetSelectionBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetSelectionBets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BetSelectionBets.
     */
    distinct?: BetSelectionBetScalarFieldEnum | BetSelectionBetScalarFieldEnum[]
  }

  /**
   * BetSelectionBet findFirstOrThrow
   */
  export type BetSelectionBetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelectionBet
     */
    select?: BetSelectionBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelectionBet
     */
    omit?: BetSelectionBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionBetInclude<ExtArgs> | null
    /**
     * Filter, which BetSelectionBet to fetch.
     */
    where?: BetSelectionBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetSelectionBets to fetch.
     */
    orderBy?: BetSelectionBetOrderByWithRelationInput | BetSelectionBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BetSelectionBets.
     */
    cursor?: BetSelectionBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetSelectionBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetSelectionBets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BetSelectionBets.
     */
    distinct?: BetSelectionBetScalarFieldEnum | BetSelectionBetScalarFieldEnum[]
  }

  /**
   * BetSelectionBet findMany
   */
  export type BetSelectionBetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelectionBet
     */
    select?: BetSelectionBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelectionBet
     */
    omit?: BetSelectionBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionBetInclude<ExtArgs> | null
    /**
     * Filter, which BetSelectionBets to fetch.
     */
    where?: BetSelectionBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetSelectionBets to fetch.
     */
    orderBy?: BetSelectionBetOrderByWithRelationInput | BetSelectionBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BetSelectionBets.
     */
    cursor?: BetSelectionBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetSelectionBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetSelectionBets.
     */
    skip?: number
    distinct?: BetSelectionBetScalarFieldEnum | BetSelectionBetScalarFieldEnum[]
  }

  /**
   * BetSelectionBet create
   */
  export type BetSelectionBetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelectionBet
     */
    select?: BetSelectionBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelectionBet
     */
    omit?: BetSelectionBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionBetInclude<ExtArgs> | null
    /**
     * The data needed to create a BetSelectionBet.
     */
    data: XOR<BetSelectionBetCreateInput, BetSelectionBetUncheckedCreateInput>
  }

  /**
   * BetSelectionBet createMany
   */
  export type BetSelectionBetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BetSelectionBets.
     */
    data: BetSelectionBetCreateManyInput | BetSelectionBetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BetSelectionBet createManyAndReturn
   */
  export type BetSelectionBetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelectionBet
     */
    select?: BetSelectionBetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelectionBet
     */
    omit?: BetSelectionBetOmit<ExtArgs> | null
    /**
     * The data used to create many BetSelectionBets.
     */
    data: BetSelectionBetCreateManyInput | BetSelectionBetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionBetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BetSelectionBet update
   */
  export type BetSelectionBetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelectionBet
     */
    select?: BetSelectionBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelectionBet
     */
    omit?: BetSelectionBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionBetInclude<ExtArgs> | null
    /**
     * The data needed to update a BetSelectionBet.
     */
    data: XOR<BetSelectionBetUpdateInput, BetSelectionBetUncheckedUpdateInput>
    /**
     * Choose, which BetSelectionBet to update.
     */
    where: BetSelectionBetWhereUniqueInput
  }

  /**
   * BetSelectionBet updateMany
   */
  export type BetSelectionBetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BetSelectionBets.
     */
    data: XOR<BetSelectionBetUpdateManyMutationInput, BetSelectionBetUncheckedUpdateManyInput>
    /**
     * Filter which BetSelectionBets to update
     */
    where?: BetSelectionBetWhereInput
    /**
     * Limit how many BetSelectionBets to update.
     */
    limit?: number
  }

  /**
   * BetSelectionBet updateManyAndReturn
   */
  export type BetSelectionBetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelectionBet
     */
    select?: BetSelectionBetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelectionBet
     */
    omit?: BetSelectionBetOmit<ExtArgs> | null
    /**
     * The data used to update BetSelectionBets.
     */
    data: XOR<BetSelectionBetUpdateManyMutationInput, BetSelectionBetUncheckedUpdateManyInput>
    /**
     * Filter which BetSelectionBets to update
     */
    where?: BetSelectionBetWhereInput
    /**
     * Limit how many BetSelectionBets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionBetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BetSelectionBet upsert
   */
  export type BetSelectionBetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelectionBet
     */
    select?: BetSelectionBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelectionBet
     */
    omit?: BetSelectionBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionBetInclude<ExtArgs> | null
    /**
     * The filter to search for the BetSelectionBet to update in case it exists.
     */
    where: BetSelectionBetWhereUniqueInput
    /**
     * In case the BetSelectionBet found by the `where` argument doesn't exist, create a new BetSelectionBet with this data.
     */
    create: XOR<BetSelectionBetCreateInput, BetSelectionBetUncheckedCreateInput>
    /**
     * In case the BetSelectionBet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BetSelectionBetUpdateInput, BetSelectionBetUncheckedUpdateInput>
  }

  /**
   * BetSelectionBet delete
   */
  export type BetSelectionBetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelectionBet
     */
    select?: BetSelectionBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelectionBet
     */
    omit?: BetSelectionBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionBetInclude<ExtArgs> | null
    /**
     * Filter which BetSelectionBet to delete.
     */
    where: BetSelectionBetWhereUniqueInput
  }

  /**
   * BetSelectionBet deleteMany
   */
  export type BetSelectionBetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BetSelectionBets to delete
     */
    where?: BetSelectionBetWhereInput
    /**
     * Limit how many BetSelectionBets to delete.
     */
    limit?: number
  }

  /**
   * BetSelectionBet without action
   */
  export type BetSelectionBetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetSelectionBet
     */
    select?: BetSelectionBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetSelectionBet
     */
    omit?: BetSelectionBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetSelectionBetInclude<ExtArgs> | null
  }


  /**
   * Model FinancialAccount
   */

  export type AggregateFinancialAccount = {
    _count: FinancialAccountCountAggregateOutputType | null
    _avg: FinancialAccountAvgAggregateOutputType | null
    _sum: FinancialAccountSumAggregateOutputType | null
    _min: FinancialAccountMinAggregateOutputType | null
    _max: FinancialAccountMaxAggregateOutputType | null
  }

  export type FinancialAccountAvgAggregateOutputType = {
    balance: Decimal | null
    availableBalance: Decimal | null
    lockedBalance: Decimal | null
  }

  export type FinancialAccountSumAggregateOutputType = {
    balance: Decimal | null
    availableBalance: Decimal | null
    lockedBalance: Decimal | null
  }

  export type FinancialAccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accountType: string | null
    balance: Decimal | null
    availableBalance: Decimal | null
    lockedBalance: Decimal | null
    currency: string | null
    lastTransactionAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FinancialAccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accountType: string | null
    balance: Decimal | null
    availableBalance: Decimal | null
    lockedBalance: Decimal | null
    currency: string | null
    lastTransactionAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FinancialAccountCountAggregateOutputType = {
    id: number
    userId: number
    accountType: number
    balance: number
    availableBalance: number
    lockedBalance: number
    currency: number
    lastTransactionAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FinancialAccountAvgAggregateInputType = {
    balance?: true
    availableBalance?: true
    lockedBalance?: true
  }

  export type FinancialAccountSumAggregateInputType = {
    balance?: true
    availableBalance?: true
    lockedBalance?: true
  }

  export type FinancialAccountMinAggregateInputType = {
    id?: true
    userId?: true
    accountType?: true
    balance?: true
    availableBalance?: true
    lockedBalance?: true
    currency?: true
    lastTransactionAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FinancialAccountMaxAggregateInputType = {
    id?: true
    userId?: true
    accountType?: true
    balance?: true
    availableBalance?: true
    lockedBalance?: true
    currency?: true
    lastTransactionAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FinancialAccountCountAggregateInputType = {
    id?: true
    userId?: true
    accountType?: true
    balance?: true
    availableBalance?: true
    lockedBalance?: true
    currency?: true
    lastTransactionAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FinancialAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialAccount to aggregate.
     */
    where?: FinancialAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialAccounts to fetch.
     */
    orderBy?: FinancialAccountOrderByWithRelationInput | FinancialAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinancialAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinancialAccounts
    **/
    _count?: true | FinancialAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinancialAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinancialAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancialAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancialAccountMaxAggregateInputType
  }

  export type GetFinancialAccountAggregateType<T extends FinancialAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancialAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancialAccount[P]>
      : GetScalarType<T[P], AggregateFinancialAccount[P]>
  }




  export type FinancialAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialAccountWhereInput
    orderBy?: FinancialAccountOrderByWithAggregationInput | FinancialAccountOrderByWithAggregationInput[]
    by: FinancialAccountScalarFieldEnum[] | FinancialAccountScalarFieldEnum
    having?: FinancialAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancialAccountCountAggregateInputType | true
    _avg?: FinancialAccountAvgAggregateInputType
    _sum?: FinancialAccountSumAggregateInputType
    _min?: FinancialAccountMinAggregateInputType
    _max?: FinancialAccountMaxAggregateInputType
  }

  export type FinancialAccountGroupByOutputType = {
    id: string
    userId: string
    accountType: string
    balance: Decimal
    availableBalance: Decimal
    lockedBalance: Decimal
    currency: string
    lastTransactionAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: FinancialAccountCountAggregateOutputType | null
    _avg: FinancialAccountAvgAggregateOutputType | null
    _sum: FinancialAccountSumAggregateOutputType | null
    _min: FinancialAccountMinAggregateOutputType | null
    _max: FinancialAccountMaxAggregateOutputType | null
  }

  type GetFinancialAccountGroupByPayload<T extends FinancialAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancialAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancialAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancialAccountGroupByOutputType[P]>
            : GetScalarType<T[P], FinancialAccountGroupByOutputType[P]>
        }
      >
    >


  export type FinancialAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountType?: boolean
    balance?: boolean
    availableBalance?: boolean
    lockedBalance?: boolean
    currency?: boolean
    lastTransactionAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    transactions?: boolean | FinancialAccount$transactionsArgs<ExtArgs>
    _count?: boolean | FinancialAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialAccount"]>

  export type FinancialAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountType?: boolean
    balance?: boolean
    availableBalance?: boolean
    lockedBalance?: boolean
    currency?: boolean
    lastTransactionAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialAccount"]>

  export type FinancialAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountType?: boolean
    balance?: boolean
    availableBalance?: boolean
    lockedBalance?: boolean
    currency?: boolean
    lastTransactionAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialAccount"]>

  export type FinancialAccountSelectScalar = {
    id?: boolean
    userId?: boolean
    accountType?: boolean
    balance?: boolean
    availableBalance?: boolean
    lockedBalance?: boolean
    currency?: boolean
    lastTransactionAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FinancialAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "accountType" | "balance" | "availableBalance" | "lockedBalance" | "currency" | "lastTransactionAt" | "createdAt" | "updatedAt", ExtArgs["result"]["financialAccount"]>
  export type FinancialAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    transactions?: boolean | FinancialAccount$transactionsArgs<ExtArgs>
    _count?: boolean | FinancialAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FinancialAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FinancialAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FinancialAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinancialAccount"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accountType: string
      balance: Prisma.Decimal
      availableBalance: Prisma.Decimal
      lockedBalance: Prisma.Decimal
      currency: string
      lastTransactionAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["financialAccount"]>
    composites: {}
  }

  type FinancialAccountGetPayload<S extends boolean | null | undefined | FinancialAccountDefaultArgs> = $Result.GetResult<Prisma.$FinancialAccountPayload, S>

  type FinancialAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FinancialAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinancialAccountCountAggregateInputType | true
    }

  export interface FinancialAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancialAccount'], meta: { name: 'FinancialAccount' } }
    /**
     * Find zero or one FinancialAccount that matches the filter.
     * @param {FinancialAccountFindUniqueArgs} args - Arguments to find a FinancialAccount
     * @example
     * // Get one FinancialAccount
     * const financialAccount = await prisma.financialAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinancialAccountFindUniqueArgs>(args: SelectSubset<T, FinancialAccountFindUniqueArgs<ExtArgs>>): Prisma__FinancialAccountClient<$Result.GetResult<Prisma.$FinancialAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FinancialAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FinancialAccountFindUniqueOrThrowArgs} args - Arguments to find a FinancialAccount
     * @example
     * // Get one FinancialAccount
     * const financialAccount = await prisma.financialAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinancialAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, FinancialAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinancialAccountClient<$Result.GetResult<Prisma.$FinancialAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialAccountFindFirstArgs} args - Arguments to find a FinancialAccount
     * @example
     * // Get one FinancialAccount
     * const financialAccount = await prisma.financialAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinancialAccountFindFirstArgs>(args?: SelectSubset<T, FinancialAccountFindFirstArgs<ExtArgs>>): Prisma__FinancialAccountClient<$Result.GetResult<Prisma.$FinancialAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialAccountFindFirstOrThrowArgs} args - Arguments to find a FinancialAccount
     * @example
     * // Get one FinancialAccount
     * const financialAccount = await prisma.financialAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinancialAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, FinancialAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinancialAccountClient<$Result.GetResult<Prisma.$FinancialAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FinancialAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinancialAccounts
     * const financialAccounts = await prisma.financialAccount.findMany()
     * 
     * // Get first 10 FinancialAccounts
     * const financialAccounts = await prisma.financialAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financialAccountWithIdOnly = await prisma.financialAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinancialAccountFindManyArgs>(args?: SelectSubset<T, FinancialAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FinancialAccount.
     * @param {FinancialAccountCreateArgs} args - Arguments to create a FinancialAccount.
     * @example
     * // Create one FinancialAccount
     * const FinancialAccount = await prisma.financialAccount.create({
     *   data: {
     *     // ... data to create a FinancialAccount
     *   }
     * })
     * 
     */
    create<T extends FinancialAccountCreateArgs>(args: SelectSubset<T, FinancialAccountCreateArgs<ExtArgs>>): Prisma__FinancialAccountClient<$Result.GetResult<Prisma.$FinancialAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FinancialAccounts.
     * @param {FinancialAccountCreateManyArgs} args - Arguments to create many FinancialAccounts.
     * @example
     * // Create many FinancialAccounts
     * const financialAccount = await prisma.financialAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinancialAccountCreateManyArgs>(args?: SelectSubset<T, FinancialAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinancialAccounts and returns the data saved in the database.
     * @param {FinancialAccountCreateManyAndReturnArgs} args - Arguments to create many FinancialAccounts.
     * @example
     * // Create many FinancialAccounts
     * const financialAccount = await prisma.financialAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinancialAccounts and only return the `id`
     * const financialAccountWithIdOnly = await prisma.financialAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinancialAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, FinancialAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FinancialAccount.
     * @param {FinancialAccountDeleteArgs} args - Arguments to delete one FinancialAccount.
     * @example
     * // Delete one FinancialAccount
     * const FinancialAccount = await prisma.financialAccount.delete({
     *   where: {
     *     // ... filter to delete one FinancialAccount
     *   }
     * })
     * 
     */
    delete<T extends FinancialAccountDeleteArgs>(args: SelectSubset<T, FinancialAccountDeleteArgs<ExtArgs>>): Prisma__FinancialAccountClient<$Result.GetResult<Prisma.$FinancialAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FinancialAccount.
     * @param {FinancialAccountUpdateArgs} args - Arguments to update one FinancialAccount.
     * @example
     * // Update one FinancialAccount
     * const financialAccount = await prisma.financialAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinancialAccountUpdateArgs>(args: SelectSubset<T, FinancialAccountUpdateArgs<ExtArgs>>): Prisma__FinancialAccountClient<$Result.GetResult<Prisma.$FinancialAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FinancialAccounts.
     * @param {FinancialAccountDeleteManyArgs} args - Arguments to filter FinancialAccounts to delete.
     * @example
     * // Delete a few FinancialAccounts
     * const { count } = await prisma.financialAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinancialAccountDeleteManyArgs>(args?: SelectSubset<T, FinancialAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinancialAccounts
     * const financialAccount = await prisma.financialAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinancialAccountUpdateManyArgs>(args: SelectSubset<T, FinancialAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialAccounts and returns the data updated in the database.
     * @param {FinancialAccountUpdateManyAndReturnArgs} args - Arguments to update many FinancialAccounts.
     * @example
     * // Update many FinancialAccounts
     * const financialAccount = await prisma.financialAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FinancialAccounts and only return the `id`
     * const financialAccountWithIdOnly = await prisma.financialAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FinancialAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, FinancialAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FinancialAccount.
     * @param {FinancialAccountUpsertArgs} args - Arguments to update or create a FinancialAccount.
     * @example
     * // Update or create a FinancialAccount
     * const financialAccount = await prisma.financialAccount.upsert({
     *   create: {
     *     // ... data to create a FinancialAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinancialAccount we want to update
     *   }
     * })
     */
    upsert<T extends FinancialAccountUpsertArgs>(args: SelectSubset<T, FinancialAccountUpsertArgs<ExtArgs>>): Prisma__FinancialAccountClient<$Result.GetResult<Prisma.$FinancialAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FinancialAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialAccountCountArgs} args - Arguments to filter FinancialAccounts to count.
     * @example
     * // Count the number of FinancialAccounts
     * const count = await prisma.financialAccount.count({
     *   where: {
     *     // ... the filter for the FinancialAccounts we want to count
     *   }
     * })
    **/
    count<T extends FinancialAccountCountArgs>(
      args?: Subset<T, FinancialAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancialAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinancialAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancialAccountAggregateArgs>(args: Subset<T, FinancialAccountAggregateArgs>): Prisma.PrismaPromise<GetFinancialAccountAggregateType<T>>

    /**
     * Group by FinancialAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinancialAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinancialAccountGroupByArgs['orderBy'] }
        : { orderBy?: FinancialAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinancialAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancialAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinancialAccount model
   */
  readonly fields: FinancialAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinancialAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinancialAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends FinancialAccount$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, FinancialAccount$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinancialAccount model
   */
  interface FinancialAccountFieldRefs {
    readonly id: FieldRef<"FinancialAccount", 'String'>
    readonly userId: FieldRef<"FinancialAccount", 'String'>
    readonly accountType: FieldRef<"FinancialAccount", 'String'>
    readonly balance: FieldRef<"FinancialAccount", 'Decimal'>
    readonly availableBalance: FieldRef<"FinancialAccount", 'Decimal'>
    readonly lockedBalance: FieldRef<"FinancialAccount", 'Decimal'>
    readonly currency: FieldRef<"FinancialAccount", 'String'>
    readonly lastTransactionAt: FieldRef<"FinancialAccount", 'DateTime'>
    readonly createdAt: FieldRef<"FinancialAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"FinancialAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FinancialAccount findUnique
   */
  export type FinancialAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAccount
     */
    select?: FinancialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAccount
     */
    omit?: FinancialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAccountInclude<ExtArgs> | null
    /**
     * Filter, which FinancialAccount to fetch.
     */
    where: FinancialAccountWhereUniqueInput
  }

  /**
   * FinancialAccount findUniqueOrThrow
   */
  export type FinancialAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAccount
     */
    select?: FinancialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAccount
     */
    omit?: FinancialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAccountInclude<ExtArgs> | null
    /**
     * Filter, which FinancialAccount to fetch.
     */
    where: FinancialAccountWhereUniqueInput
  }

  /**
   * FinancialAccount findFirst
   */
  export type FinancialAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAccount
     */
    select?: FinancialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAccount
     */
    omit?: FinancialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAccountInclude<ExtArgs> | null
    /**
     * Filter, which FinancialAccount to fetch.
     */
    where?: FinancialAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialAccounts to fetch.
     */
    orderBy?: FinancialAccountOrderByWithRelationInput | FinancialAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialAccounts.
     */
    cursor?: FinancialAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialAccounts.
     */
    distinct?: FinancialAccountScalarFieldEnum | FinancialAccountScalarFieldEnum[]
  }

  /**
   * FinancialAccount findFirstOrThrow
   */
  export type FinancialAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAccount
     */
    select?: FinancialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAccount
     */
    omit?: FinancialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAccountInclude<ExtArgs> | null
    /**
     * Filter, which FinancialAccount to fetch.
     */
    where?: FinancialAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialAccounts to fetch.
     */
    orderBy?: FinancialAccountOrderByWithRelationInput | FinancialAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialAccounts.
     */
    cursor?: FinancialAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialAccounts.
     */
    distinct?: FinancialAccountScalarFieldEnum | FinancialAccountScalarFieldEnum[]
  }

  /**
   * FinancialAccount findMany
   */
  export type FinancialAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAccount
     */
    select?: FinancialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAccount
     */
    omit?: FinancialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAccountInclude<ExtArgs> | null
    /**
     * Filter, which FinancialAccounts to fetch.
     */
    where?: FinancialAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialAccounts to fetch.
     */
    orderBy?: FinancialAccountOrderByWithRelationInput | FinancialAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinancialAccounts.
     */
    cursor?: FinancialAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialAccounts.
     */
    skip?: number
    distinct?: FinancialAccountScalarFieldEnum | FinancialAccountScalarFieldEnum[]
  }

  /**
   * FinancialAccount create
   */
  export type FinancialAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAccount
     */
    select?: FinancialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAccount
     */
    omit?: FinancialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a FinancialAccount.
     */
    data: XOR<FinancialAccountCreateInput, FinancialAccountUncheckedCreateInput>
  }

  /**
   * FinancialAccount createMany
   */
  export type FinancialAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinancialAccounts.
     */
    data: FinancialAccountCreateManyInput | FinancialAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinancialAccount createManyAndReturn
   */
  export type FinancialAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAccount
     */
    select?: FinancialAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAccount
     */
    omit?: FinancialAccountOmit<ExtArgs> | null
    /**
     * The data used to create many FinancialAccounts.
     */
    data: FinancialAccountCreateManyInput | FinancialAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialAccount update
   */
  export type FinancialAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAccount
     */
    select?: FinancialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAccount
     */
    omit?: FinancialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a FinancialAccount.
     */
    data: XOR<FinancialAccountUpdateInput, FinancialAccountUncheckedUpdateInput>
    /**
     * Choose, which FinancialAccount to update.
     */
    where: FinancialAccountWhereUniqueInput
  }

  /**
   * FinancialAccount updateMany
   */
  export type FinancialAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinancialAccounts.
     */
    data: XOR<FinancialAccountUpdateManyMutationInput, FinancialAccountUncheckedUpdateManyInput>
    /**
     * Filter which FinancialAccounts to update
     */
    where?: FinancialAccountWhereInput
    /**
     * Limit how many FinancialAccounts to update.
     */
    limit?: number
  }

  /**
   * FinancialAccount updateManyAndReturn
   */
  export type FinancialAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAccount
     */
    select?: FinancialAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAccount
     */
    omit?: FinancialAccountOmit<ExtArgs> | null
    /**
     * The data used to update FinancialAccounts.
     */
    data: XOR<FinancialAccountUpdateManyMutationInput, FinancialAccountUncheckedUpdateManyInput>
    /**
     * Filter which FinancialAccounts to update
     */
    where?: FinancialAccountWhereInput
    /**
     * Limit how many FinancialAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialAccount upsert
   */
  export type FinancialAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAccount
     */
    select?: FinancialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAccount
     */
    omit?: FinancialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the FinancialAccount to update in case it exists.
     */
    where: FinancialAccountWhereUniqueInput
    /**
     * In case the FinancialAccount found by the `where` argument doesn't exist, create a new FinancialAccount with this data.
     */
    create: XOR<FinancialAccountCreateInput, FinancialAccountUncheckedCreateInput>
    /**
     * In case the FinancialAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinancialAccountUpdateInput, FinancialAccountUncheckedUpdateInput>
  }

  /**
   * FinancialAccount delete
   */
  export type FinancialAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAccount
     */
    select?: FinancialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAccount
     */
    omit?: FinancialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAccountInclude<ExtArgs> | null
    /**
     * Filter which FinancialAccount to delete.
     */
    where: FinancialAccountWhereUniqueInput
  }

  /**
   * FinancialAccount deleteMany
   */
  export type FinancialAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialAccounts to delete
     */
    where?: FinancialAccountWhereInput
    /**
     * Limit how many FinancialAccounts to delete.
     */
    limit?: number
  }

  /**
   * FinancialAccount.transactions
   */
  export type FinancialAccount$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * FinancialAccount without action
   */
  export type FinancialAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialAccount
     */
    select?: FinancialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialAccount
     */
    omit?: FinancialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialAccountInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: Decimal | null
    balanceBefore: Decimal | null
    balanceAfter: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: Decimal | null
    balanceBefore: Decimal | null
    balanceAfter: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    transactionType: string | null
    amount: Decimal | null
    balanceBefore: Decimal | null
    balanceAfter: Decimal | null
    status: string | null
    paymentMethodId: string | null
    externalTransactionId: string | null
    description: string | null
    createdAt: Date | null
    processedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    transactionType: string | null
    amount: Decimal | null
    balanceBefore: Decimal | null
    balanceAfter: Decimal | null
    status: string | null
    paymentMethodId: string | null
    externalTransactionId: string | null
    description: string | null
    createdAt: Date | null
    processedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    userId: number
    accountId: number
    transactionType: number
    amount: number
    balanceBefore: number
    balanceAfter: number
    status: number
    paymentMethodId: number
    externalTransactionId: number
    description: number
    metadata: number
    createdAt: number
    processedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
    balanceBefore?: true
    balanceAfter?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
    balanceBefore?: true
    balanceAfter?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    transactionType?: true
    amount?: true
    balanceBefore?: true
    balanceAfter?: true
    status?: true
    paymentMethodId?: true
    externalTransactionId?: true
    description?: true
    createdAt?: true
    processedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    transactionType?: true
    amount?: true
    balanceBefore?: true
    balanceAfter?: true
    status?: true
    paymentMethodId?: true
    externalTransactionId?: true
    description?: true
    createdAt?: true
    processedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    transactionType?: true
    amount?: true
    balanceBefore?: true
    balanceAfter?: true
    status?: true
    paymentMethodId?: true
    externalTransactionId?: true
    description?: true
    metadata?: true
    createdAt?: true
    processedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    userId: string
    accountId: string
    transactionType: string
    amount: Decimal
    balanceBefore: Decimal
    balanceAfter: Decimal
    status: string
    paymentMethodId: string | null
    externalTransactionId: string | null
    description: string | null
    metadata: JsonValue | null
    createdAt: Date
    processedAt: Date | null
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    transactionType?: boolean
    amount?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    status?: boolean
    paymentMethodId?: boolean
    externalTransactionId?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    processedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | FinancialAccountDefaultArgs<ExtArgs>
    paymentMethod?: boolean | Transaction$paymentMethodArgs<ExtArgs>
    deposit?: boolean | Transaction$depositArgs<ExtArgs>
    withdrawal?: boolean | Transaction$withdrawalArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    transactionType?: boolean
    amount?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    status?: boolean
    paymentMethodId?: boolean
    externalTransactionId?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    processedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | FinancialAccountDefaultArgs<ExtArgs>
    paymentMethod?: boolean | Transaction$paymentMethodArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    transactionType?: boolean
    amount?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    status?: boolean
    paymentMethodId?: boolean
    externalTransactionId?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    processedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | FinancialAccountDefaultArgs<ExtArgs>
    paymentMethod?: boolean | Transaction$paymentMethodArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    accountId?: boolean
    transactionType?: boolean
    amount?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    status?: boolean
    paymentMethodId?: boolean
    externalTransactionId?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    processedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "accountId" | "transactionType" | "amount" | "balanceBefore" | "balanceAfter" | "status" | "paymentMethodId" | "externalTransactionId" | "description" | "metadata" | "createdAt" | "processedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | FinancialAccountDefaultArgs<ExtArgs>
    paymentMethod?: boolean | Transaction$paymentMethodArgs<ExtArgs>
    deposit?: boolean | Transaction$depositArgs<ExtArgs>
    withdrawal?: boolean | Transaction$withdrawalArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | FinancialAccountDefaultArgs<ExtArgs>
    paymentMethod?: boolean | Transaction$paymentMethodArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | FinancialAccountDefaultArgs<ExtArgs>
    paymentMethod?: boolean | Transaction$paymentMethodArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      account: Prisma.$FinancialAccountPayload<ExtArgs>
      paymentMethod: Prisma.$PaymentMethodPayload<ExtArgs> | null
      deposit: Prisma.$DepositPayload<ExtArgs> | null
      withdrawal: Prisma.$WithdrawalPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accountId: string
      transactionType: string
      amount: Prisma.Decimal
      balanceBefore: Prisma.Decimal
      balanceAfter: Prisma.Decimal
      status: string
      paymentMethodId: string | null
      externalTransactionId: string | null
      description: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      processedAt: Date | null
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    account<T extends FinancialAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FinancialAccountDefaultArgs<ExtArgs>>): Prisma__FinancialAccountClient<$Result.GetResult<Prisma.$FinancialAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paymentMethod<T extends Transaction$paymentMethodArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$paymentMethodArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    deposit<T extends Transaction$depositArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$depositArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    withdrawal<T extends Transaction$withdrawalArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$withdrawalArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly userId: FieldRef<"Transaction", 'String'>
    readonly accountId: FieldRef<"Transaction", 'String'>
    readonly transactionType: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Decimal'>
    readonly balanceBefore: FieldRef<"Transaction", 'Decimal'>
    readonly balanceAfter: FieldRef<"Transaction", 'Decimal'>
    readonly status: FieldRef<"Transaction", 'String'>
    readonly paymentMethodId: FieldRef<"Transaction", 'String'>
    readonly externalTransactionId: FieldRef<"Transaction", 'String'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly metadata: FieldRef<"Transaction", 'Json'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly processedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.paymentMethod
   */
  export type Transaction$paymentMethodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    where?: PaymentMethodWhereInput
  }

  /**
   * Transaction.deposit
   */
  export type Transaction$depositArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    where?: DepositWhereInput
  }

  /**
   * Transaction.withdrawal
   */
  export type Transaction$withdrawalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    where?: WithdrawalWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model PaymentMethod
   */

  export type AggregatePaymentMethod = {
    _count: PaymentMethodCountAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  export type PaymentMethodMinAggregateOutputType = {
    id: string | null
    userId: string | null
    paymentType: string | null
    provider: string | null
    tokenizedId: string | null
    last4Digits: string | null
    expiryDate: string | null
    billingAddress: string | null
    isDefault: boolean | null
    verified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    paymentType: string | null
    provider: string | null
    tokenizedId: string | null
    last4Digits: string | null
    expiryDate: string | null
    billingAddress: string | null
    isDefault: boolean | null
    verified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodCountAggregateOutputType = {
    id: number
    userId: number
    paymentType: number
    provider: number
    tokenizedId: number
    last4Digits: number
    expiryDate: number
    billingAddress: number
    isDefault: number
    verified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentMethodMinAggregateInputType = {
    id?: true
    userId?: true
    paymentType?: true
    provider?: true
    tokenizedId?: true
    last4Digits?: true
    expiryDate?: true
    billingAddress?: true
    isDefault?: true
    verified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodMaxAggregateInputType = {
    id?: true
    userId?: true
    paymentType?: true
    provider?: true
    tokenizedId?: true
    last4Digits?: true
    expiryDate?: true
    billingAddress?: true
    isDefault?: true
    verified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodCountAggregateInputType = {
    id?: true
    userId?: true
    paymentType?: true
    provider?: true
    tokenizedId?: true
    last4Digits?: true
    expiryDate?: true
    billingAddress?: true
    isDefault?: true
    verified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethod to aggregate.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethods
    **/
    _count?: true | PaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type GetPaymentMethodAggregateType<T extends PaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethod[P]>
      : GetScalarType<T[P], AggregatePaymentMethod[P]>
  }




  export type PaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithAggregationInput | PaymentMethodOrderByWithAggregationInput[]
    by: PaymentMethodScalarFieldEnum[] | PaymentMethodScalarFieldEnum
    having?: PaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodCountAggregateInputType | true
    _min?: PaymentMethodMinAggregateInputType
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type PaymentMethodGroupByOutputType = {
    id: string
    userId: string
    paymentType: string
    provider: string
    tokenizedId: string
    last4Digits: string | null
    expiryDate: string | null
    billingAddress: string | null
    isDefault: boolean
    verified: boolean
    createdAt: Date
    updatedAt: Date
    _count: PaymentMethodCountAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  type GetPaymentMethodGroupByPayload<T extends PaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    paymentType?: boolean
    provider?: boolean
    tokenizedId?: boolean
    last4Digits?: boolean
    expiryDate?: boolean
    billingAddress?: boolean
    isDefault?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    transactions?: boolean | PaymentMethod$transactionsArgs<ExtArgs>
    deposits?: boolean | PaymentMethod$depositsArgs<ExtArgs>
    withdrawals?: boolean | PaymentMethod$withdrawalsArgs<ExtArgs>
    _count?: boolean | PaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    paymentType?: boolean
    provider?: boolean
    tokenizedId?: boolean
    last4Digits?: boolean
    expiryDate?: boolean
    billingAddress?: boolean
    isDefault?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    paymentType?: boolean
    provider?: boolean
    tokenizedId?: boolean
    last4Digits?: boolean
    expiryDate?: boolean
    billingAddress?: boolean
    isDefault?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectScalar = {
    id?: boolean
    userId?: boolean
    paymentType?: boolean
    provider?: boolean
    tokenizedId?: boolean
    last4Digits?: boolean
    expiryDate?: boolean
    billingAddress?: boolean
    isDefault?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "paymentType" | "provider" | "tokenizedId" | "last4Digits" | "expiryDate" | "billingAddress" | "isDefault" | "verified" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentMethod"]>
  export type PaymentMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    transactions?: boolean | PaymentMethod$transactionsArgs<ExtArgs>
    deposits?: boolean | PaymentMethod$depositsArgs<ExtArgs>
    withdrawals?: boolean | PaymentMethod$withdrawalsArgs<ExtArgs>
    _count?: boolean | PaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentMethodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentMethodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethod"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      deposits: Prisma.$DepositPayload<ExtArgs>[]
      withdrawals: Prisma.$WithdrawalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      paymentType: string
      provider: string
      tokenizedId: string
      last4Digits: string | null
      expiryDate: string | null
      billingAddress: string | null
      isDefault: boolean
      verified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentMethod"]>
    composites: {}
  }

  type PaymentMethodGetPayload<S extends boolean | null | undefined | PaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodPayload, S>

  type PaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentMethodCountAggregateInputType | true
    }

  export interface PaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethod'], meta: { name: 'PaymentMethod' } }
    /**
     * Find zero or one PaymentMethod that matches the filter.
     * @param {PaymentMethodFindUniqueArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodFindUniqueArgs>(args: SelectSubset<T, PaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodFindFirstArgs>(args?: SelectSubset<T, PaymentMethodFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany()
     * 
     * // Get first 10 PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentMethodFindManyArgs>(args?: SelectSubset<T, PaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentMethod.
     * @param {PaymentMethodCreateArgs} args - Arguments to create a PaymentMethod.
     * @example
     * // Create one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.create({
     *   data: {
     *     // ... data to create a PaymentMethod
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodCreateArgs>(args: SelectSubset<T, PaymentMethodCreateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentMethods.
     * @param {PaymentMethodCreateManyArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodCreateManyArgs>(args?: SelectSubset<T, PaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentMethods and returns the data saved in the database.
     * @param {PaymentMethodCreateManyAndReturnArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentMethod.
     * @param {PaymentMethodDeleteArgs} args - Arguments to delete one PaymentMethod.
     * @example
     * // Delete one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodDeleteArgs>(args: SelectSubset<T, PaymentMethodDeleteArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentMethod.
     * @param {PaymentMethodUpdateArgs} args - Arguments to update one PaymentMethod.
     * @example
     * // Update one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodUpdateArgs>(args: SelectSubset<T, PaymentMethodUpdateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentMethods.
     * @param {PaymentMethodDeleteManyArgs} args - Arguments to filter PaymentMethods to delete.
     * @example
     * // Delete a few PaymentMethods
     * const { count } = await prisma.paymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodUpdateManyArgs>(args: SelectSubset<T, PaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods and returns the data updated in the database.
     * @param {PaymentMethodUpdateManyAndReturnArgs} args - Arguments to update many PaymentMethods.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentMethodUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentMethodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentMethod.
     * @param {PaymentMethodUpsertArgs} args - Arguments to update or create a PaymentMethod.
     * @example
     * // Update or create a PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.upsert({
     *   create: {
     *     // ... data to create a PaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodUpsertArgs>(args: SelectSubset<T, PaymentMethodUpsertArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodCountArgs} args - Arguments to filter PaymentMethods to count.
     * @example
     * // Count the number of PaymentMethods
     * const count = await prisma.paymentMethod.count({
     *   where: {
     *     // ... the filter for the PaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodCountArgs>(
      args?: Subset<T, PaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodAggregateArgs>(args: Subset<T, PaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodAggregateType<T>>

    /**
     * Group by PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethod model
   */
  readonly fields: PaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends PaymentMethod$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethod$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deposits<T extends PaymentMethod$depositsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethod$depositsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    withdrawals<T extends PaymentMethod$withdrawalsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethod$withdrawalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethod model
   */
  interface PaymentMethodFieldRefs {
    readonly id: FieldRef<"PaymentMethod", 'String'>
    readonly userId: FieldRef<"PaymentMethod", 'String'>
    readonly paymentType: FieldRef<"PaymentMethod", 'String'>
    readonly provider: FieldRef<"PaymentMethod", 'String'>
    readonly tokenizedId: FieldRef<"PaymentMethod", 'String'>
    readonly last4Digits: FieldRef<"PaymentMethod", 'String'>
    readonly expiryDate: FieldRef<"PaymentMethod", 'String'>
    readonly billingAddress: FieldRef<"PaymentMethod", 'String'>
    readonly isDefault: FieldRef<"PaymentMethod", 'Boolean'>
    readonly verified: FieldRef<"PaymentMethod", 'Boolean'>
    readonly createdAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentMethod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethod findUnique
   */
  export type PaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findUniqueOrThrow
   */
  export type PaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findFirst
   */
  export type PaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findFirstOrThrow
   */
  export type PaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findMany
   */
  export type PaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod create
   */
  export type PaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethod.
     */
    data: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
  }

  /**
   * PaymentMethod createMany
   */
  export type PaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod createManyAndReturn
   */
  export type PaymentMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentMethod update
   */
  export type PaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethod.
     */
    data: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethod to update.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod updateMany
   */
  export type PaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod updateManyAndReturn
   */
  export type PaymentMethodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentMethod upsert
   */
  export type PaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethod to update in case it exists.
     */
    where: PaymentMethodWhereUniqueInput
    /**
     * In case the PaymentMethod found by the `where` argument doesn't exist, create a new PaymentMethod with this data.
     */
    create: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
    /**
     * In case the PaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
  }

  /**
   * PaymentMethod delete
   */
  export type PaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter which PaymentMethod to delete.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod deleteMany
   */
  export type PaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to delete
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * PaymentMethod.transactions
   */
  export type PaymentMethod$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * PaymentMethod.deposits
   */
  export type PaymentMethod$depositsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    where?: DepositWhereInput
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    cursor?: DepositWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepositScalarFieldEnum | DepositScalarFieldEnum[]
  }

  /**
   * PaymentMethod.withdrawals
   */
  export type PaymentMethod$withdrawalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    where?: WithdrawalWhereInput
    orderBy?: WithdrawalOrderByWithRelationInput | WithdrawalOrderByWithRelationInput[]
    cursor?: WithdrawalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * PaymentMethod without action
   */
  export type PaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
  }


  /**
   * Model Deposit
   */

  export type AggregateDeposit = {
    _count: DepositCountAggregateOutputType | null
    _avg: DepositAvgAggregateOutputType | null
    _sum: DepositSumAggregateOutputType | null
    _min: DepositMinAggregateOutputType | null
    _max: DepositMaxAggregateOutputType | null
  }

  export type DepositAvgAggregateOutputType = {
    amount: Decimal | null
    feeAmount: Decimal | null
    netAmount: Decimal | null
  }

  export type DepositSumAggregateOutputType = {
    amount: Decimal | null
    feeAmount: Decimal | null
    netAmount: Decimal | null
  }

  export type DepositMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    paymentMethodId: string | null
    amount: Decimal | null
    feeAmount: Decimal | null
    netAmount: Decimal | null
    providerTransactionId: string | null
    status: string | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepositMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    paymentMethodId: string | null
    amount: Decimal | null
    feeAmount: Decimal | null
    netAmount: Decimal | null
    providerTransactionId: string | null
    status: string | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepositCountAggregateOutputType = {
    id: number
    transactionId: number
    paymentMethodId: number
    amount: number
    feeAmount: number
    netAmount: number
    providerTransactionId: number
    status: number
    providerResponse: number
    processedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepositAvgAggregateInputType = {
    amount?: true
    feeAmount?: true
    netAmount?: true
  }

  export type DepositSumAggregateInputType = {
    amount?: true
    feeAmount?: true
    netAmount?: true
  }

  export type DepositMinAggregateInputType = {
    id?: true
    transactionId?: true
    paymentMethodId?: true
    amount?: true
    feeAmount?: true
    netAmount?: true
    providerTransactionId?: true
    status?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepositMaxAggregateInputType = {
    id?: true
    transactionId?: true
    paymentMethodId?: true
    amount?: true
    feeAmount?: true
    netAmount?: true
    providerTransactionId?: true
    status?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepositCountAggregateInputType = {
    id?: true
    transactionId?: true
    paymentMethodId?: true
    amount?: true
    feeAmount?: true
    netAmount?: true
    providerTransactionId?: true
    status?: true
    providerResponse?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepositAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deposit to aggregate.
     */
    where?: DepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deposits to fetch.
     */
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deposits
    **/
    _count?: true | DepositCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepositAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepositSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepositMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepositMaxAggregateInputType
  }

  export type GetDepositAggregateType<T extends DepositAggregateArgs> = {
        [P in keyof T & keyof AggregateDeposit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeposit[P]>
      : GetScalarType<T[P], AggregateDeposit[P]>
  }




  export type DepositGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepositWhereInput
    orderBy?: DepositOrderByWithAggregationInput | DepositOrderByWithAggregationInput[]
    by: DepositScalarFieldEnum[] | DepositScalarFieldEnum
    having?: DepositScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepositCountAggregateInputType | true
    _avg?: DepositAvgAggregateInputType
    _sum?: DepositSumAggregateInputType
    _min?: DepositMinAggregateInputType
    _max?: DepositMaxAggregateInputType
  }

  export type DepositGroupByOutputType = {
    id: string
    transactionId: string
    paymentMethodId: string
    amount: Decimal
    feeAmount: Decimal
    netAmount: Decimal
    providerTransactionId: string | null
    status: string
    providerResponse: JsonValue | null
    processedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DepositCountAggregateOutputType | null
    _avg: DepositAvgAggregateOutputType | null
    _sum: DepositSumAggregateOutputType | null
    _min: DepositMinAggregateOutputType | null
    _max: DepositMaxAggregateOutputType | null
  }

  type GetDepositGroupByPayload<T extends DepositGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepositGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepositGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepositGroupByOutputType[P]>
            : GetScalarType<T[P], DepositGroupByOutputType[P]>
        }
      >
    >


  export type DepositSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    paymentMethodId?: boolean
    amount?: boolean
    feeAmount?: boolean
    netAmount?: boolean
    providerTransactionId?: boolean
    status?: boolean
    providerResponse?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deposit"]>

  export type DepositSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    paymentMethodId?: boolean
    amount?: boolean
    feeAmount?: boolean
    netAmount?: boolean
    providerTransactionId?: boolean
    status?: boolean
    providerResponse?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deposit"]>

  export type DepositSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    paymentMethodId?: boolean
    amount?: boolean
    feeAmount?: boolean
    netAmount?: boolean
    providerTransactionId?: boolean
    status?: boolean
    providerResponse?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deposit"]>

  export type DepositSelectScalar = {
    id?: boolean
    transactionId?: boolean
    paymentMethodId?: boolean
    amount?: boolean
    feeAmount?: boolean
    netAmount?: boolean
    providerTransactionId?: boolean
    status?: boolean
    providerResponse?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepositOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "paymentMethodId" | "amount" | "feeAmount" | "netAmount" | "providerTransactionId" | "status" | "providerResponse" | "processedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["deposit"]>
  export type DepositInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }
  export type DepositIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }
  export type DepositIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }

  export type $DepositPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deposit"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>
      paymentMethod: Prisma.$PaymentMethodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      paymentMethodId: string
      amount: Prisma.Decimal
      feeAmount: Prisma.Decimal
      netAmount: Prisma.Decimal
      providerTransactionId: string | null
      status: string
      providerResponse: Prisma.JsonValue | null
      processedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deposit"]>
    composites: {}
  }

  type DepositGetPayload<S extends boolean | null | undefined | DepositDefaultArgs> = $Result.GetResult<Prisma.$DepositPayload, S>

  type DepositCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepositFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepositCountAggregateInputType | true
    }

  export interface DepositDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deposit'], meta: { name: 'Deposit' } }
    /**
     * Find zero or one Deposit that matches the filter.
     * @param {DepositFindUniqueArgs} args - Arguments to find a Deposit
     * @example
     * // Get one Deposit
     * const deposit = await prisma.deposit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepositFindUniqueArgs>(args: SelectSubset<T, DepositFindUniqueArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Deposit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepositFindUniqueOrThrowArgs} args - Arguments to find a Deposit
     * @example
     * // Get one Deposit
     * const deposit = await prisma.deposit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepositFindUniqueOrThrowArgs>(args: SelectSubset<T, DepositFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deposit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositFindFirstArgs} args - Arguments to find a Deposit
     * @example
     * // Get one Deposit
     * const deposit = await prisma.deposit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepositFindFirstArgs>(args?: SelectSubset<T, DepositFindFirstArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deposit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositFindFirstOrThrowArgs} args - Arguments to find a Deposit
     * @example
     * // Get one Deposit
     * const deposit = await prisma.deposit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepositFindFirstOrThrowArgs>(args?: SelectSubset<T, DepositFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Deposits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deposits
     * const deposits = await prisma.deposit.findMany()
     * 
     * // Get first 10 Deposits
     * const deposits = await prisma.deposit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const depositWithIdOnly = await prisma.deposit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepositFindManyArgs>(args?: SelectSubset<T, DepositFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Deposit.
     * @param {DepositCreateArgs} args - Arguments to create a Deposit.
     * @example
     * // Create one Deposit
     * const Deposit = await prisma.deposit.create({
     *   data: {
     *     // ... data to create a Deposit
     *   }
     * })
     * 
     */
    create<T extends DepositCreateArgs>(args: SelectSubset<T, DepositCreateArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Deposits.
     * @param {DepositCreateManyArgs} args - Arguments to create many Deposits.
     * @example
     * // Create many Deposits
     * const deposit = await prisma.deposit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepositCreateManyArgs>(args?: SelectSubset<T, DepositCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deposits and returns the data saved in the database.
     * @param {DepositCreateManyAndReturnArgs} args - Arguments to create many Deposits.
     * @example
     * // Create many Deposits
     * const deposit = await prisma.deposit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deposits and only return the `id`
     * const depositWithIdOnly = await prisma.deposit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepositCreateManyAndReturnArgs>(args?: SelectSubset<T, DepositCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Deposit.
     * @param {DepositDeleteArgs} args - Arguments to delete one Deposit.
     * @example
     * // Delete one Deposit
     * const Deposit = await prisma.deposit.delete({
     *   where: {
     *     // ... filter to delete one Deposit
     *   }
     * })
     * 
     */
    delete<T extends DepositDeleteArgs>(args: SelectSubset<T, DepositDeleteArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Deposit.
     * @param {DepositUpdateArgs} args - Arguments to update one Deposit.
     * @example
     * // Update one Deposit
     * const deposit = await prisma.deposit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepositUpdateArgs>(args: SelectSubset<T, DepositUpdateArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Deposits.
     * @param {DepositDeleteManyArgs} args - Arguments to filter Deposits to delete.
     * @example
     * // Delete a few Deposits
     * const { count } = await prisma.deposit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepositDeleteManyArgs>(args?: SelectSubset<T, DepositDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deposits
     * const deposit = await prisma.deposit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepositUpdateManyArgs>(args: SelectSubset<T, DepositUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deposits and returns the data updated in the database.
     * @param {DepositUpdateManyAndReturnArgs} args - Arguments to update many Deposits.
     * @example
     * // Update many Deposits
     * const deposit = await prisma.deposit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Deposits and only return the `id`
     * const depositWithIdOnly = await prisma.deposit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepositUpdateManyAndReturnArgs>(args: SelectSubset<T, DepositUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Deposit.
     * @param {DepositUpsertArgs} args - Arguments to update or create a Deposit.
     * @example
     * // Update or create a Deposit
     * const deposit = await prisma.deposit.upsert({
     *   create: {
     *     // ... data to create a Deposit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deposit we want to update
     *   }
     * })
     */
    upsert<T extends DepositUpsertArgs>(args: SelectSubset<T, DepositUpsertArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Deposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositCountArgs} args - Arguments to filter Deposits to count.
     * @example
     * // Count the number of Deposits
     * const count = await prisma.deposit.count({
     *   where: {
     *     // ... the filter for the Deposits we want to count
     *   }
     * })
    **/
    count<T extends DepositCountArgs>(
      args?: Subset<T, DepositCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepositCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deposit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepositAggregateArgs>(args: Subset<T, DepositAggregateArgs>): Prisma.PrismaPromise<GetDepositAggregateType<T>>

    /**
     * Group by Deposit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepositGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepositGroupByArgs['orderBy'] }
        : { orderBy?: DepositGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepositGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepositGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deposit model
   */
  readonly fields: DepositFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deposit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepositClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paymentMethod<T extends PaymentMethodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethodDefaultArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Deposit model
   */
  interface DepositFieldRefs {
    readonly id: FieldRef<"Deposit", 'String'>
    readonly transactionId: FieldRef<"Deposit", 'String'>
    readonly paymentMethodId: FieldRef<"Deposit", 'String'>
    readonly amount: FieldRef<"Deposit", 'Decimal'>
    readonly feeAmount: FieldRef<"Deposit", 'Decimal'>
    readonly netAmount: FieldRef<"Deposit", 'Decimal'>
    readonly providerTransactionId: FieldRef<"Deposit", 'String'>
    readonly status: FieldRef<"Deposit", 'String'>
    readonly providerResponse: FieldRef<"Deposit", 'Json'>
    readonly processedAt: FieldRef<"Deposit", 'DateTime'>
    readonly createdAt: FieldRef<"Deposit", 'DateTime'>
    readonly updatedAt: FieldRef<"Deposit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Deposit findUnique
   */
  export type DepositFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter, which Deposit to fetch.
     */
    where: DepositWhereUniqueInput
  }

  /**
   * Deposit findUniqueOrThrow
   */
  export type DepositFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter, which Deposit to fetch.
     */
    where: DepositWhereUniqueInput
  }

  /**
   * Deposit findFirst
   */
  export type DepositFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter, which Deposit to fetch.
     */
    where?: DepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deposits to fetch.
     */
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deposits.
     */
    cursor?: DepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deposits.
     */
    distinct?: DepositScalarFieldEnum | DepositScalarFieldEnum[]
  }

  /**
   * Deposit findFirstOrThrow
   */
  export type DepositFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter, which Deposit to fetch.
     */
    where?: DepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deposits to fetch.
     */
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deposits.
     */
    cursor?: DepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deposits.
     */
    distinct?: DepositScalarFieldEnum | DepositScalarFieldEnum[]
  }

  /**
   * Deposit findMany
   */
  export type DepositFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter, which Deposits to fetch.
     */
    where?: DepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deposits to fetch.
     */
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deposits.
     */
    cursor?: DepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deposits.
     */
    skip?: number
    distinct?: DepositScalarFieldEnum | DepositScalarFieldEnum[]
  }

  /**
   * Deposit create
   */
  export type DepositCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * The data needed to create a Deposit.
     */
    data: XOR<DepositCreateInput, DepositUncheckedCreateInput>
  }

  /**
   * Deposit createMany
   */
  export type DepositCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deposits.
     */
    data: DepositCreateManyInput | DepositCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Deposit createManyAndReturn
   */
  export type DepositCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * The data used to create many Deposits.
     */
    data: DepositCreateManyInput | DepositCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deposit update
   */
  export type DepositUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * The data needed to update a Deposit.
     */
    data: XOR<DepositUpdateInput, DepositUncheckedUpdateInput>
    /**
     * Choose, which Deposit to update.
     */
    where: DepositWhereUniqueInput
  }

  /**
   * Deposit updateMany
   */
  export type DepositUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deposits.
     */
    data: XOR<DepositUpdateManyMutationInput, DepositUncheckedUpdateManyInput>
    /**
     * Filter which Deposits to update
     */
    where?: DepositWhereInput
    /**
     * Limit how many Deposits to update.
     */
    limit?: number
  }

  /**
   * Deposit updateManyAndReturn
   */
  export type DepositUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * The data used to update Deposits.
     */
    data: XOR<DepositUpdateManyMutationInput, DepositUncheckedUpdateManyInput>
    /**
     * Filter which Deposits to update
     */
    where?: DepositWhereInput
    /**
     * Limit how many Deposits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deposit upsert
   */
  export type DepositUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * The filter to search for the Deposit to update in case it exists.
     */
    where: DepositWhereUniqueInput
    /**
     * In case the Deposit found by the `where` argument doesn't exist, create a new Deposit with this data.
     */
    create: XOR<DepositCreateInput, DepositUncheckedCreateInput>
    /**
     * In case the Deposit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepositUpdateInput, DepositUncheckedUpdateInput>
  }

  /**
   * Deposit delete
   */
  export type DepositDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter which Deposit to delete.
     */
    where: DepositWhereUniqueInput
  }

  /**
   * Deposit deleteMany
   */
  export type DepositDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deposits to delete
     */
    where?: DepositWhereInput
    /**
     * Limit how many Deposits to delete.
     */
    limit?: number
  }

  /**
   * Deposit without action
   */
  export type DepositDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
  }


  /**
   * Model Withdrawal
   */

  export type AggregateWithdrawal = {
    _count: WithdrawalCountAggregateOutputType | null
    _avg: WithdrawalAvgAggregateOutputType | null
    _sum: WithdrawalSumAggregateOutputType | null
    _min: WithdrawalMinAggregateOutputType | null
    _max: WithdrawalMaxAggregateOutputType | null
  }

  export type WithdrawalAvgAggregateOutputType = {
    amount: Decimal | null
    feeAmount: Decimal | null
    netAmount: Decimal | null
  }

  export type WithdrawalSumAggregateOutputType = {
    amount: Decimal | null
    feeAmount: Decimal | null
    netAmount: Decimal | null
  }

  export type WithdrawalMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    paymentMethodId: string | null
    amount: Decimal | null
    feeAmount: Decimal | null
    netAmount: Decimal | null
    status: string | null
    providerTransactionId: string | null
    kycVerificationRequired: boolean | null
    requestedAt: Date | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WithdrawalMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    paymentMethodId: string | null
    amount: Decimal | null
    feeAmount: Decimal | null
    netAmount: Decimal | null
    status: string | null
    providerTransactionId: string | null
    kycVerificationRequired: boolean | null
    requestedAt: Date | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WithdrawalCountAggregateOutputType = {
    id: number
    transactionId: number
    paymentMethodId: number
    amount: number
    feeAmount: number
    netAmount: number
    status: number
    providerTransactionId: number
    providerResponse: number
    kycVerificationRequired: number
    requestedAt: number
    processedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WithdrawalAvgAggregateInputType = {
    amount?: true
    feeAmount?: true
    netAmount?: true
  }

  export type WithdrawalSumAggregateInputType = {
    amount?: true
    feeAmount?: true
    netAmount?: true
  }

  export type WithdrawalMinAggregateInputType = {
    id?: true
    transactionId?: true
    paymentMethodId?: true
    amount?: true
    feeAmount?: true
    netAmount?: true
    status?: true
    providerTransactionId?: true
    kycVerificationRequired?: true
    requestedAt?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WithdrawalMaxAggregateInputType = {
    id?: true
    transactionId?: true
    paymentMethodId?: true
    amount?: true
    feeAmount?: true
    netAmount?: true
    status?: true
    providerTransactionId?: true
    kycVerificationRequired?: true
    requestedAt?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WithdrawalCountAggregateInputType = {
    id?: true
    transactionId?: true
    paymentMethodId?: true
    amount?: true
    feeAmount?: true
    netAmount?: true
    status?: true
    providerTransactionId?: true
    providerResponse?: true
    kycVerificationRequired?: true
    requestedAt?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WithdrawalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Withdrawal to aggregate.
     */
    where?: WithdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdrawals to fetch.
     */
    orderBy?: WithdrawalOrderByWithRelationInput | WithdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WithdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Withdrawals
    **/
    _count?: true | WithdrawalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WithdrawalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WithdrawalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WithdrawalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WithdrawalMaxAggregateInputType
  }

  export type GetWithdrawalAggregateType<T extends WithdrawalAggregateArgs> = {
        [P in keyof T & keyof AggregateWithdrawal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWithdrawal[P]>
      : GetScalarType<T[P], AggregateWithdrawal[P]>
  }




  export type WithdrawalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WithdrawalWhereInput
    orderBy?: WithdrawalOrderByWithAggregationInput | WithdrawalOrderByWithAggregationInput[]
    by: WithdrawalScalarFieldEnum[] | WithdrawalScalarFieldEnum
    having?: WithdrawalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WithdrawalCountAggregateInputType | true
    _avg?: WithdrawalAvgAggregateInputType
    _sum?: WithdrawalSumAggregateInputType
    _min?: WithdrawalMinAggregateInputType
    _max?: WithdrawalMaxAggregateInputType
  }

  export type WithdrawalGroupByOutputType = {
    id: string
    transactionId: string
    paymentMethodId: string
    amount: Decimal
    feeAmount: Decimal
    netAmount: Decimal
    status: string
    providerTransactionId: string | null
    providerResponse: JsonValue | null
    kycVerificationRequired: boolean
    requestedAt: Date
    processedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: WithdrawalCountAggregateOutputType | null
    _avg: WithdrawalAvgAggregateOutputType | null
    _sum: WithdrawalSumAggregateOutputType | null
    _min: WithdrawalMinAggregateOutputType | null
    _max: WithdrawalMaxAggregateOutputType | null
  }

  type GetWithdrawalGroupByPayload<T extends WithdrawalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WithdrawalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WithdrawalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WithdrawalGroupByOutputType[P]>
            : GetScalarType<T[P], WithdrawalGroupByOutputType[P]>
        }
      >
    >


  export type WithdrawalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    paymentMethodId?: boolean
    amount?: boolean
    feeAmount?: boolean
    netAmount?: boolean
    status?: boolean
    providerTransactionId?: boolean
    providerResponse?: boolean
    kycVerificationRequired?: boolean
    requestedAt?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["withdrawal"]>

  export type WithdrawalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    paymentMethodId?: boolean
    amount?: boolean
    feeAmount?: boolean
    netAmount?: boolean
    status?: boolean
    providerTransactionId?: boolean
    providerResponse?: boolean
    kycVerificationRequired?: boolean
    requestedAt?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["withdrawal"]>

  export type WithdrawalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    paymentMethodId?: boolean
    amount?: boolean
    feeAmount?: boolean
    netAmount?: boolean
    status?: boolean
    providerTransactionId?: boolean
    providerResponse?: boolean
    kycVerificationRequired?: boolean
    requestedAt?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["withdrawal"]>

  export type WithdrawalSelectScalar = {
    id?: boolean
    transactionId?: boolean
    paymentMethodId?: boolean
    amount?: boolean
    feeAmount?: boolean
    netAmount?: boolean
    status?: boolean
    providerTransactionId?: boolean
    providerResponse?: boolean
    kycVerificationRequired?: boolean
    requestedAt?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WithdrawalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "paymentMethodId" | "amount" | "feeAmount" | "netAmount" | "status" | "providerTransactionId" | "providerResponse" | "kycVerificationRequired" | "requestedAt" | "processedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["withdrawal"]>
  export type WithdrawalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }
  export type WithdrawalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }
  export type WithdrawalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }

  export type $WithdrawalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Withdrawal"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>
      paymentMethod: Prisma.$PaymentMethodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      paymentMethodId: string
      amount: Prisma.Decimal
      feeAmount: Prisma.Decimal
      netAmount: Prisma.Decimal
      status: string
      providerTransactionId: string | null
      providerResponse: Prisma.JsonValue | null
      kycVerificationRequired: boolean
      requestedAt: Date
      processedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["withdrawal"]>
    composites: {}
  }

  type WithdrawalGetPayload<S extends boolean | null | undefined | WithdrawalDefaultArgs> = $Result.GetResult<Prisma.$WithdrawalPayload, S>

  type WithdrawalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WithdrawalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WithdrawalCountAggregateInputType | true
    }

  export interface WithdrawalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Withdrawal'], meta: { name: 'Withdrawal' } }
    /**
     * Find zero or one Withdrawal that matches the filter.
     * @param {WithdrawalFindUniqueArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WithdrawalFindUniqueArgs>(args: SelectSubset<T, WithdrawalFindUniqueArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Withdrawal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WithdrawalFindUniqueOrThrowArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WithdrawalFindUniqueOrThrowArgs>(args: SelectSubset<T, WithdrawalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Withdrawal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalFindFirstArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WithdrawalFindFirstArgs>(args?: SelectSubset<T, WithdrawalFindFirstArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Withdrawal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalFindFirstOrThrowArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WithdrawalFindFirstOrThrowArgs>(args?: SelectSubset<T, WithdrawalFindFirstOrThrowArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Withdrawals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Withdrawals
     * const withdrawals = await prisma.withdrawal.findMany()
     * 
     * // Get first 10 Withdrawals
     * const withdrawals = await prisma.withdrawal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const withdrawalWithIdOnly = await prisma.withdrawal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WithdrawalFindManyArgs>(args?: SelectSubset<T, WithdrawalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Withdrawal.
     * @param {WithdrawalCreateArgs} args - Arguments to create a Withdrawal.
     * @example
     * // Create one Withdrawal
     * const Withdrawal = await prisma.withdrawal.create({
     *   data: {
     *     // ... data to create a Withdrawal
     *   }
     * })
     * 
     */
    create<T extends WithdrawalCreateArgs>(args: SelectSubset<T, WithdrawalCreateArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Withdrawals.
     * @param {WithdrawalCreateManyArgs} args - Arguments to create many Withdrawals.
     * @example
     * // Create many Withdrawals
     * const withdrawal = await prisma.withdrawal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WithdrawalCreateManyArgs>(args?: SelectSubset<T, WithdrawalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Withdrawals and returns the data saved in the database.
     * @param {WithdrawalCreateManyAndReturnArgs} args - Arguments to create many Withdrawals.
     * @example
     * // Create many Withdrawals
     * const withdrawal = await prisma.withdrawal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Withdrawals and only return the `id`
     * const withdrawalWithIdOnly = await prisma.withdrawal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WithdrawalCreateManyAndReturnArgs>(args?: SelectSubset<T, WithdrawalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Withdrawal.
     * @param {WithdrawalDeleteArgs} args - Arguments to delete one Withdrawal.
     * @example
     * // Delete one Withdrawal
     * const Withdrawal = await prisma.withdrawal.delete({
     *   where: {
     *     // ... filter to delete one Withdrawal
     *   }
     * })
     * 
     */
    delete<T extends WithdrawalDeleteArgs>(args: SelectSubset<T, WithdrawalDeleteArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Withdrawal.
     * @param {WithdrawalUpdateArgs} args - Arguments to update one Withdrawal.
     * @example
     * // Update one Withdrawal
     * const withdrawal = await prisma.withdrawal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WithdrawalUpdateArgs>(args: SelectSubset<T, WithdrawalUpdateArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Withdrawals.
     * @param {WithdrawalDeleteManyArgs} args - Arguments to filter Withdrawals to delete.
     * @example
     * // Delete a few Withdrawals
     * const { count } = await prisma.withdrawal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WithdrawalDeleteManyArgs>(args?: SelectSubset<T, WithdrawalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Withdrawals
     * const withdrawal = await prisma.withdrawal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WithdrawalUpdateManyArgs>(args: SelectSubset<T, WithdrawalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Withdrawals and returns the data updated in the database.
     * @param {WithdrawalUpdateManyAndReturnArgs} args - Arguments to update many Withdrawals.
     * @example
     * // Update many Withdrawals
     * const withdrawal = await prisma.withdrawal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Withdrawals and only return the `id`
     * const withdrawalWithIdOnly = await prisma.withdrawal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WithdrawalUpdateManyAndReturnArgs>(args: SelectSubset<T, WithdrawalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Withdrawal.
     * @param {WithdrawalUpsertArgs} args - Arguments to update or create a Withdrawal.
     * @example
     * // Update or create a Withdrawal
     * const withdrawal = await prisma.withdrawal.upsert({
     *   create: {
     *     // ... data to create a Withdrawal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Withdrawal we want to update
     *   }
     * })
     */
    upsert<T extends WithdrawalUpsertArgs>(args: SelectSubset<T, WithdrawalUpsertArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalCountArgs} args - Arguments to filter Withdrawals to count.
     * @example
     * // Count the number of Withdrawals
     * const count = await prisma.withdrawal.count({
     *   where: {
     *     // ... the filter for the Withdrawals we want to count
     *   }
     * })
    **/
    count<T extends WithdrawalCountArgs>(
      args?: Subset<T, WithdrawalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WithdrawalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Withdrawal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WithdrawalAggregateArgs>(args: Subset<T, WithdrawalAggregateArgs>): Prisma.PrismaPromise<GetWithdrawalAggregateType<T>>

    /**
     * Group by Withdrawal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WithdrawalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WithdrawalGroupByArgs['orderBy'] }
        : { orderBy?: WithdrawalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WithdrawalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWithdrawalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Withdrawal model
   */
  readonly fields: WithdrawalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Withdrawal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WithdrawalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paymentMethod<T extends PaymentMethodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethodDefaultArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Withdrawal model
   */
  interface WithdrawalFieldRefs {
    readonly id: FieldRef<"Withdrawal", 'String'>
    readonly transactionId: FieldRef<"Withdrawal", 'String'>
    readonly paymentMethodId: FieldRef<"Withdrawal", 'String'>
    readonly amount: FieldRef<"Withdrawal", 'Decimal'>
    readonly feeAmount: FieldRef<"Withdrawal", 'Decimal'>
    readonly netAmount: FieldRef<"Withdrawal", 'Decimal'>
    readonly status: FieldRef<"Withdrawal", 'String'>
    readonly providerTransactionId: FieldRef<"Withdrawal", 'String'>
    readonly providerResponse: FieldRef<"Withdrawal", 'Json'>
    readonly kycVerificationRequired: FieldRef<"Withdrawal", 'Boolean'>
    readonly requestedAt: FieldRef<"Withdrawal", 'DateTime'>
    readonly processedAt: FieldRef<"Withdrawal", 'DateTime'>
    readonly createdAt: FieldRef<"Withdrawal", 'DateTime'>
    readonly updatedAt: FieldRef<"Withdrawal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Withdrawal findUnique
   */
  export type WithdrawalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * Filter, which Withdrawal to fetch.
     */
    where: WithdrawalWhereUniqueInput
  }

  /**
   * Withdrawal findUniqueOrThrow
   */
  export type WithdrawalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * Filter, which Withdrawal to fetch.
     */
    where: WithdrawalWhereUniqueInput
  }

  /**
   * Withdrawal findFirst
   */
  export type WithdrawalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * Filter, which Withdrawal to fetch.
     */
    where?: WithdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdrawals to fetch.
     */
    orderBy?: WithdrawalOrderByWithRelationInput | WithdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Withdrawals.
     */
    cursor?: WithdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Withdrawals.
     */
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * Withdrawal findFirstOrThrow
   */
  export type WithdrawalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * Filter, which Withdrawal to fetch.
     */
    where?: WithdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdrawals to fetch.
     */
    orderBy?: WithdrawalOrderByWithRelationInput | WithdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Withdrawals.
     */
    cursor?: WithdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Withdrawals.
     */
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * Withdrawal findMany
   */
  export type WithdrawalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * Filter, which Withdrawals to fetch.
     */
    where?: WithdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdrawals to fetch.
     */
    orderBy?: WithdrawalOrderByWithRelationInput | WithdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Withdrawals.
     */
    cursor?: WithdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdrawals.
     */
    skip?: number
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * Withdrawal create
   */
  export type WithdrawalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * The data needed to create a Withdrawal.
     */
    data: XOR<WithdrawalCreateInput, WithdrawalUncheckedCreateInput>
  }

  /**
   * Withdrawal createMany
   */
  export type WithdrawalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Withdrawals.
     */
    data: WithdrawalCreateManyInput | WithdrawalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Withdrawal createManyAndReturn
   */
  export type WithdrawalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * The data used to create many Withdrawals.
     */
    data: WithdrawalCreateManyInput | WithdrawalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Withdrawal update
   */
  export type WithdrawalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * The data needed to update a Withdrawal.
     */
    data: XOR<WithdrawalUpdateInput, WithdrawalUncheckedUpdateInput>
    /**
     * Choose, which Withdrawal to update.
     */
    where: WithdrawalWhereUniqueInput
  }

  /**
   * Withdrawal updateMany
   */
  export type WithdrawalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Withdrawals.
     */
    data: XOR<WithdrawalUpdateManyMutationInput, WithdrawalUncheckedUpdateManyInput>
    /**
     * Filter which Withdrawals to update
     */
    where?: WithdrawalWhereInput
    /**
     * Limit how many Withdrawals to update.
     */
    limit?: number
  }

  /**
   * Withdrawal updateManyAndReturn
   */
  export type WithdrawalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * The data used to update Withdrawals.
     */
    data: XOR<WithdrawalUpdateManyMutationInput, WithdrawalUncheckedUpdateManyInput>
    /**
     * Filter which Withdrawals to update
     */
    where?: WithdrawalWhereInput
    /**
     * Limit how many Withdrawals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Withdrawal upsert
   */
  export type WithdrawalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * The filter to search for the Withdrawal to update in case it exists.
     */
    where: WithdrawalWhereUniqueInput
    /**
     * In case the Withdrawal found by the `where` argument doesn't exist, create a new Withdrawal with this data.
     */
    create: XOR<WithdrawalCreateInput, WithdrawalUncheckedCreateInput>
    /**
     * In case the Withdrawal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WithdrawalUpdateInput, WithdrawalUncheckedUpdateInput>
  }

  /**
   * Withdrawal delete
   */
  export type WithdrawalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * Filter which Withdrawal to delete.
     */
    where: WithdrawalWhereUniqueInput
  }

  /**
   * Withdrawal deleteMany
   */
  export type WithdrawalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Withdrawals to delete
     */
    where?: WithdrawalWhereInput
    /**
     * Limit how many Withdrawals to delete.
     */
    limit?: number
  }

  /**
   * Withdrawal without action
   */
  export type WithdrawalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
  }


  /**
   * Model FraudEvent
   */

  export type AggregateFraudEvent = {
    _count: FraudEventCountAggregateOutputType | null
    _avg: FraudEventAvgAggregateOutputType | null
    _sum: FraudEventSumAggregateOutputType | null
    _min: FraudEventMinAggregateOutputType | null
    _max: FraudEventMaxAggregateOutputType | null
  }

  export type FraudEventAvgAggregateOutputType = {
    riskScore: number | null
  }

  export type FraudEventSumAggregateOutputType = {
    riskScore: number | null
  }

  export type FraudEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    eventType: string | null
    severity: string | null
    riskScore: number | null
    description: string | null
    status: string | null
    reviewedBy: string | null
    reviewedAt: Date | null
    createdAt: Date | null
  }

  export type FraudEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    eventType: string | null
    severity: string | null
    riskScore: number | null
    description: string | null
    status: string | null
    reviewedBy: string | null
    reviewedAt: Date | null
    createdAt: Date | null
  }

  export type FraudEventCountAggregateOutputType = {
    id: number
    userId: number
    eventType: number
    severity: number
    riskScore: number
    description: number
    metadata: number
    status: number
    reviewedBy: number
    reviewedAt: number
    createdAt: number
    _all: number
  }


  export type FraudEventAvgAggregateInputType = {
    riskScore?: true
  }

  export type FraudEventSumAggregateInputType = {
    riskScore?: true
  }

  export type FraudEventMinAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    severity?: true
    riskScore?: true
    description?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
  }

  export type FraudEventMaxAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    severity?: true
    riskScore?: true
    description?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
  }

  export type FraudEventCountAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    severity?: true
    riskScore?: true
    description?: true
    metadata?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
    _all?: true
  }

  export type FraudEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FraudEvent to aggregate.
     */
    where?: FraudEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FraudEvents to fetch.
     */
    orderBy?: FraudEventOrderByWithRelationInput | FraudEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FraudEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FraudEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FraudEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FraudEvents
    **/
    _count?: true | FraudEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FraudEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FraudEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FraudEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FraudEventMaxAggregateInputType
  }

  export type GetFraudEventAggregateType<T extends FraudEventAggregateArgs> = {
        [P in keyof T & keyof AggregateFraudEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFraudEvent[P]>
      : GetScalarType<T[P], AggregateFraudEvent[P]>
  }




  export type FraudEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FraudEventWhereInput
    orderBy?: FraudEventOrderByWithAggregationInput | FraudEventOrderByWithAggregationInput[]
    by: FraudEventScalarFieldEnum[] | FraudEventScalarFieldEnum
    having?: FraudEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FraudEventCountAggregateInputType | true
    _avg?: FraudEventAvgAggregateInputType
    _sum?: FraudEventSumAggregateInputType
    _min?: FraudEventMinAggregateInputType
    _max?: FraudEventMaxAggregateInputType
  }

  export type FraudEventGroupByOutputType = {
    id: string
    userId: string | null
    eventType: string
    severity: string
    riskScore: number
    description: string | null
    metadata: JsonValue | null
    status: string
    reviewedBy: string | null
    reviewedAt: Date | null
    createdAt: Date
    _count: FraudEventCountAggregateOutputType | null
    _avg: FraudEventAvgAggregateOutputType | null
    _sum: FraudEventSumAggregateOutputType | null
    _min: FraudEventMinAggregateOutputType | null
    _max: FraudEventMaxAggregateOutputType | null
  }

  type GetFraudEventGroupByPayload<T extends FraudEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FraudEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FraudEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FraudEventGroupByOutputType[P]>
            : GetScalarType<T[P], FraudEventGroupByOutputType[P]>
        }
      >
    >


  export type FraudEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    severity?: boolean
    riskScore?: boolean
    description?: boolean
    metadata?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    user?: boolean | FraudEvent$userArgs<ExtArgs>
  }, ExtArgs["result"]["fraudEvent"]>

  export type FraudEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    severity?: boolean
    riskScore?: boolean
    description?: boolean
    metadata?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    user?: boolean | FraudEvent$userArgs<ExtArgs>
  }, ExtArgs["result"]["fraudEvent"]>

  export type FraudEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    severity?: boolean
    riskScore?: boolean
    description?: boolean
    metadata?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    user?: boolean | FraudEvent$userArgs<ExtArgs>
  }, ExtArgs["result"]["fraudEvent"]>

  export type FraudEventSelectScalar = {
    id?: boolean
    userId?: boolean
    eventType?: boolean
    severity?: boolean
    riskScore?: boolean
    description?: boolean
    metadata?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
  }

  export type FraudEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "eventType" | "severity" | "riskScore" | "description" | "metadata" | "status" | "reviewedBy" | "reviewedAt" | "createdAt", ExtArgs["result"]["fraudEvent"]>
  export type FraudEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | FraudEvent$userArgs<ExtArgs>
  }
  export type FraudEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | FraudEvent$userArgs<ExtArgs>
  }
  export type FraudEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | FraudEvent$userArgs<ExtArgs>
  }

  export type $FraudEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FraudEvent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      eventType: string
      severity: string
      riskScore: number
      description: string | null
      metadata: Prisma.JsonValue | null
      status: string
      reviewedBy: string | null
      reviewedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["fraudEvent"]>
    composites: {}
  }

  type FraudEventGetPayload<S extends boolean | null | undefined | FraudEventDefaultArgs> = $Result.GetResult<Prisma.$FraudEventPayload, S>

  type FraudEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FraudEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FraudEventCountAggregateInputType | true
    }

  export interface FraudEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FraudEvent'], meta: { name: 'FraudEvent' } }
    /**
     * Find zero or one FraudEvent that matches the filter.
     * @param {FraudEventFindUniqueArgs} args - Arguments to find a FraudEvent
     * @example
     * // Get one FraudEvent
     * const fraudEvent = await prisma.fraudEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FraudEventFindUniqueArgs>(args: SelectSubset<T, FraudEventFindUniqueArgs<ExtArgs>>): Prisma__FraudEventClient<$Result.GetResult<Prisma.$FraudEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FraudEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FraudEventFindUniqueOrThrowArgs} args - Arguments to find a FraudEvent
     * @example
     * // Get one FraudEvent
     * const fraudEvent = await prisma.fraudEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FraudEventFindUniqueOrThrowArgs>(args: SelectSubset<T, FraudEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FraudEventClient<$Result.GetResult<Prisma.$FraudEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FraudEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FraudEventFindFirstArgs} args - Arguments to find a FraudEvent
     * @example
     * // Get one FraudEvent
     * const fraudEvent = await prisma.fraudEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FraudEventFindFirstArgs>(args?: SelectSubset<T, FraudEventFindFirstArgs<ExtArgs>>): Prisma__FraudEventClient<$Result.GetResult<Prisma.$FraudEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FraudEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FraudEventFindFirstOrThrowArgs} args - Arguments to find a FraudEvent
     * @example
     * // Get one FraudEvent
     * const fraudEvent = await prisma.fraudEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FraudEventFindFirstOrThrowArgs>(args?: SelectSubset<T, FraudEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__FraudEventClient<$Result.GetResult<Prisma.$FraudEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FraudEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FraudEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FraudEvents
     * const fraudEvents = await prisma.fraudEvent.findMany()
     * 
     * // Get first 10 FraudEvents
     * const fraudEvents = await prisma.fraudEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fraudEventWithIdOnly = await prisma.fraudEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FraudEventFindManyArgs>(args?: SelectSubset<T, FraudEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FraudEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FraudEvent.
     * @param {FraudEventCreateArgs} args - Arguments to create a FraudEvent.
     * @example
     * // Create one FraudEvent
     * const FraudEvent = await prisma.fraudEvent.create({
     *   data: {
     *     // ... data to create a FraudEvent
     *   }
     * })
     * 
     */
    create<T extends FraudEventCreateArgs>(args: SelectSubset<T, FraudEventCreateArgs<ExtArgs>>): Prisma__FraudEventClient<$Result.GetResult<Prisma.$FraudEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FraudEvents.
     * @param {FraudEventCreateManyArgs} args - Arguments to create many FraudEvents.
     * @example
     * // Create many FraudEvents
     * const fraudEvent = await prisma.fraudEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FraudEventCreateManyArgs>(args?: SelectSubset<T, FraudEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FraudEvents and returns the data saved in the database.
     * @param {FraudEventCreateManyAndReturnArgs} args - Arguments to create many FraudEvents.
     * @example
     * // Create many FraudEvents
     * const fraudEvent = await prisma.fraudEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FraudEvents and only return the `id`
     * const fraudEventWithIdOnly = await prisma.fraudEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FraudEventCreateManyAndReturnArgs>(args?: SelectSubset<T, FraudEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FraudEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FraudEvent.
     * @param {FraudEventDeleteArgs} args - Arguments to delete one FraudEvent.
     * @example
     * // Delete one FraudEvent
     * const FraudEvent = await prisma.fraudEvent.delete({
     *   where: {
     *     // ... filter to delete one FraudEvent
     *   }
     * })
     * 
     */
    delete<T extends FraudEventDeleteArgs>(args: SelectSubset<T, FraudEventDeleteArgs<ExtArgs>>): Prisma__FraudEventClient<$Result.GetResult<Prisma.$FraudEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FraudEvent.
     * @param {FraudEventUpdateArgs} args - Arguments to update one FraudEvent.
     * @example
     * // Update one FraudEvent
     * const fraudEvent = await prisma.fraudEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FraudEventUpdateArgs>(args: SelectSubset<T, FraudEventUpdateArgs<ExtArgs>>): Prisma__FraudEventClient<$Result.GetResult<Prisma.$FraudEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FraudEvents.
     * @param {FraudEventDeleteManyArgs} args - Arguments to filter FraudEvents to delete.
     * @example
     * // Delete a few FraudEvents
     * const { count } = await prisma.fraudEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FraudEventDeleteManyArgs>(args?: SelectSubset<T, FraudEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FraudEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FraudEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FraudEvents
     * const fraudEvent = await prisma.fraudEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FraudEventUpdateManyArgs>(args: SelectSubset<T, FraudEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FraudEvents and returns the data updated in the database.
     * @param {FraudEventUpdateManyAndReturnArgs} args - Arguments to update many FraudEvents.
     * @example
     * // Update many FraudEvents
     * const fraudEvent = await prisma.fraudEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FraudEvents and only return the `id`
     * const fraudEventWithIdOnly = await prisma.fraudEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FraudEventUpdateManyAndReturnArgs>(args: SelectSubset<T, FraudEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FraudEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FraudEvent.
     * @param {FraudEventUpsertArgs} args - Arguments to update or create a FraudEvent.
     * @example
     * // Update or create a FraudEvent
     * const fraudEvent = await prisma.fraudEvent.upsert({
     *   create: {
     *     // ... data to create a FraudEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FraudEvent we want to update
     *   }
     * })
     */
    upsert<T extends FraudEventUpsertArgs>(args: SelectSubset<T, FraudEventUpsertArgs<ExtArgs>>): Prisma__FraudEventClient<$Result.GetResult<Prisma.$FraudEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FraudEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FraudEventCountArgs} args - Arguments to filter FraudEvents to count.
     * @example
     * // Count the number of FraudEvents
     * const count = await prisma.fraudEvent.count({
     *   where: {
     *     // ... the filter for the FraudEvents we want to count
     *   }
     * })
    **/
    count<T extends FraudEventCountArgs>(
      args?: Subset<T, FraudEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FraudEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FraudEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FraudEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FraudEventAggregateArgs>(args: Subset<T, FraudEventAggregateArgs>): Prisma.PrismaPromise<GetFraudEventAggregateType<T>>

    /**
     * Group by FraudEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FraudEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FraudEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FraudEventGroupByArgs['orderBy'] }
        : { orderBy?: FraudEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FraudEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFraudEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FraudEvent model
   */
  readonly fields: FraudEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FraudEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FraudEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends FraudEvent$userArgs<ExtArgs> = {}>(args?: Subset<T, FraudEvent$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FraudEvent model
   */
  interface FraudEventFieldRefs {
    readonly id: FieldRef<"FraudEvent", 'String'>
    readonly userId: FieldRef<"FraudEvent", 'String'>
    readonly eventType: FieldRef<"FraudEvent", 'String'>
    readonly severity: FieldRef<"FraudEvent", 'String'>
    readonly riskScore: FieldRef<"FraudEvent", 'Int'>
    readonly description: FieldRef<"FraudEvent", 'String'>
    readonly metadata: FieldRef<"FraudEvent", 'Json'>
    readonly status: FieldRef<"FraudEvent", 'String'>
    readonly reviewedBy: FieldRef<"FraudEvent", 'String'>
    readonly reviewedAt: FieldRef<"FraudEvent", 'DateTime'>
    readonly createdAt: FieldRef<"FraudEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FraudEvent findUnique
   */
  export type FraudEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudEvent
     */
    select?: FraudEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudEvent
     */
    omit?: FraudEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudEventInclude<ExtArgs> | null
    /**
     * Filter, which FraudEvent to fetch.
     */
    where: FraudEventWhereUniqueInput
  }

  /**
   * FraudEvent findUniqueOrThrow
   */
  export type FraudEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudEvent
     */
    select?: FraudEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudEvent
     */
    omit?: FraudEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudEventInclude<ExtArgs> | null
    /**
     * Filter, which FraudEvent to fetch.
     */
    where: FraudEventWhereUniqueInput
  }

  /**
   * FraudEvent findFirst
   */
  export type FraudEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudEvent
     */
    select?: FraudEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudEvent
     */
    omit?: FraudEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudEventInclude<ExtArgs> | null
    /**
     * Filter, which FraudEvent to fetch.
     */
    where?: FraudEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FraudEvents to fetch.
     */
    orderBy?: FraudEventOrderByWithRelationInput | FraudEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FraudEvents.
     */
    cursor?: FraudEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FraudEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FraudEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FraudEvents.
     */
    distinct?: FraudEventScalarFieldEnum | FraudEventScalarFieldEnum[]
  }

  /**
   * FraudEvent findFirstOrThrow
   */
  export type FraudEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudEvent
     */
    select?: FraudEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudEvent
     */
    omit?: FraudEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudEventInclude<ExtArgs> | null
    /**
     * Filter, which FraudEvent to fetch.
     */
    where?: FraudEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FraudEvents to fetch.
     */
    orderBy?: FraudEventOrderByWithRelationInput | FraudEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FraudEvents.
     */
    cursor?: FraudEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FraudEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FraudEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FraudEvents.
     */
    distinct?: FraudEventScalarFieldEnum | FraudEventScalarFieldEnum[]
  }

  /**
   * FraudEvent findMany
   */
  export type FraudEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudEvent
     */
    select?: FraudEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudEvent
     */
    omit?: FraudEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudEventInclude<ExtArgs> | null
    /**
     * Filter, which FraudEvents to fetch.
     */
    where?: FraudEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FraudEvents to fetch.
     */
    orderBy?: FraudEventOrderByWithRelationInput | FraudEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FraudEvents.
     */
    cursor?: FraudEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FraudEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FraudEvents.
     */
    skip?: number
    distinct?: FraudEventScalarFieldEnum | FraudEventScalarFieldEnum[]
  }

  /**
   * FraudEvent create
   */
  export type FraudEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudEvent
     */
    select?: FraudEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudEvent
     */
    omit?: FraudEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudEventInclude<ExtArgs> | null
    /**
     * The data needed to create a FraudEvent.
     */
    data: XOR<FraudEventCreateInput, FraudEventUncheckedCreateInput>
  }

  /**
   * FraudEvent createMany
   */
  export type FraudEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FraudEvents.
     */
    data: FraudEventCreateManyInput | FraudEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FraudEvent createManyAndReturn
   */
  export type FraudEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudEvent
     */
    select?: FraudEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FraudEvent
     */
    omit?: FraudEventOmit<ExtArgs> | null
    /**
     * The data used to create many FraudEvents.
     */
    data: FraudEventCreateManyInput | FraudEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FraudEvent update
   */
  export type FraudEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudEvent
     */
    select?: FraudEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudEvent
     */
    omit?: FraudEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudEventInclude<ExtArgs> | null
    /**
     * The data needed to update a FraudEvent.
     */
    data: XOR<FraudEventUpdateInput, FraudEventUncheckedUpdateInput>
    /**
     * Choose, which FraudEvent to update.
     */
    where: FraudEventWhereUniqueInput
  }

  /**
   * FraudEvent updateMany
   */
  export type FraudEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FraudEvents.
     */
    data: XOR<FraudEventUpdateManyMutationInput, FraudEventUncheckedUpdateManyInput>
    /**
     * Filter which FraudEvents to update
     */
    where?: FraudEventWhereInput
    /**
     * Limit how many FraudEvents to update.
     */
    limit?: number
  }

  /**
   * FraudEvent updateManyAndReturn
   */
  export type FraudEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudEvent
     */
    select?: FraudEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FraudEvent
     */
    omit?: FraudEventOmit<ExtArgs> | null
    /**
     * The data used to update FraudEvents.
     */
    data: XOR<FraudEventUpdateManyMutationInput, FraudEventUncheckedUpdateManyInput>
    /**
     * Filter which FraudEvents to update
     */
    where?: FraudEventWhereInput
    /**
     * Limit how many FraudEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FraudEvent upsert
   */
  export type FraudEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudEvent
     */
    select?: FraudEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudEvent
     */
    omit?: FraudEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudEventInclude<ExtArgs> | null
    /**
     * The filter to search for the FraudEvent to update in case it exists.
     */
    where: FraudEventWhereUniqueInput
    /**
     * In case the FraudEvent found by the `where` argument doesn't exist, create a new FraudEvent with this data.
     */
    create: XOR<FraudEventCreateInput, FraudEventUncheckedCreateInput>
    /**
     * In case the FraudEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FraudEventUpdateInput, FraudEventUncheckedUpdateInput>
  }

  /**
   * FraudEvent delete
   */
  export type FraudEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudEvent
     */
    select?: FraudEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudEvent
     */
    omit?: FraudEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudEventInclude<ExtArgs> | null
    /**
     * Filter which FraudEvent to delete.
     */
    where: FraudEventWhereUniqueInput
  }

  /**
   * FraudEvent deleteMany
   */
  export type FraudEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FraudEvents to delete
     */
    where?: FraudEventWhereInput
    /**
     * Limit how many FraudEvents to delete.
     */
    limit?: number
  }

  /**
   * FraudEvent.user
   */
  export type FraudEvent$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * FraudEvent without action
   */
  export type FraudEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudEvent
     */
    select?: FraudEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudEvent
     */
    omit?: FraudEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudEventInclude<ExtArgs> | null
  }


  /**
   * Model BettingPattern
   */

  export type AggregateBettingPattern = {
    _count: BettingPatternCountAggregateOutputType | null
    _avg: BettingPatternAvgAggregateOutputType | null
    _sum: BettingPatternSumAggregateOutputType | null
    _min: BettingPatternMinAggregateOutputType | null
    _max: BettingPatternMaxAggregateOutputType | null
  }

  export type BettingPatternAvgAggregateOutputType = {
    riskScore: number | null
  }

  export type BettingPatternSumAggregateOutputType = {
    riskScore: number | null
  }

  export type BettingPatternMinAggregateOutputType = {
    id: string | null
    userId: string | null
    patternType: string | null
    detectedAt: Date | null
    riskScore: number | null
    actionTaken: string | null
  }

  export type BettingPatternMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    patternType: string | null
    detectedAt: Date | null
    riskScore: number | null
    actionTaken: string | null
  }

  export type BettingPatternCountAggregateOutputType = {
    id: number
    userId: number
    patternType: number
    patternDetails: number
    detectedAt: number
    riskScore: number
    actionTaken: number
    _all: number
  }


  export type BettingPatternAvgAggregateInputType = {
    riskScore?: true
  }

  export type BettingPatternSumAggregateInputType = {
    riskScore?: true
  }

  export type BettingPatternMinAggregateInputType = {
    id?: true
    userId?: true
    patternType?: true
    detectedAt?: true
    riskScore?: true
    actionTaken?: true
  }

  export type BettingPatternMaxAggregateInputType = {
    id?: true
    userId?: true
    patternType?: true
    detectedAt?: true
    riskScore?: true
    actionTaken?: true
  }

  export type BettingPatternCountAggregateInputType = {
    id?: true
    userId?: true
    patternType?: true
    patternDetails?: true
    detectedAt?: true
    riskScore?: true
    actionTaken?: true
    _all?: true
  }

  export type BettingPatternAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BettingPattern to aggregate.
     */
    where?: BettingPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BettingPatterns to fetch.
     */
    orderBy?: BettingPatternOrderByWithRelationInput | BettingPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BettingPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BettingPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BettingPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BettingPatterns
    **/
    _count?: true | BettingPatternCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BettingPatternAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BettingPatternSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BettingPatternMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BettingPatternMaxAggregateInputType
  }

  export type GetBettingPatternAggregateType<T extends BettingPatternAggregateArgs> = {
        [P in keyof T & keyof AggregateBettingPattern]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBettingPattern[P]>
      : GetScalarType<T[P], AggregateBettingPattern[P]>
  }




  export type BettingPatternGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BettingPatternWhereInput
    orderBy?: BettingPatternOrderByWithAggregationInput | BettingPatternOrderByWithAggregationInput[]
    by: BettingPatternScalarFieldEnum[] | BettingPatternScalarFieldEnum
    having?: BettingPatternScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BettingPatternCountAggregateInputType | true
    _avg?: BettingPatternAvgAggregateInputType
    _sum?: BettingPatternSumAggregateInputType
    _min?: BettingPatternMinAggregateInputType
    _max?: BettingPatternMaxAggregateInputType
  }

  export type BettingPatternGroupByOutputType = {
    id: string
    userId: string
    patternType: string
    patternDetails: JsonValue | null
    detectedAt: Date
    riskScore: number
    actionTaken: string | null
    _count: BettingPatternCountAggregateOutputType | null
    _avg: BettingPatternAvgAggregateOutputType | null
    _sum: BettingPatternSumAggregateOutputType | null
    _min: BettingPatternMinAggregateOutputType | null
    _max: BettingPatternMaxAggregateOutputType | null
  }

  type GetBettingPatternGroupByPayload<T extends BettingPatternGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BettingPatternGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BettingPatternGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BettingPatternGroupByOutputType[P]>
            : GetScalarType<T[P], BettingPatternGroupByOutputType[P]>
        }
      >
    >


  export type BettingPatternSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    patternType?: boolean
    patternDetails?: boolean
    detectedAt?: boolean
    riskScore?: boolean
    actionTaken?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bettingPattern"]>

  export type BettingPatternSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    patternType?: boolean
    patternDetails?: boolean
    detectedAt?: boolean
    riskScore?: boolean
    actionTaken?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bettingPattern"]>

  export type BettingPatternSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    patternType?: boolean
    patternDetails?: boolean
    detectedAt?: boolean
    riskScore?: boolean
    actionTaken?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bettingPattern"]>

  export type BettingPatternSelectScalar = {
    id?: boolean
    userId?: boolean
    patternType?: boolean
    patternDetails?: boolean
    detectedAt?: boolean
    riskScore?: boolean
    actionTaken?: boolean
  }

  export type BettingPatternOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "patternType" | "patternDetails" | "detectedAt" | "riskScore" | "actionTaken", ExtArgs["result"]["bettingPattern"]>
  export type BettingPatternInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BettingPatternIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BettingPatternIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BettingPatternPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BettingPattern"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      patternType: string
      patternDetails: Prisma.JsonValue | null
      detectedAt: Date
      riskScore: number
      actionTaken: string | null
    }, ExtArgs["result"]["bettingPattern"]>
    composites: {}
  }

  type BettingPatternGetPayload<S extends boolean | null | undefined | BettingPatternDefaultArgs> = $Result.GetResult<Prisma.$BettingPatternPayload, S>

  type BettingPatternCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BettingPatternFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BettingPatternCountAggregateInputType | true
    }

  export interface BettingPatternDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BettingPattern'], meta: { name: 'BettingPattern' } }
    /**
     * Find zero or one BettingPattern that matches the filter.
     * @param {BettingPatternFindUniqueArgs} args - Arguments to find a BettingPattern
     * @example
     * // Get one BettingPattern
     * const bettingPattern = await prisma.bettingPattern.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BettingPatternFindUniqueArgs>(args: SelectSubset<T, BettingPatternFindUniqueArgs<ExtArgs>>): Prisma__BettingPatternClient<$Result.GetResult<Prisma.$BettingPatternPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BettingPattern that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BettingPatternFindUniqueOrThrowArgs} args - Arguments to find a BettingPattern
     * @example
     * // Get one BettingPattern
     * const bettingPattern = await prisma.bettingPattern.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BettingPatternFindUniqueOrThrowArgs>(args: SelectSubset<T, BettingPatternFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BettingPatternClient<$Result.GetResult<Prisma.$BettingPatternPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BettingPattern that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingPatternFindFirstArgs} args - Arguments to find a BettingPattern
     * @example
     * // Get one BettingPattern
     * const bettingPattern = await prisma.bettingPattern.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BettingPatternFindFirstArgs>(args?: SelectSubset<T, BettingPatternFindFirstArgs<ExtArgs>>): Prisma__BettingPatternClient<$Result.GetResult<Prisma.$BettingPatternPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BettingPattern that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingPatternFindFirstOrThrowArgs} args - Arguments to find a BettingPattern
     * @example
     * // Get one BettingPattern
     * const bettingPattern = await prisma.bettingPattern.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BettingPatternFindFirstOrThrowArgs>(args?: SelectSubset<T, BettingPatternFindFirstOrThrowArgs<ExtArgs>>): Prisma__BettingPatternClient<$Result.GetResult<Prisma.$BettingPatternPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BettingPatterns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingPatternFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BettingPatterns
     * const bettingPatterns = await prisma.bettingPattern.findMany()
     * 
     * // Get first 10 BettingPatterns
     * const bettingPatterns = await prisma.bettingPattern.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bettingPatternWithIdOnly = await prisma.bettingPattern.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BettingPatternFindManyArgs>(args?: SelectSubset<T, BettingPatternFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BettingPatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BettingPattern.
     * @param {BettingPatternCreateArgs} args - Arguments to create a BettingPattern.
     * @example
     * // Create one BettingPattern
     * const BettingPattern = await prisma.bettingPattern.create({
     *   data: {
     *     // ... data to create a BettingPattern
     *   }
     * })
     * 
     */
    create<T extends BettingPatternCreateArgs>(args: SelectSubset<T, BettingPatternCreateArgs<ExtArgs>>): Prisma__BettingPatternClient<$Result.GetResult<Prisma.$BettingPatternPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BettingPatterns.
     * @param {BettingPatternCreateManyArgs} args - Arguments to create many BettingPatterns.
     * @example
     * // Create many BettingPatterns
     * const bettingPattern = await prisma.bettingPattern.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BettingPatternCreateManyArgs>(args?: SelectSubset<T, BettingPatternCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BettingPatterns and returns the data saved in the database.
     * @param {BettingPatternCreateManyAndReturnArgs} args - Arguments to create many BettingPatterns.
     * @example
     * // Create many BettingPatterns
     * const bettingPattern = await prisma.bettingPattern.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BettingPatterns and only return the `id`
     * const bettingPatternWithIdOnly = await prisma.bettingPattern.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BettingPatternCreateManyAndReturnArgs>(args?: SelectSubset<T, BettingPatternCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BettingPatternPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BettingPattern.
     * @param {BettingPatternDeleteArgs} args - Arguments to delete one BettingPattern.
     * @example
     * // Delete one BettingPattern
     * const BettingPattern = await prisma.bettingPattern.delete({
     *   where: {
     *     // ... filter to delete one BettingPattern
     *   }
     * })
     * 
     */
    delete<T extends BettingPatternDeleteArgs>(args: SelectSubset<T, BettingPatternDeleteArgs<ExtArgs>>): Prisma__BettingPatternClient<$Result.GetResult<Prisma.$BettingPatternPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BettingPattern.
     * @param {BettingPatternUpdateArgs} args - Arguments to update one BettingPattern.
     * @example
     * // Update one BettingPattern
     * const bettingPattern = await prisma.bettingPattern.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BettingPatternUpdateArgs>(args: SelectSubset<T, BettingPatternUpdateArgs<ExtArgs>>): Prisma__BettingPatternClient<$Result.GetResult<Prisma.$BettingPatternPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BettingPatterns.
     * @param {BettingPatternDeleteManyArgs} args - Arguments to filter BettingPatterns to delete.
     * @example
     * // Delete a few BettingPatterns
     * const { count } = await prisma.bettingPattern.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BettingPatternDeleteManyArgs>(args?: SelectSubset<T, BettingPatternDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BettingPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingPatternUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BettingPatterns
     * const bettingPattern = await prisma.bettingPattern.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BettingPatternUpdateManyArgs>(args: SelectSubset<T, BettingPatternUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BettingPatterns and returns the data updated in the database.
     * @param {BettingPatternUpdateManyAndReturnArgs} args - Arguments to update many BettingPatterns.
     * @example
     * // Update many BettingPatterns
     * const bettingPattern = await prisma.bettingPattern.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BettingPatterns and only return the `id`
     * const bettingPatternWithIdOnly = await prisma.bettingPattern.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BettingPatternUpdateManyAndReturnArgs>(args: SelectSubset<T, BettingPatternUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BettingPatternPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BettingPattern.
     * @param {BettingPatternUpsertArgs} args - Arguments to update or create a BettingPattern.
     * @example
     * // Update or create a BettingPattern
     * const bettingPattern = await prisma.bettingPattern.upsert({
     *   create: {
     *     // ... data to create a BettingPattern
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BettingPattern we want to update
     *   }
     * })
     */
    upsert<T extends BettingPatternUpsertArgs>(args: SelectSubset<T, BettingPatternUpsertArgs<ExtArgs>>): Prisma__BettingPatternClient<$Result.GetResult<Prisma.$BettingPatternPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BettingPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingPatternCountArgs} args - Arguments to filter BettingPatterns to count.
     * @example
     * // Count the number of BettingPatterns
     * const count = await prisma.bettingPattern.count({
     *   where: {
     *     // ... the filter for the BettingPatterns we want to count
     *   }
     * })
    **/
    count<T extends BettingPatternCountArgs>(
      args?: Subset<T, BettingPatternCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BettingPatternCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BettingPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingPatternAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BettingPatternAggregateArgs>(args: Subset<T, BettingPatternAggregateArgs>): Prisma.PrismaPromise<GetBettingPatternAggregateType<T>>

    /**
     * Group by BettingPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BettingPatternGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BettingPatternGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BettingPatternGroupByArgs['orderBy'] }
        : { orderBy?: BettingPatternGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BettingPatternGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBettingPatternGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BettingPattern model
   */
  readonly fields: BettingPatternFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BettingPattern.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BettingPatternClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BettingPattern model
   */
  interface BettingPatternFieldRefs {
    readonly id: FieldRef<"BettingPattern", 'String'>
    readonly userId: FieldRef<"BettingPattern", 'String'>
    readonly patternType: FieldRef<"BettingPattern", 'String'>
    readonly patternDetails: FieldRef<"BettingPattern", 'Json'>
    readonly detectedAt: FieldRef<"BettingPattern", 'DateTime'>
    readonly riskScore: FieldRef<"BettingPattern", 'Int'>
    readonly actionTaken: FieldRef<"BettingPattern", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BettingPattern findUnique
   */
  export type BettingPatternFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPattern
     */
    select?: BettingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPattern
     */
    omit?: BettingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPatternInclude<ExtArgs> | null
    /**
     * Filter, which BettingPattern to fetch.
     */
    where: BettingPatternWhereUniqueInput
  }

  /**
   * BettingPattern findUniqueOrThrow
   */
  export type BettingPatternFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPattern
     */
    select?: BettingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPattern
     */
    omit?: BettingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPatternInclude<ExtArgs> | null
    /**
     * Filter, which BettingPattern to fetch.
     */
    where: BettingPatternWhereUniqueInput
  }

  /**
   * BettingPattern findFirst
   */
  export type BettingPatternFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPattern
     */
    select?: BettingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPattern
     */
    omit?: BettingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPatternInclude<ExtArgs> | null
    /**
     * Filter, which BettingPattern to fetch.
     */
    where?: BettingPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BettingPatterns to fetch.
     */
    orderBy?: BettingPatternOrderByWithRelationInput | BettingPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BettingPatterns.
     */
    cursor?: BettingPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BettingPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BettingPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BettingPatterns.
     */
    distinct?: BettingPatternScalarFieldEnum | BettingPatternScalarFieldEnum[]
  }

  /**
   * BettingPattern findFirstOrThrow
   */
  export type BettingPatternFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPattern
     */
    select?: BettingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPattern
     */
    omit?: BettingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPatternInclude<ExtArgs> | null
    /**
     * Filter, which BettingPattern to fetch.
     */
    where?: BettingPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BettingPatterns to fetch.
     */
    orderBy?: BettingPatternOrderByWithRelationInput | BettingPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BettingPatterns.
     */
    cursor?: BettingPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BettingPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BettingPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BettingPatterns.
     */
    distinct?: BettingPatternScalarFieldEnum | BettingPatternScalarFieldEnum[]
  }

  /**
   * BettingPattern findMany
   */
  export type BettingPatternFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPattern
     */
    select?: BettingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPattern
     */
    omit?: BettingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPatternInclude<ExtArgs> | null
    /**
     * Filter, which BettingPatterns to fetch.
     */
    where?: BettingPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BettingPatterns to fetch.
     */
    orderBy?: BettingPatternOrderByWithRelationInput | BettingPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BettingPatterns.
     */
    cursor?: BettingPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BettingPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BettingPatterns.
     */
    skip?: number
    distinct?: BettingPatternScalarFieldEnum | BettingPatternScalarFieldEnum[]
  }

  /**
   * BettingPattern create
   */
  export type BettingPatternCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPattern
     */
    select?: BettingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPattern
     */
    omit?: BettingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPatternInclude<ExtArgs> | null
    /**
     * The data needed to create a BettingPattern.
     */
    data: XOR<BettingPatternCreateInput, BettingPatternUncheckedCreateInput>
  }

  /**
   * BettingPattern createMany
   */
  export type BettingPatternCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BettingPatterns.
     */
    data: BettingPatternCreateManyInput | BettingPatternCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BettingPattern createManyAndReturn
   */
  export type BettingPatternCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPattern
     */
    select?: BettingPatternSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPattern
     */
    omit?: BettingPatternOmit<ExtArgs> | null
    /**
     * The data used to create many BettingPatterns.
     */
    data: BettingPatternCreateManyInput | BettingPatternCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPatternIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BettingPattern update
   */
  export type BettingPatternUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPattern
     */
    select?: BettingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPattern
     */
    omit?: BettingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPatternInclude<ExtArgs> | null
    /**
     * The data needed to update a BettingPattern.
     */
    data: XOR<BettingPatternUpdateInput, BettingPatternUncheckedUpdateInput>
    /**
     * Choose, which BettingPattern to update.
     */
    where: BettingPatternWhereUniqueInput
  }

  /**
   * BettingPattern updateMany
   */
  export type BettingPatternUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BettingPatterns.
     */
    data: XOR<BettingPatternUpdateManyMutationInput, BettingPatternUncheckedUpdateManyInput>
    /**
     * Filter which BettingPatterns to update
     */
    where?: BettingPatternWhereInput
    /**
     * Limit how many BettingPatterns to update.
     */
    limit?: number
  }

  /**
   * BettingPattern updateManyAndReturn
   */
  export type BettingPatternUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPattern
     */
    select?: BettingPatternSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPattern
     */
    omit?: BettingPatternOmit<ExtArgs> | null
    /**
     * The data used to update BettingPatterns.
     */
    data: XOR<BettingPatternUpdateManyMutationInput, BettingPatternUncheckedUpdateManyInput>
    /**
     * Filter which BettingPatterns to update
     */
    where?: BettingPatternWhereInput
    /**
     * Limit how many BettingPatterns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPatternIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BettingPattern upsert
   */
  export type BettingPatternUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPattern
     */
    select?: BettingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPattern
     */
    omit?: BettingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPatternInclude<ExtArgs> | null
    /**
     * The filter to search for the BettingPattern to update in case it exists.
     */
    where: BettingPatternWhereUniqueInput
    /**
     * In case the BettingPattern found by the `where` argument doesn't exist, create a new BettingPattern with this data.
     */
    create: XOR<BettingPatternCreateInput, BettingPatternUncheckedCreateInput>
    /**
     * In case the BettingPattern was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BettingPatternUpdateInput, BettingPatternUncheckedUpdateInput>
  }

  /**
   * BettingPattern delete
   */
  export type BettingPatternDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPattern
     */
    select?: BettingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPattern
     */
    omit?: BettingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPatternInclude<ExtArgs> | null
    /**
     * Filter which BettingPattern to delete.
     */
    where: BettingPatternWhereUniqueInput
  }

  /**
   * BettingPattern deleteMany
   */
  export type BettingPatternDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BettingPatterns to delete
     */
    where?: BettingPatternWhereInput
    /**
     * Limit how many BettingPatterns to delete.
     */
    limit?: number
  }

  /**
   * BettingPattern without action
   */
  export type BettingPatternDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BettingPattern
     */
    select?: BettingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BettingPattern
     */
    omit?: BettingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BettingPatternInclude<ExtArgs> | null
  }


  /**
   * Model AccountActivityLog
   */

  export type AggregateAccountActivityLog = {
    _count: AccountActivityLogCountAggregateOutputType | null
    _min: AccountActivityLogMinAggregateOutputType | null
    _max: AccountActivityLogMaxAggregateOutputType | null
  }

  export type AccountActivityLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    activityType: string | null
    ipAddressHash: string | null
    deviceFingerprint: string | null
    country: string | null
    region: string | null
    city: string | null
    userAgent: string | null
    success: boolean | null
    createdAt: Date | null
  }

  export type AccountActivityLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    activityType: string | null
    ipAddressHash: string | null
    deviceFingerprint: string | null
    country: string | null
    region: string | null
    city: string | null
    userAgent: string | null
    success: boolean | null
    createdAt: Date | null
  }

  export type AccountActivityLogCountAggregateOutputType = {
    id: number
    userId: number
    activityType: number
    ipAddressHash: number
    deviceFingerprint: number
    country: number
    region: number
    city: number
    userAgent: number
    success: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AccountActivityLogMinAggregateInputType = {
    id?: true
    userId?: true
    activityType?: true
    ipAddressHash?: true
    deviceFingerprint?: true
    country?: true
    region?: true
    city?: true
    userAgent?: true
    success?: true
    createdAt?: true
  }

  export type AccountActivityLogMaxAggregateInputType = {
    id?: true
    userId?: true
    activityType?: true
    ipAddressHash?: true
    deviceFingerprint?: true
    country?: true
    region?: true
    city?: true
    userAgent?: true
    success?: true
    createdAt?: true
  }

  export type AccountActivityLogCountAggregateInputType = {
    id?: true
    userId?: true
    activityType?: true
    ipAddressHash?: true
    deviceFingerprint?: true
    country?: true
    region?: true
    city?: true
    userAgent?: true
    success?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AccountActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountActivityLog to aggregate.
     */
    where?: AccountActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountActivityLogs to fetch.
     */
    orderBy?: AccountActivityLogOrderByWithRelationInput | AccountActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountActivityLogs
    **/
    _count?: true | AccountActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountActivityLogMaxAggregateInputType
  }

  export type GetAccountActivityLogAggregateType<T extends AccountActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountActivityLog[P]>
      : GetScalarType<T[P], AggregateAccountActivityLog[P]>
  }




  export type AccountActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountActivityLogWhereInput
    orderBy?: AccountActivityLogOrderByWithAggregationInput | AccountActivityLogOrderByWithAggregationInput[]
    by: AccountActivityLogScalarFieldEnum[] | AccountActivityLogScalarFieldEnum
    having?: AccountActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountActivityLogCountAggregateInputType | true
    _min?: AccountActivityLogMinAggregateInputType
    _max?: AccountActivityLogMaxAggregateInputType
  }

  export type AccountActivityLogGroupByOutputType = {
    id: string
    userId: string
    activityType: string
    ipAddressHash: string
    deviceFingerprint: string | null
    country: string | null
    region: string | null
    city: string | null
    userAgent: string | null
    success: boolean
    metadata: JsonValue | null
    createdAt: Date
    _count: AccountActivityLogCountAggregateOutputType | null
    _min: AccountActivityLogMinAggregateOutputType | null
    _max: AccountActivityLogMaxAggregateOutputType | null
  }

  type GetAccountActivityLogGroupByPayload<T extends AccountActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], AccountActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type AccountActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    activityType?: boolean
    ipAddressHash?: boolean
    deviceFingerprint?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    userAgent?: boolean
    success?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountActivityLog"]>

  export type AccountActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    activityType?: boolean
    ipAddressHash?: boolean
    deviceFingerprint?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    userAgent?: boolean
    success?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountActivityLog"]>

  export type AccountActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    activityType?: boolean
    ipAddressHash?: boolean
    deviceFingerprint?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    userAgent?: boolean
    success?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountActivityLog"]>

  export type AccountActivityLogSelectScalar = {
    id?: boolean
    userId?: boolean
    activityType?: boolean
    ipAddressHash?: boolean
    deviceFingerprint?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    userAgent?: boolean
    success?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AccountActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "activityType" | "ipAddressHash" | "deviceFingerprint" | "country" | "region" | "city" | "userAgent" | "success" | "metadata" | "createdAt", ExtArgs["result"]["accountActivityLog"]>
  export type AccountActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountActivityLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      activityType: string
      ipAddressHash: string
      deviceFingerprint: string | null
      country: string | null
      region: string | null
      city: string | null
      userAgent: string | null
      success: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["accountActivityLog"]>
    composites: {}
  }

  type AccountActivityLogGetPayload<S extends boolean | null | undefined | AccountActivityLogDefaultArgs> = $Result.GetResult<Prisma.$AccountActivityLogPayload, S>

  type AccountActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountActivityLogCountAggregateInputType | true
    }

  export interface AccountActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountActivityLog'], meta: { name: 'AccountActivityLog' } }
    /**
     * Find zero or one AccountActivityLog that matches the filter.
     * @param {AccountActivityLogFindUniqueArgs} args - Arguments to find a AccountActivityLog
     * @example
     * // Get one AccountActivityLog
     * const accountActivityLog = await prisma.accountActivityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountActivityLogFindUniqueArgs>(args: SelectSubset<T, AccountActivityLogFindUniqueArgs<ExtArgs>>): Prisma__AccountActivityLogClient<$Result.GetResult<Prisma.$AccountActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccountActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountActivityLogFindUniqueOrThrowArgs} args - Arguments to find a AccountActivityLog
     * @example
     * // Get one AccountActivityLog
     * const accountActivityLog = await prisma.accountActivityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountActivityLogClient<$Result.GetResult<Prisma.$AccountActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountActivityLogFindFirstArgs} args - Arguments to find a AccountActivityLog
     * @example
     * // Get one AccountActivityLog
     * const accountActivityLog = await prisma.accountActivityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountActivityLogFindFirstArgs>(args?: SelectSubset<T, AccountActivityLogFindFirstArgs<ExtArgs>>): Prisma__AccountActivityLogClient<$Result.GetResult<Prisma.$AccountActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountActivityLogFindFirstOrThrowArgs} args - Arguments to find a AccountActivityLog
     * @example
     * // Get one AccountActivityLog
     * const accountActivityLog = await prisma.accountActivityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountActivityLogClient<$Result.GetResult<Prisma.$AccountActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccountActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountActivityLogs
     * const accountActivityLogs = await prisma.accountActivityLog.findMany()
     * 
     * // Get first 10 AccountActivityLogs
     * const accountActivityLogs = await prisma.accountActivityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountActivityLogWithIdOnly = await prisma.accountActivityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountActivityLogFindManyArgs>(args?: SelectSubset<T, AccountActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccountActivityLog.
     * @param {AccountActivityLogCreateArgs} args - Arguments to create a AccountActivityLog.
     * @example
     * // Create one AccountActivityLog
     * const AccountActivityLog = await prisma.accountActivityLog.create({
     *   data: {
     *     // ... data to create a AccountActivityLog
     *   }
     * })
     * 
     */
    create<T extends AccountActivityLogCreateArgs>(args: SelectSubset<T, AccountActivityLogCreateArgs<ExtArgs>>): Prisma__AccountActivityLogClient<$Result.GetResult<Prisma.$AccountActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccountActivityLogs.
     * @param {AccountActivityLogCreateManyArgs} args - Arguments to create many AccountActivityLogs.
     * @example
     * // Create many AccountActivityLogs
     * const accountActivityLog = await prisma.accountActivityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountActivityLogCreateManyArgs>(args?: SelectSubset<T, AccountActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccountActivityLogs and returns the data saved in the database.
     * @param {AccountActivityLogCreateManyAndReturnArgs} args - Arguments to create many AccountActivityLogs.
     * @example
     * // Create many AccountActivityLogs
     * const accountActivityLog = await prisma.accountActivityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccountActivityLogs and only return the `id`
     * const accountActivityLogWithIdOnly = await prisma.accountActivityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AccountActivityLog.
     * @param {AccountActivityLogDeleteArgs} args - Arguments to delete one AccountActivityLog.
     * @example
     * // Delete one AccountActivityLog
     * const AccountActivityLog = await prisma.accountActivityLog.delete({
     *   where: {
     *     // ... filter to delete one AccountActivityLog
     *   }
     * })
     * 
     */
    delete<T extends AccountActivityLogDeleteArgs>(args: SelectSubset<T, AccountActivityLogDeleteArgs<ExtArgs>>): Prisma__AccountActivityLogClient<$Result.GetResult<Prisma.$AccountActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccountActivityLog.
     * @param {AccountActivityLogUpdateArgs} args - Arguments to update one AccountActivityLog.
     * @example
     * // Update one AccountActivityLog
     * const accountActivityLog = await prisma.accountActivityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountActivityLogUpdateArgs>(args: SelectSubset<T, AccountActivityLogUpdateArgs<ExtArgs>>): Prisma__AccountActivityLogClient<$Result.GetResult<Prisma.$AccountActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccountActivityLogs.
     * @param {AccountActivityLogDeleteManyArgs} args - Arguments to filter AccountActivityLogs to delete.
     * @example
     * // Delete a few AccountActivityLogs
     * const { count } = await prisma.accountActivityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountActivityLogDeleteManyArgs>(args?: SelectSubset<T, AccountActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountActivityLogs
     * const accountActivityLog = await prisma.accountActivityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountActivityLogUpdateManyArgs>(args: SelectSubset<T, AccountActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountActivityLogs and returns the data updated in the database.
     * @param {AccountActivityLogUpdateManyAndReturnArgs} args - Arguments to update many AccountActivityLogs.
     * @example
     * // Update many AccountActivityLogs
     * const accountActivityLog = await prisma.accountActivityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AccountActivityLogs and only return the `id`
     * const accountActivityLogWithIdOnly = await prisma.accountActivityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AccountActivityLog.
     * @param {AccountActivityLogUpsertArgs} args - Arguments to update or create a AccountActivityLog.
     * @example
     * // Update or create a AccountActivityLog
     * const accountActivityLog = await prisma.accountActivityLog.upsert({
     *   create: {
     *     // ... data to create a AccountActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends AccountActivityLogUpsertArgs>(args: SelectSubset<T, AccountActivityLogUpsertArgs<ExtArgs>>): Prisma__AccountActivityLogClient<$Result.GetResult<Prisma.$AccountActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccountActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountActivityLogCountArgs} args - Arguments to filter AccountActivityLogs to count.
     * @example
     * // Count the number of AccountActivityLogs
     * const count = await prisma.accountActivityLog.count({
     *   where: {
     *     // ... the filter for the AccountActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends AccountActivityLogCountArgs>(
      args?: Subset<T, AccountActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountActivityLogAggregateArgs>(args: Subset<T, AccountActivityLogAggregateArgs>): Prisma.PrismaPromise<GetAccountActivityLogAggregateType<T>>

    /**
     * Group by AccountActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: AccountActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountActivityLog model
   */
  readonly fields: AccountActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountActivityLog model
   */
  interface AccountActivityLogFieldRefs {
    readonly id: FieldRef<"AccountActivityLog", 'String'>
    readonly userId: FieldRef<"AccountActivityLog", 'String'>
    readonly activityType: FieldRef<"AccountActivityLog", 'String'>
    readonly ipAddressHash: FieldRef<"AccountActivityLog", 'String'>
    readonly deviceFingerprint: FieldRef<"AccountActivityLog", 'String'>
    readonly country: FieldRef<"AccountActivityLog", 'String'>
    readonly region: FieldRef<"AccountActivityLog", 'String'>
    readonly city: FieldRef<"AccountActivityLog", 'String'>
    readonly userAgent: FieldRef<"AccountActivityLog", 'String'>
    readonly success: FieldRef<"AccountActivityLog", 'Boolean'>
    readonly metadata: FieldRef<"AccountActivityLog", 'Json'>
    readonly createdAt: FieldRef<"AccountActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccountActivityLog findUnique
   */
  export type AccountActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountActivityLog
     */
    select?: AccountActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountActivityLog
     */
    omit?: AccountActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which AccountActivityLog to fetch.
     */
    where: AccountActivityLogWhereUniqueInput
  }

  /**
   * AccountActivityLog findUniqueOrThrow
   */
  export type AccountActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountActivityLog
     */
    select?: AccountActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountActivityLog
     */
    omit?: AccountActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which AccountActivityLog to fetch.
     */
    where: AccountActivityLogWhereUniqueInput
  }

  /**
   * AccountActivityLog findFirst
   */
  export type AccountActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountActivityLog
     */
    select?: AccountActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountActivityLog
     */
    omit?: AccountActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which AccountActivityLog to fetch.
     */
    where?: AccountActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountActivityLogs to fetch.
     */
    orderBy?: AccountActivityLogOrderByWithRelationInput | AccountActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountActivityLogs.
     */
    cursor?: AccountActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountActivityLogs.
     */
    distinct?: AccountActivityLogScalarFieldEnum | AccountActivityLogScalarFieldEnum[]
  }

  /**
   * AccountActivityLog findFirstOrThrow
   */
  export type AccountActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountActivityLog
     */
    select?: AccountActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountActivityLog
     */
    omit?: AccountActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which AccountActivityLog to fetch.
     */
    where?: AccountActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountActivityLogs to fetch.
     */
    orderBy?: AccountActivityLogOrderByWithRelationInput | AccountActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountActivityLogs.
     */
    cursor?: AccountActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountActivityLogs.
     */
    distinct?: AccountActivityLogScalarFieldEnum | AccountActivityLogScalarFieldEnum[]
  }

  /**
   * AccountActivityLog findMany
   */
  export type AccountActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountActivityLog
     */
    select?: AccountActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountActivityLog
     */
    omit?: AccountActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which AccountActivityLogs to fetch.
     */
    where?: AccountActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountActivityLogs to fetch.
     */
    orderBy?: AccountActivityLogOrderByWithRelationInput | AccountActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountActivityLogs.
     */
    cursor?: AccountActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountActivityLogs.
     */
    skip?: number
    distinct?: AccountActivityLogScalarFieldEnum | AccountActivityLogScalarFieldEnum[]
  }

  /**
   * AccountActivityLog create
   */
  export type AccountActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountActivityLog
     */
    select?: AccountActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountActivityLog
     */
    omit?: AccountActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountActivityLog.
     */
    data: XOR<AccountActivityLogCreateInput, AccountActivityLogUncheckedCreateInput>
  }

  /**
   * AccountActivityLog createMany
   */
  export type AccountActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountActivityLogs.
     */
    data: AccountActivityLogCreateManyInput | AccountActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountActivityLog createManyAndReturn
   */
  export type AccountActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountActivityLog
     */
    select?: AccountActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccountActivityLog
     */
    omit?: AccountActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many AccountActivityLogs.
     */
    data: AccountActivityLogCreateManyInput | AccountActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccountActivityLog update
   */
  export type AccountActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountActivityLog
     */
    select?: AccountActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountActivityLog
     */
    omit?: AccountActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountActivityLog.
     */
    data: XOR<AccountActivityLogUpdateInput, AccountActivityLogUncheckedUpdateInput>
    /**
     * Choose, which AccountActivityLog to update.
     */
    where: AccountActivityLogWhereUniqueInput
  }

  /**
   * AccountActivityLog updateMany
   */
  export type AccountActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountActivityLogs.
     */
    data: XOR<AccountActivityLogUpdateManyMutationInput, AccountActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which AccountActivityLogs to update
     */
    where?: AccountActivityLogWhereInput
    /**
     * Limit how many AccountActivityLogs to update.
     */
    limit?: number
  }

  /**
   * AccountActivityLog updateManyAndReturn
   */
  export type AccountActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountActivityLog
     */
    select?: AccountActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccountActivityLog
     */
    omit?: AccountActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update AccountActivityLogs.
     */
    data: XOR<AccountActivityLogUpdateManyMutationInput, AccountActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which AccountActivityLogs to update
     */
    where?: AccountActivityLogWhereInput
    /**
     * Limit how many AccountActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccountActivityLog upsert
   */
  export type AccountActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountActivityLog
     */
    select?: AccountActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountActivityLog
     */
    omit?: AccountActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountActivityLog to update in case it exists.
     */
    where: AccountActivityLogWhereUniqueInput
    /**
     * In case the AccountActivityLog found by the `where` argument doesn't exist, create a new AccountActivityLog with this data.
     */
    create: XOR<AccountActivityLogCreateInput, AccountActivityLogUncheckedCreateInput>
    /**
     * In case the AccountActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountActivityLogUpdateInput, AccountActivityLogUncheckedUpdateInput>
  }

  /**
   * AccountActivityLog delete
   */
  export type AccountActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountActivityLog
     */
    select?: AccountActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountActivityLog
     */
    omit?: AccountActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountActivityLogInclude<ExtArgs> | null
    /**
     * Filter which AccountActivityLog to delete.
     */
    where: AccountActivityLogWhereUniqueInput
  }

  /**
   * AccountActivityLog deleteMany
   */
  export type AccountActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountActivityLogs to delete
     */
    where?: AccountActivityLogWhereInput
    /**
     * Limit how many AccountActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * AccountActivityLog without action
   */
  export type AccountActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountActivityLog
     */
    select?: AccountActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountActivityLog
     */
    omit?: AccountActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model DeviceRegistry
   */

  export type AggregateDeviceRegistry = {
    _count: DeviceRegistryCountAggregateOutputType | null
    _min: DeviceRegistryMinAggregateOutputType | null
    _max: DeviceRegistryMaxAggregateOutputType | null
  }

  export type DeviceRegistryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceFingerprint: string | null
    deviceName: string | null
    deviceType: string | null
    os: string | null
    browser: string | null
    trusted: boolean | null
    blocked: boolean | null
    firstSeenAt: Date | null
    lastSeenAt: Date | null
  }

  export type DeviceRegistryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceFingerprint: string | null
    deviceName: string | null
    deviceType: string | null
    os: string | null
    browser: string | null
    trusted: boolean | null
    blocked: boolean | null
    firstSeenAt: Date | null
    lastSeenAt: Date | null
  }

  export type DeviceRegistryCountAggregateOutputType = {
    id: number
    userId: number
    deviceFingerprint: number
    deviceName: number
    deviceType: number
    os: number
    browser: number
    trusted: number
    blocked: number
    firstSeenAt: number
    lastSeenAt: number
    _all: number
  }


  export type DeviceRegistryMinAggregateInputType = {
    id?: true
    userId?: true
    deviceFingerprint?: true
    deviceName?: true
    deviceType?: true
    os?: true
    browser?: true
    trusted?: true
    blocked?: true
    firstSeenAt?: true
    lastSeenAt?: true
  }

  export type DeviceRegistryMaxAggregateInputType = {
    id?: true
    userId?: true
    deviceFingerprint?: true
    deviceName?: true
    deviceType?: true
    os?: true
    browser?: true
    trusted?: true
    blocked?: true
    firstSeenAt?: true
    lastSeenAt?: true
  }

  export type DeviceRegistryCountAggregateInputType = {
    id?: true
    userId?: true
    deviceFingerprint?: true
    deviceName?: true
    deviceType?: true
    os?: true
    browser?: true
    trusted?: true
    blocked?: true
    firstSeenAt?: true
    lastSeenAt?: true
    _all?: true
  }

  export type DeviceRegistryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceRegistry to aggregate.
     */
    where?: DeviceRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceRegistries to fetch.
     */
    orderBy?: DeviceRegistryOrderByWithRelationInput | DeviceRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceRegistries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceRegistries
    **/
    _count?: true | DeviceRegistryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceRegistryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceRegistryMaxAggregateInputType
  }

  export type GetDeviceRegistryAggregateType<T extends DeviceRegistryAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceRegistry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceRegistry[P]>
      : GetScalarType<T[P], AggregateDeviceRegistry[P]>
  }




  export type DeviceRegistryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceRegistryWhereInput
    orderBy?: DeviceRegistryOrderByWithAggregationInput | DeviceRegistryOrderByWithAggregationInput[]
    by: DeviceRegistryScalarFieldEnum[] | DeviceRegistryScalarFieldEnum
    having?: DeviceRegistryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceRegistryCountAggregateInputType | true
    _min?: DeviceRegistryMinAggregateInputType
    _max?: DeviceRegistryMaxAggregateInputType
  }

  export type DeviceRegistryGroupByOutputType = {
    id: string
    userId: string
    deviceFingerprint: string
    deviceName: string | null
    deviceType: string | null
    os: string | null
    browser: string | null
    trusted: boolean
    blocked: boolean
    firstSeenAt: Date
    lastSeenAt: Date
    _count: DeviceRegistryCountAggregateOutputType | null
    _min: DeviceRegistryMinAggregateOutputType | null
    _max: DeviceRegistryMaxAggregateOutputType | null
  }

  type GetDeviceRegistryGroupByPayload<T extends DeviceRegistryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceRegistryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceRegistryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceRegistryGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceRegistryGroupByOutputType[P]>
        }
      >
    >


  export type DeviceRegistrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceFingerprint?: boolean
    deviceName?: boolean
    deviceType?: boolean
    os?: boolean
    browser?: boolean
    trusted?: boolean
    blocked?: boolean
    firstSeenAt?: boolean
    lastSeenAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceRegistry"]>

  export type DeviceRegistrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceFingerprint?: boolean
    deviceName?: boolean
    deviceType?: boolean
    os?: boolean
    browser?: boolean
    trusted?: boolean
    blocked?: boolean
    firstSeenAt?: boolean
    lastSeenAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceRegistry"]>

  export type DeviceRegistrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceFingerprint?: boolean
    deviceName?: boolean
    deviceType?: boolean
    os?: boolean
    browser?: boolean
    trusted?: boolean
    blocked?: boolean
    firstSeenAt?: boolean
    lastSeenAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceRegistry"]>

  export type DeviceRegistrySelectScalar = {
    id?: boolean
    userId?: boolean
    deviceFingerprint?: boolean
    deviceName?: boolean
    deviceType?: boolean
    os?: boolean
    browser?: boolean
    trusted?: boolean
    blocked?: boolean
    firstSeenAt?: boolean
    lastSeenAt?: boolean
  }

  export type DeviceRegistryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "deviceFingerprint" | "deviceName" | "deviceType" | "os" | "browser" | "trusted" | "blocked" | "firstSeenAt" | "lastSeenAt", ExtArgs["result"]["deviceRegistry"]>
  export type DeviceRegistryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeviceRegistryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeviceRegistryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeviceRegistryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceRegistry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      deviceFingerprint: string
      deviceName: string | null
      deviceType: string | null
      os: string | null
      browser: string | null
      trusted: boolean
      blocked: boolean
      firstSeenAt: Date
      lastSeenAt: Date
    }, ExtArgs["result"]["deviceRegistry"]>
    composites: {}
  }

  type DeviceRegistryGetPayload<S extends boolean | null | undefined | DeviceRegistryDefaultArgs> = $Result.GetResult<Prisma.$DeviceRegistryPayload, S>

  type DeviceRegistryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceRegistryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceRegistryCountAggregateInputType | true
    }

  export interface DeviceRegistryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceRegistry'], meta: { name: 'DeviceRegistry' } }
    /**
     * Find zero or one DeviceRegistry that matches the filter.
     * @param {DeviceRegistryFindUniqueArgs} args - Arguments to find a DeviceRegistry
     * @example
     * // Get one DeviceRegistry
     * const deviceRegistry = await prisma.deviceRegistry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceRegistryFindUniqueArgs>(args: SelectSubset<T, DeviceRegistryFindUniqueArgs<ExtArgs>>): Prisma__DeviceRegistryClient<$Result.GetResult<Prisma.$DeviceRegistryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceRegistry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceRegistryFindUniqueOrThrowArgs} args - Arguments to find a DeviceRegistry
     * @example
     * // Get one DeviceRegistry
     * const deviceRegistry = await prisma.deviceRegistry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceRegistryFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceRegistryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceRegistryClient<$Result.GetResult<Prisma.$DeviceRegistryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceRegistry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceRegistryFindFirstArgs} args - Arguments to find a DeviceRegistry
     * @example
     * // Get one DeviceRegistry
     * const deviceRegistry = await prisma.deviceRegistry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceRegistryFindFirstArgs>(args?: SelectSubset<T, DeviceRegistryFindFirstArgs<ExtArgs>>): Prisma__DeviceRegistryClient<$Result.GetResult<Prisma.$DeviceRegistryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceRegistry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceRegistryFindFirstOrThrowArgs} args - Arguments to find a DeviceRegistry
     * @example
     * // Get one DeviceRegistry
     * const deviceRegistry = await prisma.deviceRegistry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceRegistryFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceRegistryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceRegistryClient<$Result.GetResult<Prisma.$DeviceRegistryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceRegistries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceRegistryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceRegistries
     * const deviceRegistries = await prisma.deviceRegistry.findMany()
     * 
     * // Get first 10 DeviceRegistries
     * const deviceRegistries = await prisma.deviceRegistry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceRegistryWithIdOnly = await prisma.deviceRegistry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceRegistryFindManyArgs>(args?: SelectSubset<T, DeviceRegistryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceRegistryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceRegistry.
     * @param {DeviceRegistryCreateArgs} args - Arguments to create a DeviceRegistry.
     * @example
     * // Create one DeviceRegistry
     * const DeviceRegistry = await prisma.deviceRegistry.create({
     *   data: {
     *     // ... data to create a DeviceRegistry
     *   }
     * })
     * 
     */
    create<T extends DeviceRegistryCreateArgs>(args: SelectSubset<T, DeviceRegistryCreateArgs<ExtArgs>>): Prisma__DeviceRegistryClient<$Result.GetResult<Prisma.$DeviceRegistryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceRegistries.
     * @param {DeviceRegistryCreateManyArgs} args - Arguments to create many DeviceRegistries.
     * @example
     * // Create many DeviceRegistries
     * const deviceRegistry = await prisma.deviceRegistry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceRegistryCreateManyArgs>(args?: SelectSubset<T, DeviceRegistryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceRegistries and returns the data saved in the database.
     * @param {DeviceRegistryCreateManyAndReturnArgs} args - Arguments to create many DeviceRegistries.
     * @example
     * // Create many DeviceRegistries
     * const deviceRegistry = await prisma.deviceRegistry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceRegistries and only return the `id`
     * const deviceRegistryWithIdOnly = await prisma.deviceRegistry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceRegistryCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceRegistryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceRegistryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceRegistry.
     * @param {DeviceRegistryDeleteArgs} args - Arguments to delete one DeviceRegistry.
     * @example
     * // Delete one DeviceRegistry
     * const DeviceRegistry = await prisma.deviceRegistry.delete({
     *   where: {
     *     // ... filter to delete one DeviceRegistry
     *   }
     * })
     * 
     */
    delete<T extends DeviceRegistryDeleteArgs>(args: SelectSubset<T, DeviceRegistryDeleteArgs<ExtArgs>>): Prisma__DeviceRegistryClient<$Result.GetResult<Prisma.$DeviceRegistryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceRegistry.
     * @param {DeviceRegistryUpdateArgs} args - Arguments to update one DeviceRegistry.
     * @example
     * // Update one DeviceRegistry
     * const deviceRegistry = await prisma.deviceRegistry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceRegistryUpdateArgs>(args: SelectSubset<T, DeviceRegistryUpdateArgs<ExtArgs>>): Prisma__DeviceRegistryClient<$Result.GetResult<Prisma.$DeviceRegistryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceRegistries.
     * @param {DeviceRegistryDeleteManyArgs} args - Arguments to filter DeviceRegistries to delete.
     * @example
     * // Delete a few DeviceRegistries
     * const { count } = await prisma.deviceRegistry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceRegistryDeleteManyArgs>(args?: SelectSubset<T, DeviceRegistryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceRegistries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceRegistryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceRegistries
     * const deviceRegistry = await prisma.deviceRegistry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceRegistryUpdateManyArgs>(args: SelectSubset<T, DeviceRegistryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceRegistries and returns the data updated in the database.
     * @param {DeviceRegistryUpdateManyAndReturnArgs} args - Arguments to update many DeviceRegistries.
     * @example
     * // Update many DeviceRegistries
     * const deviceRegistry = await prisma.deviceRegistry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceRegistries and only return the `id`
     * const deviceRegistryWithIdOnly = await prisma.deviceRegistry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceRegistryUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceRegistryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceRegistryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceRegistry.
     * @param {DeviceRegistryUpsertArgs} args - Arguments to update or create a DeviceRegistry.
     * @example
     * // Update or create a DeviceRegistry
     * const deviceRegistry = await prisma.deviceRegistry.upsert({
     *   create: {
     *     // ... data to create a DeviceRegistry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceRegistry we want to update
     *   }
     * })
     */
    upsert<T extends DeviceRegistryUpsertArgs>(args: SelectSubset<T, DeviceRegistryUpsertArgs<ExtArgs>>): Prisma__DeviceRegistryClient<$Result.GetResult<Prisma.$DeviceRegistryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceRegistries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceRegistryCountArgs} args - Arguments to filter DeviceRegistries to count.
     * @example
     * // Count the number of DeviceRegistries
     * const count = await prisma.deviceRegistry.count({
     *   where: {
     *     // ... the filter for the DeviceRegistries we want to count
     *   }
     * })
    **/
    count<T extends DeviceRegistryCountArgs>(
      args?: Subset<T, DeviceRegistryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceRegistryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceRegistry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceRegistryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceRegistryAggregateArgs>(args: Subset<T, DeviceRegistryAggregateArgs>): Prisma.PrismaPromise<GetDeviceRegistryAggregateType<T>>

    /**
     * Group by DeviceRegistry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceRegistryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceRegistryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceRegistryGroupByArgs['orderBy'] }
        : { orderBy?: DeviceRegistryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceRegistryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceRegistryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceRegistry model
   */
  readonly fields: DeviceRegistryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceRegistry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceRegistryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceRegistry model
   */
  interface DeviceRegistryFieldRefs {
    readonly id: FieldRef<"DeviceRegistry", 'String'>
    readonly userId: FieldRef<"DeviceRegistry", 'String'>
    readonly deviceFingerprint: FieldRef<"DeviceRegistry", 'String'>
    readonly deviceName: FieldRef<"DeviceRegistry", 'String'>
    readonly deviceType: FieldRef<"DeviceRegistry", 'String'>
    readonly os: FieldRef<"DeviceRegistry", 'String'>
    readonly browser: FieldRef<"DeviceRegistry", 'String'>
    readonly trusted: FieldRef<"DeviceRegistry", 'Boolean'>
    readonly blocked: FieldRef<"DeviceRegistry", 'Boolean'>
    readonly firstSeenAt: FieldRef<"DeviceRegistry", 'DateTime'>
    readonly lastSeenAt: FieldRef<"DeviceRegistry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeviceRegistry findUnique
   */
  export type DeviceRegistryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRegistry
     */
    select?: DeviceRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRegistry
     */
    omit?: DeviceRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRegistryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceRegistry to fetch.
     */
    where: DeviceRegistryWhereUniqueInput
  }

  /**
   * DeviceRegistry findUniqueOrThrow
   */
  export type DeviceRegistryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRegistry
     */
    select?: DeviceRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRegistry
     */
    omit?: DeviceRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRegistryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceRegistry to fetch.
     */
    where: DeviceRegistryWhereUniqueInput
  }

  /**
   * DeviceRegistry findFirst
   */
  export type DeviceRegistryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRegistry
     */
    select?: DeviceRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRegistry
     */
    omit?: DeviceRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRegistryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceRegistry to fetch.
     */
    where?: DeviceRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceRegistries to fetch.
     */
    orderBy?: DeviceRegistryOrderByWithRelationInput | DeviceRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceRegistries.
     */
    cursor?: DeviceRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceRegistries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceRegistries.
     */
    distinct?: DeviceRegistryScalarFieldEnum | DeviceRegistryScalarFieldEnum[]
  }

  /**
   * DeviceRegistry findFirstOrThrow
   */
  export type DeviceRegistryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRegistry
     */
    select?: DeviceRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRegistry
     */
    omit?: DeviceRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRegistryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceRegistry to fetch.
     */
    where?: DeviceRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceRegistries to fetch.
     */
    orderBy?: DeviceRegistryOrderByWithRelationInput | DeviceRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceRegistries.
     */
    cursor?: DeviceRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceRegistries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceRegistries.
     */
    distinct?: DeviceRegistryScalarFieldEnum | DeviceRegistryScalarFieldEnum[]
  }

  /**
   * DeviceRegistry findMany
   */
  export type DeviceRegistryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRegistry
     */
    select?: DeviceRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRegistry
     */
    omit?: DeviceRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRegistryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceRegistries to fetch.
     */
    where?: DeviceRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceRegistries to fetch.
     */
    orderBy?: DeviceRegistryOrderByWithRelationInput | DeviceRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceRegistries.
     */
    cursor?: DeviceRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceRegistries.
     */
    skip?: number
    distinct?: DeviceRegistryScalarFieldEnum | DeviceRegistryScalarFieldEnum[]
  }

  /**
   * DeviceRegistry create
   */
  export type DeviceRegistryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRegistry
     */
    select?: DeviceRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRegistry
     */
    omit?: DeviceRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRegistryInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceRegistry.
     */
    data: XOR<DeviceRegistryCreateInput, DeviceRegistryUncheckedCreateInput>
  }

  /**
   * DeviceRegistry createMany
   */
  export type DeviceRegistryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceRegistries.
     */
    data: DeviceRegistryCreateManyInput | DeviceRegistryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceRegistry createManyAndReturn
   */
  export type DeviceRegistryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRegistry
     */
    select?: DeviceRegistrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRegistry
     */
    omit?: DeviceRegistryOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceRegistries.
     */
    data: DeviceRegistryCreateManyInput | DeviceRegistryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRegistryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceRegistry update
   */
  export type DeviceRegistryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRegistry
     */
    select?: DeviceRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRegistry
     */
    omit?: DeviceRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRegistryInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceRegistry.
     */
    data: XOR<DeviceRegistryUpdateInput, DeviceRegistryUncheckedUpdateInput>
    /**
     * Choose, which DeviceRegistry to update.
     */
    where: DeviceRegistryWhereUniqueInput
  }

  /**
   * DeviceRegistry updateMany
   */
  export type DeviceRegistryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceRegistries.
     */
    data: XOR<DeviceRegistryUpdateManyMutationInput, DeviceRegistryUncheckedUpdateManyInput>
    /**
     * Filter which DeviceRegistries to update
     */
    where?: DeviceRegistryWhereInput
    /**
     * Limit how many DeviceRegistries to update.
     */
    limit?: number
  }

  /**
   * DeviceRegistry updateManyAndReturn
   */
  export type DeviceRegistryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRegistry
     */
    select?: DeviceRegistrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRegistry
     */
    omit?: DeviceRegistryOmit<ExtArgs> | null
    /**
     * The data used to update DeviceRegistries.
     */
    data: XOR<DeviceRegistryUpdateManyMutationInput, DeviceRegistryUncheckedUpdateManyInput>
    /**
     * Filter which DeviceRegistries to update
     */
    where?: DeviceRegistryWhereInput
    /**
     * Limit how many DeviceRegistries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRegistryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceRegistry upsert
   */
  export type DeviceRegistryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRegistry
     */
    select?: DeviceRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRegistry
     */
    omit?: DeviceRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRegistryInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceRegistry to update in case it exists.
     */
    where: DeviceRegistryWhereUniqueInput
    /**
     * In case the DeviceRegistry found by the `where` argument doesn't exist, create a new DeviceRegistry with this data.
     */
    create: XOR<DeviceRegistryCreateInput, DeviceRegistryUncheckedCreateInput>
    /**
     * In case the DeviceRegistry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceRegistryUpdateInput, DeviceRegistryUncheckedUpdateInput>
  }

  /**
   * DeviceRegistry delete
   */
  export type DeviceRegistryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRegistry
     */
    select?: DeviceRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRegistry
     */
    omit?: DeviceRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRegistryInclude<ExtArgs> | null
    /**
     * Filter which DeviceRegistry to delete.
     */
    where: DeviceRegistryWhereUniqueInput
  }

  /**
   * DeviceRegistry deleteMany
   */
  export type DeviceRegistryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceRegistries to delete
     */
    where?: DeviceRegistryWhereInput
    /**
     * Limit how many DeviceRegistries to delete.
     */
    limit?: number
  }

  /**
   * DeviceRegistry without action
   */
  export type DeviceRegistryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRegistry
     */
    select?: DeviceRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRegistry
     */
    omit?: DeviceRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRegistryInclude<ExtArgs> | null
  }


  /**
   * Model IpAddress
   */

  export type AggregateIpAddress = {
    _count: IpAddressCountAggregateOutputType | null
    _avg: IpAddressAvgAggregateOutputType | null
    _sum: IpAddressSumAggregateOutputType | null
    _min: IpAddressMinAggregateOutputType | null
    _max: IpAddressMaxAggregateOutputType | null
  }

  export type IpAddressAvgAggregateOutputType = {
    riskScore: number | null
  }

  export type IpAddressSumAggregateOutputType = {
    riskScore: number | null
  }

  export type IpAddressMinAggregateOutputType = {
    id: string | null
    ipAddressHash: string | null
    country: string | null
    region: string | null
    city: string | null
    isp: string | null
    isVpn: boolean | null
    isProxy: boolean | null
    riskScore: number | null
    blocked: boolean | null
    firstSeenAt: Date | null
    lastSeenAt: Date | null
  }

  export type IpAddressMaxAggregateOutputType = {
    id: string | null
    ipAddressHash: string | null
    country: string | null
    region: string | null
    city: string | null
    isp: string | null
    isVpn: boolean | null
    isProxy: boolean | null
    riskScore: number | null
    blocked: boolean | null
    firstSeenAt: Date | null
    lastSeenAt: Date | null
  }

  export type IpAddressCountAggregateOutputType = {
    id: number
    ipAddressHash: number
    country: number
    region: number
    city: number
    isp: number
    isVpn: number
    isProxy: number
    riskScore: number
    blocked: number
    firstSeenAt: number
    lastSeenAt: number
    _all: number
  }


  export type IpAddressAvgAggregateInputType = {
    riskScore?: true
  }

  export type IpAddressSumAggregateInputType = {
    riskScore?: true
  }

  export type IpAddressMinAggregateInputType = {
    id?: true
    ipAddressHash?: true
    country?: true
    region?: true
    city?: true
    isp?: true
    isVpn?: true
    isProxy?: true
    riskScore?: true
    blocked?: true
    firstSeenAt?: true
    lastSeenAt?: true
  }

  export type IpAddressMaxAggregateInputType = {
    id?: true
    ipAddressHash?: true
    country?: true
    region?: true
    city?: true
    isp?: true
    isVpn?: true
    isProxy?: true
    riskScore?: true
    blocked?: true
    firstSeenAt?: true
    lastSeenAt?: true
  }

  export type IpAddressCountAggregateInputType = {
    id?: true
    ipAddressHash?: true
    country?: true
    region?: true
    city?: true
    isp?: true
    isVpn?: true
    isProxy?: true
    riskScore?: true
    blocked?: true
    firstSeenAt?: true
    lastSeenAt?: true
    _all?: true
  }

  export type IpAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IpAddress to aggregate.
     */
    where?: IpAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IpAddresses to fetch.
     */
    orderBy?: IpAddressOrderByWithRelationInput | IpAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IpAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IpAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IpAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IpAddresses
    **/
    _count?: true | IpAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IpAddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IpAddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IpAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IpAddressMaxAggregateInputType
  }

  export type GetIpAddressAggregateType<T extends IpAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateIpAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIpAddress[P]>
      : GetScalarType<T[P], AggregateIpAddress[P]>
  }




  export type IpAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IpAddressWhereInput
    orderBy?: IpAddressOrderByWithAggregationInput | IpAddressOrderByWithAggregationInput[]
    by: IpAddressScalarFieldEnum[] | IpAddressScalarFieldEnum
    having?: IpAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IpAddressCountAggregateInputType | true
    _avg?: IpAddressAvgAggregateInputType
    _sum?: IpAddressSumAggregateInputType
    _min?: IpAddressMinAggregateInputType
    _max?: IpAddressMaxAggregateInputType
  }

  export type IpAddressGroupByOutputType = {
    id: string
    ipAddressHash: string
    country: string | null
    region: string | null
    city: string | null
    isp: string | null
    isVpn: boolean
    isProxy: boolean
    riskScore: number
    blocked: boolean
    firstSeenAt: Date
    lastSeenAt: Date
    _count: IpAddressCountAggregateOutputType | null
    _avg: IpAddressAvgAggregateOutputType | null
    _sum: IpAddressSumAggregateOutputType | null
    _min: IpAddressMinAggregateOutputType | null
    _max: IpAddressMaxAggregateOutputType | null
  }

  type GetIpAddressGroupByPayload<T extends IpAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IpAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IpAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IpAddressGroupByOutputType[P]>
            : GetScalarType<T[P], IpAddressGroupByOutputType[P]>
        }
      >
    >


  export type IpAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ipAddressHash?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    isp?: boolean
    isVpn?: boolean
    isProxy?: boolean
    riskScore?: boolean
    blocked?: boolean
    firstSeenAt?: boolean
    lastSeenAt?: boolean
  }, ExtArgs["result"]["ipAddress"]>

  export type IpAddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ipAddressHash?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    isp?: boolean
    isVpn?: boolean
    isProxy?: boolean
    riskScore?: boolean
    blocked?: boolean
    firstSeenAt?: boolean
    lastSeenAt?: boolean
  }, ExtArgs["result"]["ipAddress"]>

  export type IpAddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ipAddressHash?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    isp?: boolean
    isVpn?: boolean
    isProxy?: boolean
    riskScore?: boolean
    blocked?: boolean
    firstSeenAt?: boolean
    lastSeenAt?: boolean
  }, ExtArgs["result"]["ipAddress"]>

  export type IpAddressSelectScalar = {
    id?: boolean
    ipAddressHash?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    isp?: boolean
    isVpn?: boolean
    isProxy?: boolean
    riskScore?: boolean
    blocked?: boolean
    firstSeenAt?: boolean
    lastSeenAt?: boolean
  }

  export type IpAddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ipAddressHash" | "country" | "region" | "city" | "isp" | "isVpn" | "isProxy" | "riskScore" | "blocked" | "firstSeenAt" | "lastSeenAt", ExtArgs["result"]["ipAddress"]>

  export type $IpAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IpAddress"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ipAddressHash: string
      country: string | null
      region: string | null
      city: string | null
      isp: string | null
      isVpn: boolean
      isProxy: boolean
      riskScore: number
      blocked: boolean
      firstSeenAt: Date
      lastSeenAt: Date
    }, ExtArgs["result"]["ipAddress"]>
    composites: {}
  }

  type IpAddressGetPayload<S extends boolean | null | undefined | IpAddressDefaultArgs> = $Result.GetResult<Prisma.$IpAddressPayload, S>

  type IpAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IpAddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IpAddressCountAggregateInputType | true
    }

  export interface IpAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IpAddress'], meta: { name: 'IpAddress' } }
    /**
     * Find zero or one IpAddress that matches the filter.
     * @param {IpAddressFindUniqueArgs} args - Arguments to find a IpAddress
     * @example
     * // Get one IpAddress
     * const ipAddress = await prisma.ipAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IpAddressFindUniqueArgs>(args: SelectSubset<T, IpAddressFindUniqueArgs<ExtArgs>>): Prisma__IpAddressClient<$Result.GetResult<Prisma.$IpAddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IpAddress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IpAddressFindUniqueOrThrowArgs} args - Arguments to find a IpAddress
     * @example
     * // Get one IpAddress
     * const ipAddress = await prisma.ipAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IpAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, IpAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IpAddressClient<$Result.GetResult<Prisma.$IpAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IpAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpAddressFindFirstArgs} args - Arguments to find a IpAddress
     * @example
     * // Get one IpAddress
     * const ipAddress = await prisma.ipAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IpAddressFindFirstArgs>(args?: SelectSubset<T, IpAddressFindFirstArgs<ExtArgs>>): Prisma__IpAddressClient<$Result.GetResult<Prisma.$IpAddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IpAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpAddressFindFirstOrThrowArgs} args - Arguments to find a IpAddress
     * @example
     * // Get one IpAddress
     * const ipAddress = await prisma.ipAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IpAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, IpAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__IpAddressClient<$Result.GetResult<Prisma.$IpAddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IpAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IpAddresses
     * const ipAddresses = await prisma.ipAddress.findMany()
     * 
     * // Get first 10 IpAddresses
     * const ipAddresses = await prisma.ipAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ipAddressWithIdOnly = await prisma.ipAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IpAddressFindManyArgs>(args?: SelectSubset<T, IpAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IpAddress.
     * @param {IpAddressCreateArgs} args - Arguments to create a IpAddress.
     * @example
     * // Create one IpAddress
     * const IpAddress = await prisma.ipAddress.create({
     *   data: {
     *     // ... data to create a IpAddress
     *   }
     * })
     * 
     */
    create<T extends IpAddressCreateArgs>(args: SelectSubset<T, IpAddressCreateArgs<ExtArgs>>): Prisma__IpAddressClient<$Result.GetResult<Prisma.$IpAddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IpAddresses.
     * @param {IpAddressCreateManyArgs} args - Arguments to create many IpAddresses.
     * @example
     * // Create many IpAddresses
     * const ipAddress = await prisma.ipAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IpAddressCreateManyArgs>(args?: SelectSubset<T, IpAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IpAddresses and returns the data saved in the database.
     * @param {IpAddressCreateManyAndReturnArgs} args - Arguments to create many IpAddresses.
     * @example
     * // Create many IpAddresses
     * const ipAddress = await prisma.ipAddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IpAddresses and only return the `id`
     * const ipAddressWithIdOnly = await prisma.ipAddress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IpAddressCreateManyAndReturnArgs>(args?: SelectSubset<T, IpAddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpAddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IpAddress.
     * @param {IpAddressDeleteArgs} args - Arguments to delete one IpAddress.
     * @example
     * // Delete one IpAddress
     * const IpAddress = await prisma.ipAddress.delete({
     *   where: {
     *     // ... filter to delete one IpAddress
     *   }
     * })
     * 
     */
    delete<T extends IpAddressDeleteArgs>(args: SelectSubset<T, IpAddressDeleteArgs<ExtArgs>>): Prisma__IpAddressClient<$Result.GetResult<Prisma.$IpAddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IpAddress.
     * @param {IpAddressUpdateArgs} args - Arguments to update one IpAddress.
     * @example
     * // Update one IpAddress
     * const ipAddress = await prisma.ipAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IpAddressUpdateArgs>(args: SelectSubset<T, IpAddressUpdateArgs<ExtArgs>>): Prisma__IpAddressClient<$Result.GetResult<Prisma.$IpAddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IpAddresses.
     * @param {IpAddressDeleteManyArgs} args - Arguments to filter IpAddresses to delete.
     * @example
     * // Delete a few IpAddresses
     * const { count } = await prisma.ipAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IpAddressDeleteManyArgs>(args?: SelectSubset<T, IpAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IpAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IpAddresses
     * const ipAddress = await prisma.ipAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IpAddressUpdateManyArgs>(args: SelectSubset<T, IpAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IpAddresses and returns the data updated in the database.
     * @param {IpAddressUpdateManyAndReturnArgs} args - Arguments to update many IpAddresses.
     * @example
     * // Update many IpAddresses
     * const ipAddress = await prisma.ipAddress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IpAddresses and only return the `id`
     * const ipAddressWithIdOnly = await prisma.ipAddress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IpAddressUpdateManyAndReturnArgs>(args: SelectSubset<T, IpAddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpAddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IpAddress.
     * @param {IpAddressUpsertArgs} args - Arguments to update or create a IpAddress.
     * @example
     * // Update or create a IpAddress
     * const ipAddress = await prisma.ipAddress.upsert({
     *   create: {
     *     // ... data to create a IpAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IpAddress we want to update
     *   }
     * })
     */
    upsert<T extends IpAddressUpsertArgs>(args: SelectSubset<T, IpAddressUpsertArgs<ExtArgs>>): Prisma__IpAddressClient<$Result.GetResult<Prisma.$IpAddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IpAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpAddressCountArgs} args - Arguments to filter IpAddresses to count.
     * @example
     * // Count the number of IpAddresses
     * const count = await prisma.ipAddress.count({
     *   where: {
     *     // ... the filter for the IpAddresses we want to count
     *   }
     * })
    **/
    count<T extends IpAddressCountArgs>(
      args?: Subset<T, IpAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IpAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IpAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IpAddressAggregateArgs>(args: Subset<T, IpAddressAggregateArgs>): Prisma.PrismaPromise<GetIpAddressAggregateType<T>>

    /**
     * Group by IpAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IpAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IpAddressGroupByArgs['orderBy'] }
        : { orderBy?: IpAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IpAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIpAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IpAddress model
   */
  readonly fields: IpAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IpAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IpAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IpAddress model
   */
  interface IpAddressFieldRefs {
    readonly id: FieldRef<"IpAddress", 'String'>
    readonly ipAddressHash: FieldRef<"IpAddress", 'String'>
    readonly country: FieldRef<"IpAddress", 'String'>
    readonly region: FieldRef<"IpAddress", 'String'>
    readonly city: FieldRef<"IpAddress", 'String'>
    readonly isp: FieldRef<"IpAddress", 'String'>
    readonly isVpn: FieldRef<"IpAddress", 'Boolean'>
    readonly isProxy: FieldRef<"IpAddress", 'Boolean'>
    readonly riskScore: FieldRef<"IpAddress", 'Int'>
    readonly blocked: FieldRef<"IpAddress", 'Boolean'>
    readonly firstSeenAt: FieldRef<"IpAddress", 'DateTime'>
    readonly lastSeenAt: FieldRef<"IpAddress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IpAddress findUnique
   */
  export type IpAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpAddress
     */
    select?: IpAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpAddress
     */
    omit?: IpAddressOmit<ExtArgs> | null
    /**
     * Filter, which IpAddress to fetch.
     */
    where: IpAddressWhereUniqueInput
  }

  /**
   * IpAddress findUniqueOrThrow
   */
  export type IpAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpAddress
     */
    select?: IpAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpAddress
     */
    omit?: IpAddressOmit<ExtArgs> | null
    /**
     * Filter, which IpAddress to fetch.
     */
    where: IpAddressWhereUniqueInput
  }

  /**
   * IpAddress findFirst
   */
  export type IpAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpAddress
     */
    select?: IpAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpAddress
     */
    omit?: IpAddressOmit<ExtArgs> | null
    /**
     * Filter, which IpAddress to fetch.
     */
    where?: IpAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IpAddresses to fetch.
     */
    orderBy?: IpAddressOrderByWithRelationInput | IpAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IpAddresses.
     */
    cursor?: IpAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IpAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IpAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IpAddresses.
     */
    distinct?: IpAddressScalarFieldEnum | IpAddressScalarFieldEnum[]
  }

  /**
   * IpAddress findFirstOrThrow
   */
  export type IpAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpAddress
     */
    select?: IpAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpAddress
     */
    omit?: IpAddressOmit<ExtArgs> | null
    /**
     * Filter, which IpAddress to fetch.
     */
    where?: IpAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IpAddresses to fetch.
     */
    orderBy?: IpAddressOrderByWithRelationInput | IpAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IpAddresses.
     */
    cursor?: IpAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IpAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IpAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IpAddresses.
     */
    distinct?: IpAddressScalarFieldEnum | IpAddressScalarFieldEnum[]
  }

  /**
   * IpAddress findMany
   */
  export type IpAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpAddress
     */
    select?: IpAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpAddress
     */
    omit?: IpAddressOmit<ExtArgs> | null
    /**
     * Filter, which IpAddresses to fetch.
     */
    where?: IpAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IpAddresses to fetch.
     */
    orderBy?: IpAddressOrderByWithRelationInput | IpAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IpAddresses.
     */
    cursor?: IpAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IpAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IpAddresses.
     */
    skip?: number
    distinct?: IpAddressScalarFieldEnum | IpAddressScalarFieldEnum[]
  }

  /**
   * IpAddress create
   */
  export type IpAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpAddress
     */
    select?: IpAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpAddress
     */
    omit?: IpAddressOmit<ExtArgs> | null
    /**
     * The data needed to create a IpAddress.
     */
    data: XOR<IpAddressCreateInput, IpAddressUncheckedCreateInput>
  }

  /**
   * IpAddress createMany
   */
  export type IpAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IpAddresses.
     */
    data: IpAddressCreateManyInput | IpAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IpAddress createManyAndReturn
   */
  export type IpAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpAddress
     */
    select?: IpAddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IpAddress
     */
    omit?: IpAddressOmit<ExtArgs> | null
    /**
     * The data used to create many IpAddresses.
     */
    data: IpAddressCreateManyInput | IpAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IpAddress update
   */
  export type IpAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpAddress
     */
    select?: IpAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpAddress
     */
    omit?: IpAddressOmit<ExtArgs> | null
    /**
     * The data needed to update a IpAddress.
     */
    data: XOR<IpAddressUpdateInput, IpAddressUncheckedUpdateInput>
    /**
     * Choose, which IpAddress to update.
     */
    where: IpAddressWhereUniqueInput
  }

  /**
   * IpAddress updateMany
   */
  export type IpAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IpAddresses.
     */
    data: XOR<IpAddressUpdateManyMutationInput, IpAddressUncheckedUpdateManyInput>
    /**
     * Filter which IpAddresses to update
     */
    where?: IpAddressWhereInput
    /**
     * Limit how many IpAddresses to update.
     */
    limit?: number
  }

  /**
   * IpAddress updateManyAndReturn
   */
  export type IpAddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpAddress
     */
    select?: IpAddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IpAddress
     */
    omit?: IpAddressOmit<ExtArgs> | null
    /**
     * The data used to update IpAddresses.
     */
    data: XOR<IpAddressUpdateManyMutationInput, IpAddressUncheckedUpdateManyInput>
    /**
     * Filter which IpAddresses to update
     */
    where?: IpAddressWhereInput
    /**
     * Limit how many IpAddresses to update.
     */
    limit?: number
  }

  /**
   * IpAddress upsert
   */
  export type IpAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpAddress
     */
    select?: IpAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpAddress
     */
    omit?: IpAddressOmit<ExtArgs> | null
    /**
     * The filter to search for the IpAddress to update in case it exists.
     */
    where: IpAddressWhereUniqueInput
    /**
     * In case the IpAddress found by the `where` argument doesn't exist, create a new IpAddress with this data.
     */
    create: XOR<IpAddressCreateInput, IpAddressUncheckedCreateInput>
    /**
     * In case the IpAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IpAddressUpdateInput, IpAddressUncheckedUpdateInput>
  }

  /**
   * IpAddress delete
   */
  export type IpAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpAddress
     */
    select?: IpAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpAddress
     */
    omit?: IpAddressOmit<ExtArgs> | null
    /**
     * Filter which IpAddress to delete.
     */
    where: IpAddressWhereUniqueInput
  }

  /**
   * IpAddress deleteMany
   */
  export type IpAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IpAddresses to delete
     */
    where?: IpAddressWhereInput
    /**
     * Limit how many IpAddresses to delete.
     */
    limit?: number
  }

  /**
   * IpAddress without action
   */
  export type IpAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpAddress
     */
    select?: IpAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpAddress
     */
    omit?: IpAddressOmit<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    action: string | null
    userId: string | null
    ipAddressHash: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    action: string | null
    userId: string | null
    ipAddressHash: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    action: number
    userId: number
    ipAddressHash: number
    changes: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    userId?: true
    ipAddressHash?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    userId?: true
    ipAddressHash?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    userId?: true
    ipAddressHash?: true
    changes?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    entityType: string
    entityId: string
    action: string
    userId: string | null
    ipAddressHash: string | null
    changes: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    userId?: boolean
    ipAddressHash?: boolean
    changes?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    userId?: boolean
    ipAddressHash?: boolean
    changes?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    userId?: boolean
    ipAddressHash?: boolean
    changes?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    userId?: boolean
    ipAddressHash?: boolean
    changes?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityType" | "entityId" | "action" | "userId" | "ipAddressHash" | "changes" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: string
      entityId: string
      action: string
      userId: string | null
      ipAddressHash: string | null
      changes: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly ipAddressHash: FieldRef<"AuditLog", 'String'>
    readonly changes: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model GdprConsent
   */

  export type AggregateGdprConsent = {
    _count: GdprConsentCountAggregateOutputType | null
    _min: GdprConsentMinAggregateOutputType | null
    _max: GdprConsentMaxAggregateOutputType | null
  }

  export type GdprConsentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    consentType: string | null
    consentStatus: string | null
    consentMethod: string | null
    ipAddressHash: string | null
    withdrawnAt: Date | null
    createdAt: Date | null
  }

  export type GdprConsentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    consentType: string | null
    consentStatus: string | null
    consentMethod: string | null
    ipAddressHash: string | null
    withdrawnAt: Date | null
    createdAt: Date | null
  }

  export type GdprConsentCountAggregateOutputType = {
    id: number
    userId: number
    consentType: number
    consentStatus: number
    consentMethod: number
    ipAddressHash: number
    withdrawnAt: number
    createdAt: number
    _all: number
  }


  export type GdprConsentMinAggregateInputType = {
    id?: true
    userId?: true
    consentType?: true
    consentStatus?: true
    consentMethod?: true
    ipAddressHash?: true
    withdrawnAt?: true
    createdAt?: true
  }

  export type GdprConsentMaxAggregateInputType = {
    id?: true
    userId?: true
    consentType?: true
    consentStatus?: true
    consentMethod?: true
    ipAddressHash?: true
    withdrawnAt?: true
    createdAt?: true
  }

  export type GdprConsentCountAggregateInputType = {
    id?: true
    userId?: true
    consentType?: true
    consentStatus?: true
    consentMethod?: true
    ipAddressHash?: true
    withdrawnAt?: true
    createdAt?: true
    _all?: true
  }

  export type GdprConsentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GdprConsent to aggregate.
     */
    where?: GdprConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GdprConsents to fetch.
     */
    orderBy?: GdprConsentOrderByWithRelationInput | GdprConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GdprConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GdprConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GdprConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GdprConsents
    **/
    _count?: true | GdprConsentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GdprConsentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GdprConsentMaxAggregateInputType
  }

  export type GetGdprConsentAggregateType<T extends GdprConsentAggregateArgs> = {
        [P in keyof T & keyof AggregateGdprConsent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGdprConsent[P]>
      : GetScalarType<T[P], AggregateGdprConsent[P]>
  }




  export type GdprConsentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GdprConsentWhereInput
    orderBy?: GdprConsentOrderByWithAggregationInput | GdprConsentOrderByWithAggregationInput[]
    by: GdprConsentScalarFieldEnum[] | GdprConsentScalarFieldEnum
    having?: GdprConsentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GdprConsentCountAggregateInputType | true
    _min?: GdprConsentMinAggregateInputType
    _max?: GdprConsentMaxAggregateInputType
  }

  export type GdprConsentGroupByOutputType = {
    id: string
    userId: string
    consentType: string
    consentStatus: string
    consentMethod: string
    ipAddressHash: string | null
    withdrawnAt: Date | null
    createdAt: Date
    _count: GdprConsentCountAggregateOutputType | null
    _min: GdprConsentMinAggregateOutputType | null
    _max: GdprConsentMaxAggregateOutputType | null
  }

  type GetGdprConsentGroupByPayload<T extends GdprConsentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GdprConsentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GdprConsentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GdprConsentGroupByOutputType[P]>
            : GetScalarType<T[P], GdprConsentGroupByOutputType[P]>
        }
      >
    >


  export type GdprConsentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    consentType?: boolean
    consentStatus?: boolean
    consentMethod?: boolean
    ipAddressHash?: boolean
    withdrawnAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gdprConsent"]>

  export type GdprConsentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    consentType?: boolean
    consentStatus?: boolean
    consentMethod?: boolean
    ipAddressHash?: boolean
    withdrawnAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gdprConsent"]>

  export type GdprConsentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    consentType?: boolean
    consentStatus?: boolean
    consentMethod?: boolean
    ipAddressHash?: boolean
    withdrawnAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gdprConsent"]>

  export type GdprConsentSelectScalar = {
    id?: boolean
    userId?: boolean
    consentType?: boolean
    consentStatus?: boolean
    consentMethod?: boolean
    ipAddressHash?: boolean
    withdrawnAt?: boolean
    createdAt?: boolean
  }

  export type GdprConsentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "consentType" | "consentStatus" | "consentMethod" | "ipAddressHash" | "withdrawnAt" | "createdAt", ExtArgs["result"]["gdprConsent"]>
  export type GdprConsentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GdprConsentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GdprConsentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GdprConsentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GdprConsent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      consentType: string
      consentStatus: string
      consentMethod: string
      ipAddressHash: string | null
      withdrawnAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["gdprConsent"]>
    composites: {}
  }

  type GdprConsentGetPayload<S extends boolean | null | undefined | GdprConsentDefaultArgs> = $Result.GetResult<Prisma.$GdprConsentPayload, S>

  type GdprConsentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GdprConsentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GdprConsentCountAggregateInputType | true
    }

  export interface GdprConsentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GdprConsent'], meta: { name: 'GdprConsent' } }
    /**
     * Find zero or one GdprConsent that matches the filter.
     * @param {GdprConsentFindUniqueArgs} args - Arguments to find a GdprConsent
     * @example
     * // Get one GdprConsent
     * const gdprConsent = await prisma.gdprConsent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GdprConsentFindUniqueArgs>(args: SelectSubset<T, GdprConsentFindUniqueArgs<ExtArgs>>): Prisma__GdprConsentClient<$Result.GetResult<Prisma.$GdprConsentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GdprConsent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GdprConsentFindUniqueOrThrowArgs} args - Arguments to find a GdprConsent
     * @example
     * // Get one GdprConsent
     * const gdprConsent = await prisma.gdprConsent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GdprConsentFindUniqueOrThrowArgs>(args: SelectSubset<T, GdprConsentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GdprConsentClient<$Result.GetResult<Prisma.$GdprConsentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GdprConsent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GdprConsentFindFirstArgs} args - Arguments to find a GdprConsent
     * @example
     * // Get one GdprConsent
     * const gdprConsent = await prisma.gdprConsent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GdprConsentFindFirstArgs>(args?: SelectSubset<T, GdprConsentFindFirstArgs<ExtArgs>>): Prisma__GdprConsentClient<$Result.GetResult<Prisma.$GdprConsentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GdprConsent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GdprConsentFindFirstOrThrowArgs} args - Arguments to find a GdprConsent
     * @example
     * // Get one GdprConsent
     * const gdprConsent = await prisma.gdprConsent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GdprConsentFindFirstOrThrowArgs>(args?: SelectSubset<T, GdprConsentFindFirstOrThrowArgs<ExtArgs>>): Prisma__GdprConsentClient<$Result.GetResult<Prisma.$GdprConsentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GdprConsents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GdprConsentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GdprConsents
     * const gdprConsents = await prisma.gdprConsent.findMany()
     * 
     * // Get first 10 GdprConsents
     * const gdprConsents = await prisma.gdprConsent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gdprConsentWithIdOnly = await prisma.gdprConsent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GdprConsentFindManyArgs>(args?: SelectSubset<T, GdprConsentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GdprConsentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GdprConsent.
     * @param {GdprConsentCreateArgs} args - Arguments to create a GdprConsent.
     * @example
     * // Create one GdprConsent
     * const GdprConsent = await prisma.gdprConsent.create({
     *   data: {
     *     // ... data to create a GdprConsent
     *   }
     * })
     * 
     */
    create<T extends GdprConsentCreateArgs>(args: SelectSubset<T, GdprConsentCreateArgs<ExtArgs>>): Prisma__GdprConsentClient<$Result.GetResult<Prisma.$GdprConsentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GdprConsents.
     * @param {GdprConsentCreateManyArgs} args - Arguments to create many GdprConsents.
     * @example
     * // Create many GdprConsents
     * const gdprConsent = await prisma.gdprConsent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GdprConsentCreateManyArgs>(args?: SelectSubset<T, GdprConsentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GdprConsents and returns the data saved in the database.
     * @param {GdprConsentCreateManyAndReturnArgs} args - Arguments to create many GdprConsents.
     * @example
     * // Create many GdprConsents
     * const gdprConsent = await prisma.gdprConsent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GdprConsents and only return the `id`
     * const gdprConsentWithIdOnly = await prisma.gdprConsent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GdprConsentCreateManyAndReturnArgs>(args?: SelectSubset<T, GdprConsentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GdprConsentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GdprConsent.
     * @param {GdprConsentDeleteArgs} args - Arguments to delete one GdprConsent.
     * @example
     * // Delete one GdprConsent
     * const GdprConsent = await prisma.gdprConsent.delete({
     *   where: {
     *     // ... filter to delete one GdprConsent
     *   }
     * })
     * 
     */
    delete<T extends GdprConsentDeleteArgs>(args: SelectSubset<T, GdprConsentDeleteArgs<ExtArgs>>): Prisma__GdprConsentClient<$Result.GetResult<Prisma.$GdprConsentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GdprConsent.
     * @param {GdprConsentUpdateArgs} args - Arguments to update one GdprConsent.
     * @example
     * // Update one GdprConsent
     * const gdprConsent = await prisma.gdprConsent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GdprConsentUpdateArgs>(args: SelectSubset<T, GdprConsentUpdateArgs<ExtArgs>>): Prisma__GdprConsentClient<$Result.GetResult<Prisma.$GdprConsentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GdprConsents.
     * @param {GdprConsentDeleteManyArgs} args - Arguments to filter GdprConsents to delete.
     * @example
     * // Delete a few GdprConsents
     * const { count } = await prisma.gdprConsent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GdprConsentDeleteManyArgs>(args?: SelectSubset<T, GdprConsentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GdprConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GdprConsentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GdprConsents
     * const gdprConsent = await prisma.gdprConsent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GdprConsentUpdateManyArgs>(args: SelectSubset<T, GdprConsentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GdprConsents and returns the data updated in the database.
     * @param {GdprConsentUpdateManyAndReturnArgs} args - Arguments to update many GdprConsents.
     * @example
     * // Update many GdprConsents
     * const gdprConsent = await prisma.gdprConsent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GdprConsents and only return the `id`
     * const gdprConsentWithIdOnly = await prisma.gdprConsent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GdprConsentUpdateManyAndReturnArgs>(args: SelectSubset<T, GdprConsentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GdprConsentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GdprConsent.
     * @param {GdprConsentUpsertArgs} args - Arguments to update or create a GdprConsent.
     * @example
     * // Update or create a GdprConsent
     * const gdprConsent = await prisma.gdprConsent.upsert({
     *   create: {
     *     // ... data to create a GdprConsent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GdprConsent we want to update
     *   }
     * })
     */
    upsert<T extends GdprConsentUpsertArgs>(args: SelectSubset<T, GdprConsentUpsertArgs<ExtArgs>>): Prisma__GdprConsentClient<$Result.GetResult<Prisma.$GdprConsentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GdprConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GdprConsentCountArgs} args - Arguments to filter GdprConsents to count.
     * @example
     * // Count the number of GdprConsents
     * const count = await prisma.gdprConsent.count({
     *   where: {
     *     // ... the filter for the GdprConsents we want to count
     *   }
     * })
    **/
    count<T extends GdprConsentCountArgs>(
      args?: Subset<T, GdprConsentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GdprConsentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GdprConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GdprConsentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GdprConsentAggregateArgs>(args: Subset<T, GdprConsentAggregateArgs>): Prisma.PrismaPromise<GetGdprConsentAggregateType<T>>

    /**
     * Group by GdprConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GdprConsentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GdprConsentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GdprConsentGroupByArgs['orderBy'] }
        : { orderBy?: GdprConsentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GdprConsentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGdprConsentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GdprConsent model
   */
  readonly fields: GdprConsentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GdprConsent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GdprConsentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GdprConsent model
   */
  interface GdprConsentFieldRefs {
    readonly id: FieldRef<"GdprConsent", 'String'>
    readonly userId: FieldRef<"GdprConsent", 'String'>
    readonly consentType: FieldRef<"GdprConsent", 'String'>
    readonly consentStatus: FieldRef<"GdprConsent", 'String'>
    readonly consentMethod: FieldRef<"GdprConsent", 'String'>
    readonly ipAddressHash: FieldRef<"GdprConsent", 'String'>
    readonly withdrawnAt: FieldRef<"GdprConsent", 'DateTime'>
    readonly createdAt: FieldRef<"GdprConsent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GdprConsent findUnique
   */
  export type GdprConsentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GdprConsent
     */
    select?: GdprConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GdprConsent
     */
    omit?: GdprConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GdprConsentInclude<ExtArgs> | null
    /**
     * Filter, which GdprConsent to fetch.
     */
    where: GdprConsentWhereUniqueInput
  }

  /**
   * GdprConsent findUniqueOrThrow
   */
  export type GdprConsentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GdprConsent
     */
    select?: GdprConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GdprConsent
     */
    omit?: GdprConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GdprConsentInclude<ExtArgs> | null
    /**
     * Filter, which GdprConsent to fetch.
     */
    where: GdprConsentWhereUniqueInput
  }

  /**
   * GdprConsent findFirst
   */
  export type GdprConsentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GdprConsent
     */
    select?: GdprConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GdprConsent
     */
    omit?: GdprConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GdprConsentInclude<ExtArgs> | null
    /**
     * Filter, which GdprConsent to fetch.
     */
    where?: GdprConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GdprConsents to fetch.
     */
    orderBy?: GdprConsentOrderByWithRelationInput | GdprConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GdprConsents.
     */
    cursor?: GdprConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GdprConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GdprConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GdprConsents.
     */
    distinct?: GdprConsentScalarFieldEnum | GdprConsentScalarFieldEnum[]
  }

  /**
   * GdprConsent findFirstOrThrow
   */
  export type GdprConsentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GdprConsent
     */
    select?: GdprConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GdprConsent
     */
    omit?: GdprConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GdprConsentInclude<ExtArgs> | null
    /**
     * Filter, which GdprConsent to fetch.
     */
    where?: GdprConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GdprConsents to fetch.
     */
    orderBy?: GdprConsentOrderByWithRelationInput | GdprConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GdprConsents.
     */
    cursor?: GdprConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GdprConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GdprConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GdprConsents.
     */
    distinct?: GdprConsentScalarFieldEnum | GdprConsentScalarFieldEnum[]
  }

  /**
   * GdprConsent findMany
   */
  export type GdprConsentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GdprConsent
     */
    select?: GdprConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GdprConsent
     */
    omit?: GdprConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GdprConsentInclude<ExtArgs> | null
    /**
     * Filter, which GdprConsents to fetch.
     */
    where?: GdprConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GdprConsents to fetch.
     */
    orderBy?: GdprConsentOrderByWithRelationInput | GdprConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GdprConsents.
     */
    cursor?: GdprConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GdprConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GdprConsents.
     */
    skip?: number
    distinct?: GdprConsentScalarFieldEnum | GdprConsentScalarFieldEnum[]
  }

  /**
   * GdprConsent create
   */
  export type GdprConsentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GdprConsent
     */
    select?: GdprConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GdprConsent
     */
    omit?: GdprConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GdprConsentInclude<ExtArgs> | null
    /**
     * The data needed to create a GdprConsent.
     */
    data: XOR<GdprConsentCreateInput, GdprConsentUncheckedCreateInput>
  }

  /**
   * GdprConsent createMany
   */
  export type GdprConsentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GdprConsents.
     */
    data: GdprConsentCreateManyInput | GdprConsentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GdprConsent createManyAndReturn
   */
  export type GdprConsentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GdprConsent
     */
    select?: GdprConsentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GdprConsent
     */
    omit?: GdprConsentOmit<ExtArgs> | null
    /**
     * The data used to create many GdprConsents.
     */
    data: GdprConsentCreateManyInput | GdprConsentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GdprConsentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GdprConsent update
   */
  export type GdprConsentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GdprConsent
     */
    select?: GdprConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GdprConsent
     */
    omit?: GdprConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GdprConsentInclude<ExtArgs> | null
    /**
     * The data needed to update a GdprConsent.
     */
    data: XOR<GdprConsentUpdateInput, GdprConsentUncheckedUpdateInput>
    /**
     * Choose, which GdprConsent to update.
     */
    where: GdprConsentWhereUniqueInput
  }

  /**
   * GdprConsent updateMany
   */
  export type GdprConsentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GdprConsents.
     */
    data: XOR<GdprConsentUpdateManyMutationInput, GdprConsentUncheckedUpdateManyInput>
    /**
     * Filter which GdprConsents to update
     */
    where?: GdprConsentWhereInput
    /**
     * Limit how many GdprConsents to update.
     */
    limit?: number
  }

  /**
   * GdprConsent updateManyAndReturn
   */
  export type GdprConsentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GdprConsent
     */
    select?: GdprConsentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GdprConsent
     */
    omit?: GdprConsentOmit<ExtArgs> | null
    /**
     * The data used to update GdprConsents.
     */
    data: XOR<GdprConsentUpdateManyMutationInput, GdprConsentUncheckedUpdateManyInput>
    /**
     * Filter which GdprConsents to update
     */
    where?: GdprConsentWhereInput
    /**
     * Limit how many GdprConsents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GdprConsentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GdprConsent upsert
   */
  export type GdprConsentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GdprConsent
     */
    select?: GdprConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GdprConsent
     */
    omit?: GdprConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GdprConsentInclude<ExtArgs> | null
    /**
     * The filter to search for the GdprConsent to update in case it exists.
     */
    where: GdprConsentWhereUniqueInput
    /**
     * In case the GdprConsent found by the `where` argument doesn't exist, create a new GdprConsent with this data.
     */
    create: XOR<GdprConsentCreateInput, GdprConsentUncheckedCreateInput>
    /**
     * In case the GdprConsent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GdprConsentUpdateInput, GdprConsentUncheckedUpdateInput>
  }

  /**
   * GdprConsent delete
   */
  export type GdprConsentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GdprConsent
     */
    select?: GdprConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GdprConsent
     */
    omit?: GdprConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GdprConsentInclude<ExtArgs> | null
    /**
     * Filter which GdprConsent to delete.
     */
    where: GdprConsentWhereUniqueInput
  }

  /**
   * GdprConsent deleteMany
   */
  export type GdprConsentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GdprConsents to delete
     */
    where?: GdprConsentWhereInput
    /**
     * Limit how many GdprConsents to delete.
     */
    limit?: number
  }

  /**
   * GdprConsent without action
   */
  export type GdprConsentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GdprConsent
     */
    select?: GdprConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GdprConsent
     */
    omit?: GdprConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GdprConsentInclude<ExtArgs> | null
  }


  /**
   * Model DataDeletionRequest
   */

  export type AggregateDataDeletionRequest = {
    _count: DataDeletionRequestCountAggregateOutputType | null
    _min: DataDeletionRequestMinAggregateOutputType | null
    _max: DataDeletionRequestMaxAggregateOutputType | null
  }

  export type DataDeletionRequestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: string | null
    requestedAt: Date | null
    processedAt: Date | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataDeletionRequestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: string | null
    requestedAt: Date | null
    processedAt: Date | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataDeletionRequestCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    requestedAt: number
    processedAt: number
    rejectionReason: number
    dataDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DataDeletionRequestMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    requestedAt?: true
    processedAt?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataDeletionRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    requestedAt?: true
    processedAt?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataDeletionRequestCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    requestedAt?: true
    processedAt?: true
    rejectionReason?: true
    dataDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DataDeletionRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataDeletionRequest to aggregate.
     */
    where?: DataDeletionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataDeletionRequests to fetch.
     */
    orderBy?: DataDeletionRequestOrderByWithRelationInput | DataDeletionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataDeletionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataDeletionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataDeletionRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataDeletionRequests
    **/
    _count?: true | DataDeletionRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataDeletionRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataDeletionRequestMaxAggregateInputType
  }

  export type GetDataDeletionRequestAggregateType<T extends DataDeletionRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateDataDeletionRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataDeletionRequest[P]>
      : GetScalarType<T[P], AggregateDataDeletionRequest[P]>
  }




  export type DataDeletionRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataDeletionRequestWhereInput
    orderBy?: DataDeletionRequestOrderByWithAggregationInput | DataDeletionRequestOrderByWithAggregationInput[]
    by: DataDeletionRequestScalarFieldEnum[] | DataDeletionRequestScalarFieldEnum
    having?: DataDeletionRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataDeletionRequestCountAggregateInputType | true
    _min?: DataDeletionRequestMinAggregateInputType
    _max?: DataDeletionRequestMaxAggregateInputType
  }

  export type DataDeletionRequestGroupByOutputType = {
    id: string
    userId: string
    status: string
    requestedAt: Date
    processedAt: Date | null
    rejectionReason: string | null
    dataDeleted: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: DataDeletionRequestCountAggregateOutputType | null
    _min: DataDeletionRequestMinAggregateOutputType | null
    _max: DataDeletionRequestMaxAggregateOutputType | null
  }

  type GetDataDeletionRequestGroupByPayload<T extends DataDeletionRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataDeletionRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataDeletionRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataDeletionRequestGroupByOutputType[P]>
            : GetScalarType<T[P], DataDeletionRequestGroupByOutputType[P]>
        }
      >
    >


  export type DataDeletionRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    requestedAt?: boolean
    processedAt?: boolean
    rejectionReason?: boolean
    dataDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataDeletionRequest"]>

  export type DataDeletionRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    requestedAt?: boolean
    processedAt?: boolean
    rejectionReason?: boolean
    dataDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataDeletionRequest"]>

  export type DataDeletionRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    requestedAt?: boolean
    processedAt?: boolean
    rejectionReason?: boolean
    dataDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataDeletionRequest"]>

  export type DataDeletionRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    requestedAt?: boolean
    processedAt?: boolean
    rejectionReason?: boolean
    dataDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DataDeletionRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "status" | "requestedAt" | "processedAt" | "rejectionReason" | "dataDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["dataDeletionRequest"]>
  export type DataDeletionRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DataDeletionRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DataDeletionRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DataDeletionRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataDeletionRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: string
      requestedAt: Date
      processedAt: Date | null
      rejectionReason: string | null
      dataDeleted: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dataDeletionRequest"]>
    composites: {}
  }

  type DataDeletionRequestGetPayload<S extends boolean | null | undefined | DataDeletionRequestDefaultArgs> = $Result.GetResult<Prisma.$DataDeletionRequestPayload, S>

  type DataDeletionRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataDeletionRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataDeletionRequestCountAggregateInputType | true
    }

  export interface DataDeletionRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataDeletionRequest'], meta: { name: 'DataDeletionRequest' } }
    /**
     * Find zero or one DataDeletionRequest that matches the filter.
     * @param {DataDeletionRequestFindUniqueArgs} args - Arguments to find a DataDeletionRequest
     * @example
     * // Get one DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataDeletionRequestFindUniqueArgs>(args: SelectSubset<T, DataDeletionRequestFindUniqueArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DataDeletionRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataDeletionRequestFindUniqueOrThrowArgs} args - Arguments to find a DataDeletionRequest
     * @example
     * // Get one DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataDeletionRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, DataDeletionRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataDeletionRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestFindFirstArgs} args - Arguments to find a DataDeletionRequest
     * @example
     * // Get one DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataDeletionRequestFindFirstArgs>(args?: SelectSubset<T, DataDeletionRequestFindFirstArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataDeletionRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestFindFirstOrThrowArgs} args - Arguments to find a DataDeletionRequest
     * @example
     * // Get one DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataDeletionRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, DataDeletionRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DataDeletionRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataDeletionRequests
     * const dataDeletionRequests = await prisma.dataDeletionRequest.findMany()
     * 
     * // Get first 10 DataDeletionRequests
     * const dataDeletionRequests = await prisma.dataDeletionRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataDeletionRequestWithIdOnly = await prisma.dataDeletionRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataDeletionRequestFindManyArgs>(args?: SelectSubset<T, DataDeletionRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DataDeletionRequest.
     * @param {DataDeletionRequestCreateArgs} args - Arguments to create a DataDeletionRequest.
     * @example
     * // Create one DataDeletionRequest
     * const DataDeletionRequest = await prisma.dataDeletionRequest.create({
     *   data: {
     *     // ... data to create a DataDeletionRequest
     *   }
     * })
     * 
     */
    create<T extends DataDeletionRequestCreateArgs>(args: SelectSubset<T, DataDeletionRequestCreateArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DataDeletionRequests.
     * @param {DataDeletionRequestCreateManyArgs} args - Arguments to create many DataDeletionRequests.
     * @example
     * // Create many DataDeletionRequests
     * const dataDeletionRequest = await prisma.dataDeletionRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataDeletionRequestCreateManyArgs>(args?: SelectSubset<T, DataDeletionRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataDeletionRequests and returns the data saved in the database.
     * @param {DataDeletionRequestCreateManyAndReturnArgs} args - Arguments to create many DataDeletionRequests.
     * @example
     * // Create many DataDeletionRequests
     * const dataDeletionRequest = await prisma.dataDeletionRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataDeletionRequests and only return the `id`
     * const dataDeletionRequestWithIdOnly = await prisma.dataDeletionRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataDeletionRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, DataDeletionRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DataDeletionRequest.
     * @param {DataDeletionRequestDeleteArgs} args - Arguments to delete one DataDeletionRequest.
     * @example
     * // Delete one DataDeletionRequest
     * const DataDeletionRequest = await prisma.dataDeletionRequest.delete({
     *   where: {
     *     // ... filter to delete one DataDeletionRequest
     *   }
     * })
     * 
     */
    delete<T extends DataDeletionRequestDeleteArgs>(args: SelectSubset<T, DataDeletionRequestDeleteArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DataDeletionRequest.
     * @param {DataDeletionRequestUpdateArgs} args - Arguments to update one DataDeletionRequest.
     * @example
     * // Update one DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataDeletionRequestUpdateArgs>(args: SelectSubset<T, DataDeletionRequestUpdateArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DataDeletionRequests.
     * @param {DataDeletionRequestDeleteManyArgs} args - Arguments to filter DataDeletionRequests to delete.
     * @example
     * // Delete a few DataDeletionRequests
     * const { count } = await prisma.dataDeletionRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataDeletionRequestDeleteManyArgs>(args?: SelectSubset<T, DataDeletionRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataDeletionRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataDeletionRequests
     * const dataDeletionRequest = await prisma.dataDeletionRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataDeletionRequestUpdateManyArgs>(args: SelectSubset<T, DataDeletionRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataDeletionRequests and returns the data updated in the database.
     * @param {DataDeletionRequestUpdateManyAndReturnArgs} args - Arguments to update many DataDeletionRequests.
     * @example
     * // Update many DataDeletionRequests
     * const dataDeletionRequest = await prisma.dataDeletionRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DataDeletionRequests and only return the `id`
     * const dataDeletionRequestWithIdOnly = await prisma.dataDeletionRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DataDeletionRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, DataDeletionRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DataDeletionRequest.
     * @param {DataDeletionRequestUpsertArgs} args - Arguments to update or create a DataDeletionRequest.
     * @example
     * // Update or create a DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.upsert({
     *   create: {
     *     // ... data to create a DataDeletionRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataDeletionRequest we want to update
     *   }
     * })
     */
    upsert<T extends DataDeletionRequestUpsertArgs>(args: SelectSubset<T, DataDeletionRequestUpsertArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DataDeletionRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestCountArgs} args - Arguments to filter DataDeletionRequests to count.
     * @example
     * // Count the number of DataDeletionRequests
     * const count = await prisma.dataDeletionRequest.count({
     *   where: {
     *     // ... the filter for the DataDeletionRequests we want to count
     *   }
     * })
    **/
    count<T extends DataDeletionRequestCountArgs>(
      args?: Subset<T, DataDeletionRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataDeletionRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataDeletionRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataDeletionRequestAggregateArgs>(args: Subset<T, DataDeletionRequestAggregateArgs>): Prisma.PrismaPromise<GetDataDeletionRequestAggregateType<T>>

    /**
     * Group by DataDeletionRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataDeletionRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataDeletionRequestGroupByArgs['orderBy'] }
        : { orderBy?: DataDeletionRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataDeletionRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataDeletionRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataDeletionRequest model
   */
  readonly fields: DataDeletionRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataDeletionRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataDeletionRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataDeletionRequest model
   */
  interface DataDeletionRequestFieldRefs {
    readonly id: FieldRef<"DataDeletionRequest", 'String'>
    readonly userId: FieldRef<"DataDeletionRequest", 'String'>
    readonly status: FieldRef<"DataDeletionRequest", 'String'>
    readonly requestedAt: FieldRef<"DataDeletionRequest", 'DateTime'>
    readonly processedAt: FieldRef<"DataDeletionRequest", 'DateTime'>
    readonly rejectionReason: FieldRef<"DataDeletionRequest", 'String'>
    readonly dataDeleted: FieldRef<"DataDeletionRequest", 'Json'>
    readonly createdAt: FieldRef<"DataDeletionRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"DataDeletionRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataDeletionRequest findUnique
   */
  export type DataDeletionRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataDeletionRequest to fetch.
     */
    where: DataDeletionRequestWhereUniqueInput
  }

  /**
   * DataDeletionRequest findUniqueOrThrow
   */
  export type DataDeletionRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataDeletionRequest to fetch.
     */
    where: DataDeletionRequestWhereUniqueInput
  }

  /**
   * DataDeletionRequest findFirst
   */
  export type DataDeletionRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataDeletionRequest to fetch.
     */
    where?: DataDeletionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataDeletionRequests to fetch.
     */
    orderBy?: DataDeletionRequestOrderByWithRelationInput | DataDeletionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataDeletionRequests.
     */
    cursor?: DataDeletionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataDeletionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataDeletionRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataDeletionRequests.
     */
    distinct?: DataDeletionRequestScalarFieldEnum | DataDeletionRequestScalarFieldEnum[]
  }

  /**
   * DataDeletionRequest findFirstOrThrow
   */
  export type DataDeletionRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataDeletionRequest to fetch.
     */
    where?: DataDeletionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataDeletionRequests to fetch.
     */
    orderBy?: DataDeletionRequestOrderByWithRelationInput | DataDeletionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataDeletionRequests.
     */
    cursor?: DataDeletionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataDeletionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataDeletionRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataDeletionRequests.
     */
    distinct?: DataDeletionRequestScalarFieldEnum | DataDeletionRequestScalarFieldEnum[]
  }

  /**
   * DataDeletionRequest findMany
   */
  export type DataDeletionRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataDeletionRequests to fetch.
     */
    where?: DataDeletionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataDeletionRequests to fetch.
     */
    orderBy?: DataDeletionRequestOrderByWithRelationInput | DataDeletionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataDeletionRequests.
     */
    cursor?: DataDeletionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataDeletionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataDeletionRequests.
     */
    skip?: number
    distinct?: DataDeletionRequestScalarFieldEnum | DataDeletionRequestScalarFieldEnum[]
  }

  /**
   * DataDeletionRequest create
   */
  export type DataDeletionRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a DataDeletionRequest.
     */
    data: XOR<DataDeletionRequestCreateInput, DataDeletionRequestUncheckedCreateInput>
  }

  /**
   * DataDeletionRequest createMany
   */
  export type DataDeletionRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataDeletionRequests.
     */
    data: DataDeletionRequestCreateManyInput | DataDeletionRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataDeletionRequest createManyAndReturn
   */
  export type DataDeletionRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * The data used to create many DataDeletionRequests.
     */
    data: DataDeletionRequestCreateManyInput | DataDeletionRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataDeletionRequest update
   */
  export type DataDeletionRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a DataDeletionRequest.
     */
    data: XOR<DataDeletionRequestUpdateInput, DataDeletionRequestUncheckedUpdateInput>
    /**
     * Choose, which DataDeletionRequest to update.
     */
    where: DataDeletionRequestWhereUniqueInput
  }

  /**
   * DataDeletionRequest updateMany
   */
  export type DataDeletionRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataDeletionRequests.
     */
    data: XOR<DataDeletionRequestUpdateManyMutationInput, DataDeletionRequestUncheckedUpdateManyInput>
    /**
     * Filter which DataDeletionRequests to update
     */
    where?: DataDeletionRequestWhereInput
    /**
     * Limit how many DataDeletionRequests to update.
     */
    limit?: number
  }

  /**
   * DataDeletionRequest updateManyAndReturn
   */
  export type DataDeletionRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * The data used to update DataDeletionRequests.
     */
    data: XOR<DataDeletionRequestUpdateManyMutationInput, DataDeletionRequestUncheckedUpdateManyInput>
    /**
     * Filter which DataDeletionRequests to update
     */
    where?: DataDeletionRequestWhereInput
    /**
     * Limit how many DataDeletionRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataDeletionRequest upsert
   */
  export type DataDeletionRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the DataDeletionRequest to update in case it exists.
     */
    where: DataDeletionRequestWhereUniqueInput
    /**
     * In case the DataDeletionRequest found by the `where` argument doesn't exist, create a new DataDeletionRequest with this data.
     */
    create: XOR<DataDeletionRequestCreateInput, DataDeletionRequestUncheckedCreateInput>
    /**
     * In case the DataDeletionRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataDeletionRequestUpdateInput, DataDeletionRequestUncheckedUpdateInput>
  }

  /**
   * DataDeletionRequest delete
   */
  export type DataDeletionRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    /**
     * Filter which DataDeletionRequest to delete.
     */
    where: DataDeletionRequestWhereUniqueInput
  }

  /**
   * DataDeletionRequest deleteMany
   */
  export type DataDeletionRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataDeletionRequests to delete
     */
    where?: DataDeletionRequestWhereInput
    /**
     * Limit how many DataDeletionRequests to delete.
     */
    limit?: number
  }

  /**
   * DataDeletionRequest without action
   */
  export type DataDeletionRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
  }


  /**
   * Model DataExportRequest
   */

  export type AggregateDataExportRequest = {
    _count: DataExportRequestCountAggregateOutputType | null
    _min: DataExportRequestMinAggregateOutputType | null
    _max: DataExportRequestMaxAggregateOutputType | null
  }

  export type DataExportRequestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: string | null
    exportFormat: string | null
    filePath: string | null
    expiresAt: Date | null
    requestedAt: Date | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataExportRequestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: string | null
    exportFormat: string | null
    filePath: string | null
    expiresAt: Date | null
    requestedAt: Date | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataExportRequestCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    exportFormat: number
    filePath: number
    expiresAt: number
    requestedAt: number
    processedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DataExportRequestMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    exportFormat?: true
    filePath?: true
    expiresAt?: true
    requestedAt?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataExportRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    exportFormat?: true
    filePath?: true
    expiresAt?: true
    requestedAt?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataExportRequestCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    exportFormat?: true
    filePath?: true
    expiresAt?: true
    requestedAt?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DataExportRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataExportRequest to aggregate.
     */
    where?: DataExportRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataExportRequests to fetch.
     */
    orderBy?: DataExportRequestOrderByWithRelationInput | DataExportRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataExportRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataExportRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataExportRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataExportRequests
    **/
    _count?: true | DataExportRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataExportRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataExportRequestMaxAggregateInputType
  }

  export type GetDataExportRequestAggregateType<T extends DataExportRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateDataExportRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataExportRequest[P]>
      : GetScalarType<T[P], AggregateDataExportRequest[P]>
  }




  export type DataExportRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataExportRequestWhereInput
    orderBy?: DataExportRequestOrderByWithAggregationInput | DataExportRequestOrderByWithAggregationInput[]
    by: DataExportRequestScalarFieldEnum[] | DataExportRequestScalarFieldEnum
    having?: DataExportRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataExportRequestCountAggregateInputType | true
    _min?: DataExportRequestMinAggregateInputType
    _max?: DataExportRequestMaxAggregateInputType
  }

  export type DataExportRequestGroupByOutputType = {
    id: string
    userId: string
    status: string
    exportFormat: string
    filePath: string | null
    expiresAt: Date | null
    requestedAt: Date
    processedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DataExportRequestCountAggregateOutputType | null
    _min: DataExportRequestMinAggregateOutputType | null
    _max: DataExportRequestMaxAggregateOutputType | null
  }

  type GetDataExportRequestGroupByPayload<T extends DataExportRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataExportRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataExportRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataExportRequestGroupByOutputType[P]>
            : GetScalarType<T[P], DataExportRequestGroupByOutputType[P]>
        }
      >
    >


  export type DataExportRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    exportFormat?: boolean
    filePath?: boolean
    expiresAt?: boolean
    requestedAt?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataExportRequest"]>

  export type DataExportRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    exportFormat?: boolean
    filePath?: boolean
    expiresAt?: boolean
    requestedAt?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataExportRequest"]>

  export type DataExportRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    exportFormat?: boolean
    filePath?: boolean
    expiresAt?: boolean
    requestedAt?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataExportRequest"]>

  export type DataExportRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    exportFormat?: boolean
    filePath?: boolean
    expiresAt?: boolean
    requestedAt?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DataExportRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "status" | "exportFormat" | "filePath" | "expiresAt" | "requestedAt" | "processedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["dataExportRequest"]>
  export type DataExportRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DataExportRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DataExportRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DataExportRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataExportRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: string
      exportFormat: string
      filePath: string | null
      expiresAt: Date | null
      requestedAt: Date
      processedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dataExportRequest"]>
    composites: {}
  }

  type DataExportRequestGetPayload<S extends boolean | null | undefined | DataExportRequestDefaultArgs> = $Result.GetResult<Prisma.$DataExportRequestPayload, S>

  type DataExportRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataExportRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataExportRequestCountAggregateInputType | true
    }

  export interface DataExportRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataExportRequest'], meta: { name: 'DataExportRequest' } }
    /**
     * Find zero or one DataExportRequest that matches the filter.
     * @param {DataExportRequestFindUniqueArgs} args - Arguments to find a DataExportRequest
     * @example
     * // Get one DataExportRequest
     * const dataExportRequest = await prisma.dataExportRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataExportRequestFindUniqueArgs>(args: SelectSubset<T, DataExportRequestFindUniqueArgs<ExtArgs>>): Prisma__DataExportRequestClient<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DataExportRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataExportRequestFindUniqueOrThrowArgs} args - Arguments to find a DataExportRequest
     * @example
     * // Get one DataExportRequest
     * const dataExportRequest = await prisma.dataExportRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataExportRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, DataExportRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataExportRequestClient<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataExportRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataExportRequestFindFirstArgs} args - Arguments to find a DataExportRequest
     * @example
     * // Get one DataExportRequest
     * const dataExportRequest = await prisma.dataExportRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataExportRequestFindFirstArgs>(args?: SelectSubset<T, DataExportRequestFindFirstArgs<ExtArgs>>): Prisma__DataExportRequestClient<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataExportRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataExportRequestFindFirstOrThrowArgs} args - Arguments to find a DataExportRequest
     * @example
     * // Get one DataExportRequest
     * const dataExportRequest = await prisma.dataExportRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataExportRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, DataExportRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataExportRequestClient<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DataExportRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataExportRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataExportRequests
     * const dataExportRequests = await prisma.dataExportRequest.findMany()
     * 
     * // Get first 10 DataExportRequests
     * const dataExportRequests = await prisma.dataExportRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataExportRequestWithIdOnly = await prisma.dataExportRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataExportRequestFindManyArgs>(args?: SelectSubset<T, DataExportRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DataExportRequest.
     * @param {DataExportRequestCreateArgs} args - Arguments to create a DataExportRequest.
     * @example
     * // Create one DataExportRequest
     * const DataExportRequest = await prisma.dataExportRequest.create({
     *   data: {
     *     // ... data to create a DataExportRequest
     *   }
     * })
     * 
     */
    create<T extends DataExportRequestCreateArgs>(args: SelectSubset<T, DataExportRequestCreateArgs<ExtArgs>>): Prisma__DataExportRequestClient<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DataExportRequests.
     * @param {DataExportRequestCreateManyArgs} args - Arguments to create many DataExportRequests.
     * @example
     * // Create many DataExportRequests
     * const dataExportRequest = await prisma.dataExportRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataExportRequestCreateManyArgs>(args?: SelectSubset<T, DataExportRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataExportRequests and returns the data saved in the database.
     * @param {DataExportRequestCreateManyAndReturnArgs} args - Arguments to create many DataExportRequests.
     * @example
     * // Create many DataExportRequests
     * const dataExportRequest = await prisma.dataExportRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataExportRequests and only return the `id`
     * const dataExportRequestWithIdOnly = await prisma.dataExportRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataExportRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, DataExportRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DataExportRequest.
     * @param {DataExportRequestDeleteArgs} args - Arguments to delete one DataExportRequest.
     * @example
     * // Delete one DataExportRequest
     * const DataExportRequest = await prisma.dataExportRequest.delete({
     *   where: {
     *     // ... filter to delete one DataExportRequest
     *   }
     * })
     * 
     */
    delete<T extends DataExportRequestDeleteArgs>(args: SelectSubset<T, DataExportRequestDeleteArgs<ExtArgs>>): Prisma__DataExportRequestClient<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DataExportRequest.
     * @param {DataExportRequestUpdateArgs} args - Arguments to update one DataExportRequest.
     * @example
     * // Update one DataExportRequest
     * const dataExportRequest = await prisma.dataExportRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataExportRequestUpdateArgs>(args: SelectSubset<T, DataExportRequestUpdateArgs<ExtArgs>>): Prisma__DataExportRequestClient<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DataExportRequests.
     * @param {DataExportRequestDeleteManyArgs} args - Arguments to filter DataExportRequests to delete.
     * @example
     * // Delete a few DataExportRequests
     * const { count } = await prisma.dataExportRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataExportRequestDeleteManyArgs>(args?: SelectSubset<T, DataExportRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataExportRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataExportRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataExportRequests
     * const dataExportRequest = await prisma.dataExportRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataExportRequestUpdateManyArgs>(args: SelectSubset<T, DataExportRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataExportRequests and returns the data updated in the database.
     * @param {DataExportRequestUpdateManyAndReturnArgs} args - Arguments to update many DataExportRequests.
     * @example
     * // Update many DataExportRequests
     * const dataExportRequest = await prisma.dataExportRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DataExportRequests and only return the `id`
     * const dataExportRequestWithIdOnly = await prisma.dataExportRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DataExportRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, DataExportRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DataExportRequest.
     * @param {DataExportRequestUpsertArgs} args - Arguments to update or create a DataExportRequest.
     * @example
     * // Update or create a DataExportRequest
     * const dataExportRequest = await prisma.dataExportRequest.upsert({
     *   create: {
     *     // ... data to create a DataExportRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataExportRequest we want to update
     *   }
     * })
     */
    upsert<T extends DataExportRequestUpsertArgs>(args: SelectSubset<T, DataExportRequestUpsertArgs<ExtArgs>>): Prisma__DataExportRequestClient<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DataExportRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataExportRequestCountArgs} args - Arguments to filter DataExportRequests to count.
     * @example
     * // Count the number of DataExportRequests
     * const count = await prisma.dataExportRequest.count({
     *   where: {
     *     // ... the filter for the DataExportRequests we want to count
     *   }
     * })
    **/
    count<T extends DataExportRequestCountArgs>(
      args?: Subset<T, DataExportRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataExportRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataExportRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataExportRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataExportRequestAggregateArgs>(args: Subset<T, DataExportRequestAggregateArgs>): Prisma.PrismaPromise<GetDataExportRequestAggregateType<T>>

    /**
     * Group by DataExportRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataExportRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataExportRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataExportRequestGroupByArgs['orderBy'] }
        : { orderBy?: DataExportRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataExportRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataExportRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataExportRequest model
   */
  readonly fields: DataExportRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataExportRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataExportRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataExportRequest model
   */
  interface DataExportRequestFieldRefs {
    readonly id: FieldRef<"DataExportRequest", 'String'>
    readonly userId: FieldRef<"DataExportRequest", 'String'>
    readonly status: FieldRef<"DataExportRequest", 'String'>
    readonly exportFormat: FieldRef<"DataExportRequest", 'String'>
    readonly filePath: FieldRef<"DataExportRequest", 'String'>
    readonly expiresAt: FieldRef<"DataExportRequest", 'DateTime'>
    readonly requestedAt: FieldRef<"DataExportRequest", 'DateTime'>
    readonly processedAt: FieldRef<"DataExportRequest", 'DateTime'>
    readonly createdAt: FieldRef<"DataExportRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"DataExportRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataExportRequest findUnique
   */
  export type DataExportRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExportRequest
     */
    omit?: DataExportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataExportRequest to fetch.
     */
    where: DataExportRequestWhereUniqueInput
  }

  /**
   * DataExportRequest findUniqueOrThrow
   */
  export type DataExportRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExportRequest
     */
    omit?: DataExportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataExportRequest to fetch.
     */
    where: DataExportRequestWhereUniqueInput
  }

  /**
   * DataExportRequest findFirst
   */
  export type DataExportRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExportRequest
     */
    omit?: DataExportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataExportRequest to fetch.
     */
    where?: DataExportRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataExportRequests to fetch.
     */
    orderBy?: DataExportRequestOrderByWithRelationInput | DataExportRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataExportRequests.
     */
    cursor?: DataExportRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataExportRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataExportRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataExportRequests.
     */
    distinct?: DataExportRequestScalarFieldEnum | DataExportRequestScalarFieldEnum[]
  }

  /**
   * DataExportRequest findFirstOrThrow
   */
  export type DataExportRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExportRequest
     */
    omit?: DataExportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataExportRequest to fetch.
     */
    where?: DataExportRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataExportRequests to fetch.
     */
    orderBy?: DataExportRequestOrderByWithRelationInput | DataExportRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataExportRequests.
     */
    cursor?: DataExportRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataExportRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataExportRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataExportRequests.
     */
    distinct?: DataExportRequestScalarFieldEnum | DataExportRequestScalarFieldEnum[]
  }

  /**
   * DataExportRequest findMany
   */
  export type DataExportRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExportRequest
     */
    omit?: DataExportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataExportRequests to fetch.
     */
    where?: DataExportRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataExportRequests to fetch.
     */
    orderBy?: DataExportRequestOrderByWithRelationInput | DataExportRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataExportRequests.
     */
    cursor?: DataExportRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataExportRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataExportRequests.
     */
    skip?: number
    distinct?: DataExportRequestScalarFieldEnum | DataExportRequestScalarFieldEnum[]
  }

  /**
   * DataExportRequest create
   */
  export type DataExportRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExportRequest
     */
    omit?: DataExportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a DataExportRequest.
     */
    data: XOR<DataExportRequestCreateInput, DataExportRequestUncheckedCreateInput>
  }

  /**
   * DataExportRequest createMany
   */
  export type DataExportRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataExportRequests.
     */
    data: DataExportRequestCreateManyInput | DataExportRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataExportRequest createManyAndReturn
   */
  export type DataExportRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataExportRequest
     */
    omit?: DataExportRequestOmit<ExtArgs> | null
    /**
     * The data used to create many DataExportRequests.
     */
    data: DataExportRequestCreateManyInput | DataExportRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataExportRequest update
   */
  export type DataExportRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExportRequest
     */
    omit?: DataExportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a DataExportRequest.
     */
    data: XOR<DataExportRequestUpdateInput, DataExportRequestUncheckedUpdateInput>
    /**
     * Choose, which DataExportRequest to update.
     */
    where: DataExportRequestWhereUniqueInput
  }

  /**
   * DataExportRequest updateMany
   */
  export type DataExportRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataExportRequests.
     */
    data: XOR<DataExportRequestUpdateManyMutationInput, DataExportRequestUncheckedUpdateManyInput>
    /**
     * Filter which DataExportRequests to update
     */
    where?: DataExportRequestWhereInput
    /**
     * Limit how many DataExportRequests to update.
     */
    limit?: number
  }

  /**
   * DataExportRequest updateManyAndReturn
   */
  export type DataExportRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataExportRequest
     */
    omit?: DataExportRequestOmit<ExtArgs> | null
    /**
     * The data used to update DataExportRequests.
     */
    data: XOR<DataExportRequestUpdateManyMutationInput, DataExportRequestUncheckedUpdateManyInput>
    /**
     * Filter which DataExportRequests to update
     */
    where?: DataExportRequestWhereInput
    /**
     * Limit how many DataExportRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataExportRequest upsert
   */
  export type DataExportRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExportRequest
     */
    omit?: DataExportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the DataExportRequest to update in case it exists.
     */
    where: DataExportRequestWhereUniqueInput
    /**
     * In case the DataExportRequest found by the `where` argument doesn't exist, create a new DataExportRequest with this data.
     */
    create: XOR<DataExportRequestCreateInput, DataExportRequestUncheckedCreateInput>
    /**
     * In case the DataExportRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataExportRequestUpdateInput, DataExportRequestUncheckedUpdateInput>
  }

  /**
   * DataExportRequest delete
   */
  export type DataExportRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExportRequest
     */
    omit?: DataExportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
    /**
     * Filter which DataExportRequest to delete.
     */
    where: DataExportRequestWhereUniqueInput
  }

  /**
   * DataExportRequest deleteMany
   */
  export type DataExportRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataExportRequests to delete
     */
    where?: DataExportRequestWhereInput
    /**
     * Limit how many DataExportRequests to delete.
     */
    limit?: number
  }

  /**
   * DataExportRequest without action
   */
  export type DataExportRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExportRequest
     */
    omit?: DataExportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
  }


  /**
   * Model SecurityAlert
   */

  export type AggregateSecurityAlert = {
    _count: SecurityAlertCountAggregateOutputType | null
    _min: SecurityAlertMinAggregateOutputType | null
    _max: SecurityAlertMaxAggregateOutputType | null
  }

  export type SecurityAlertMinAggregateOutputType = {
    id: string | null
    userId: string | null
    alertType: string | null
    severity: string | null
    description: string | null
    actionRequired: string | null
    acknowledged: boolean | null
    createdAt: Date | null
  }

  export type SecurityAlertMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    alertType: string | null
    severity: string | null
    description: string | null
    actionRequired: string | null
    acknowledged: boolean | null
    createdAt: Date | null
  }

  export type SecurityAlertCountAggregateOutputType = {
    id: number
    userId: number
    alertType: number
    severity: number
    description: number
    actionRequired: number
    acknowledged: number
    createdAt: number
    _all: number
  }


  export type SecurityAlertMinAggregateInputType = {
    id?: true
    userId?: true
    alertType?: true
    severity?: true
    description?: true
    actionRequired?: true
    acknowledged?: true
    createdAt?: true
  }

  export type SecurityAlertMaxAggregateInputType = {
    id?: true
    userId?: true
    alertType?: true
    severity?: true
    description?: true
    actionRequired?: true
    acknowledged?: true
    createdAt?: true
  }

  export type SecurityAlertCountAggregateInputType = {
    id?: true
    userId?: true
    alertType?: true
    severity?: true
    description?: true
    actionRequired?: true
    acknowledged?: true
    createdAt?: true
    _all?: true
  }

  export type SecurityAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityAlert to aggregate.
     */
    where?: SecurityAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityAlerts to fetch.
     */
    orderBy?: SecurityAlertOrderByWithRelationInput | SecurityAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecurityAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityAlerts
    **/
    _count?: true | SecurityAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityAlertMaxAggregateInputType
  }

  export type GetSecurityAlertAggregateType<T extends SecurityAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityAlert[P]>
      : GetScalarType<T[P], AggregateSecurityAlert[P]>
  }




  export type SecurityAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityAlertWhereInput
    orderBy?: SecurityAlertOrderByWithAggregationInput | SecurityAlertOrderByWithAggregationInput[]
    by: SecurityAlertScalarFieldEnum[] | SecurityAlertScalarFieldEnum
    having?: SecurityAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityAlertCountAggregateInputType | true
    _min?: SecurityAlertMinAggregateInputType
    _max?: SecurityAlertMaxAggregateInputType
  }

  export type SecurityAlertGroupByOutputType = {
    id: string
    userId: string | null
    alertType: string
    severity: string
    description: string | null
    actionRequired: string | null
    acknowledged: boolean
    createdAt: Date
    _count: SecurityAlertCountAggregateOutputType | null
    _min: SecurityAlertMinAggregateOutputType | null
    _max: SecurityAlertMaxAggregateOutputType | null
  }

  type GetSecurityAlertGroupByPayload<T extends SecurityAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecurityAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityAlertGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityAlertGroupByOutputType[P]>
        }
      >
    >


  export type SecurityAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    alertType?: boolean
    severity?: boolean
    description?: boolean
    actionRequired?: boolean
    acknowledged?: boolean
    createdAt?: boolean
    user?: boolean | SecurityAlert$userArgs<ExtArgs>
  }, ExtArgs["result"]["securityAlert"]>

  export type SecurityAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    alertType?: boolean
    severity?: boolean
    description?: boolean
    actionRequired?: boolean
    acknowledged?: boolean
    createdAt?: boolean
    user?: boolean | SecurityAlert$userArgs<ExtArgs>
  }, ExtArgs["result"]["securityAlert"]>

  export type SecurityAlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    alertType?: boolean
    severity?: boolean
    description?: boolean
    actionRequired?: boolean
    acknowledged?: boolean
    createdAt?: boolean
    user?: boolean | SecurityAlert$userArgs<ExtArgs>
  }, ExtArgs["result"]["securityAlert"]>

  export type SecurityAlertSelectScalar = {
    id?: boolean
    userId?: boolean
    alertType?: boolean
    severity?: boolean
    description?: boolean
    actionRequired?: boolean
    acknowledged?: boolean
    createdAt?: boolean
  }

  export type SecurityAlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "alertType" | "severity" | "description" | "actionRequired" | "acknowledged" | "createdAt", ExtArgs["result"]["securityAlert"]>
  export type SecurityAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SecurityAlert$userArgs<ExtArgs>
  }
  export type SecurityAlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SecurityAlert$userArgs<ExtArgs>
  }
  export type SecurityAlertIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SecurityAlert$userArgs<ExtArgs>
  }

  export type $SecurityAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecurityAlert"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      alertType: string
      severity: string
      description: string | null
      actionRequired: string | null
      acknowledged: boolean
      createdAt: Date
    }, ExtArgs["result"]["securityAlert"]>
    composites: {}
  }

  type SecurityAlertGetPayload<S extends boolean | null | undefined | SecurityAlertDefaultArgs> = $Result.GetResult<Prisma.$SecurityAlertPayload, S>

  type SecurityAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SecurityAlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SecurityAlertCountAggregateInputType | true
    }

  export interface SecurityAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecurityAlert'], meta: { name: 'SecurityAlert' } }
    /**
     * Find zero or one SecurityAlert that matches the filter.
     * @param {SecurityAlertFindUniqueArgs} args - Arguments to find a SecurityAlert
     * @example
     * // Get one SecurityAlert
     * const securityAlert = await prisma.securityAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecurityAlertFindUniqueArgs>(args: SelectSubset<T, SecurityAlertFindUniqueArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SecurityAlert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SecurityAlertFindUniqueOrThrowArgs} args - Arguments to find a SecurityAlert
     * @example
     * // Get one SecurityAlert
     * const securityAlert = await prisma.securityAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecurityAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, SecurityAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAlertFindFirstArgs} args - Arguments to find a SecurityAlert
     * @example
     * // Get one SecurityAlert
     * const securityAlert = await prisma.securityAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecurityAlertFindFirstArgs>(args?: SelectSubset<T, SecurityAlertFindFirstArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAlertFindFirstOrThrowArgs} args - Arguments to find a SecurityAlert
     * @example
     * // Get one SecurityAlert
     * const securityAlert = await prisma.securityAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecurityAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, SecurityAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SecurityAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityAlerts
     * const securityAlerts = await prisma.securityAlert.findMany()
     * 
     * // Get first 10 SecurityAlerts
     * const securityAlerts = await prisma.securityAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityAlertWithIdOnly = await prisma.securityAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SecurityAlertFindManyArgs>(args?: SelectSubset<T, SecurityAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SecurityAlert.
     * @param {SecurityAlertCreateArgs} args - Arguments to create a SecurityAlert.
     * @example
     * // Create one SecurityAlert
     * const SecurityAlert = await prisma.securityAlert.create({
     *   data: {
     *     // ... data to create a SecurityAlert
     *   }
     * })
     * 
     */
    create<T extends SecurityAlertCreateArgs>(args: SelectSubset<T, SecurityAlertCreateArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SecurityAlerts.
     * @param {SecurityAlertCreateManyArgs} args - Arguments to create many SecurityAlerts.
     * @example
     * // Create many SecurityAlerts
     * const securityAlert = await prisma.securityAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SecurityAlertCreateManyArgs>(args?: SelectSubset<T, SecurityAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SecurityAlerts and returns the data saved in the database.
     * @param {SecurityAlertCreateManyAndReturnArgs} args - Arguments to create many SecurityAlerts.
     * @example
     * // Create many SecurityAlerts
     * const securityAlert = await prisma.securityAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SecurityAlerts and only return the `id`
     * const securityAlertWithIdOnly = await prisma.securityAlert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SecurityAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, SecurityAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SecurityAlert.
     * @param {SecurityAlertDeleteArgs} args - Arguments to delete one SecurityAlert.
     * @example
     * // Delete one SecurityAlert
     * const SecurityAlert = await prisma.securityAlert.delete({
     *   where: {
     *     // ... filter to delete one SecurityAlert
     *   }
     * })
     * 
     */
    delete<T extends SecurityAlertDeleteArgs>(args: SelectSubset<T, SecurityAlertDeleteArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SecurityAlert.
     * @param {SecurityAlertUpdateArgs} args - Arguments to update one SecurityAlert.
     * @example
     * // Update one SecurityAlert
     * const securityAlert = await prisma.securityAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SecurityAlertUpdateArgs>(args: SelectSubset<T, SecurityAlertUpdateArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SecurityAlerts.
     * @param {SecurityAlertDeleteManyArgs} args - Arguments to filter SecurityAlerts to delete.
     * @example
     * // Delete a few SecurityAlerts
     * const { count } = await prisma.securityAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SecurityAlertDeleteManyArgs>(args?: SelectSubset<T, SecurityAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityAlerts
     * const securityAlert = await prisma.securityAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SecurityAlertUpdateManyArgs>(args: SelectSubset<T, SecurityAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityAlerts and returns the data updated in the database.
     * @param {SecurityAlertUpdateManyAndReturnArgs} args - Arguments to update many SecurityAlerts.
     * @example
     * // Update many SecurityAlerts
     * const securityAlert = await prisma.securityAlert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SecurityAlerts and only return the `id`
     * const securityAlertWithIdOnly = await prisma.securityAlert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SecurityAlertUpdateManyAndReturnArgs>(args: SelectSubset<T, SecurityAlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SecurityAlert.
     * @param {SecurityAlertUpsertArgs} args - Arguments to update or create a SecurityAlert.
     * @example
     * // Update or create a SecurityAlert
     * const securityAlert = await prisma.securityAlert.upsert({
     *   create: {
     *     // ... data to create a SecurityAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityAlert we want to update
     *   }
     * })
     */
    upsert<T extends SecurityAlertUpsertArgs>(args: SelectSubset<T, SecurityAlertUpsertArgs<ExtArgs>>): Prisma__SecurityAlertClient<$Result.GetResult<Prisma.$SecurityAlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SecurityAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAlertCountArgs} args - Arguments to filter SecurityAlerts to count.
     * @example
     * // Count the number of SecurityAlerts
     * const count = await prisma.securityAlert.count({
     *   where: {
     *     // ... the filter for the SecurityAlerts we want to count
     *   }
     * })
    **/
    count<T extends SecurityAlertCountArgs>(
      args?: Subset<T, SecurityAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityAlertAggregateArgs>(args: Subset<T, SecurityAlertAggregateArgs>): Prisma.PrismaPromise<GetSecurityAlertAggregateType<T>>

    /**
     * Group by SecurityAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityAlertGroupByArgs['orderBy'] }
        : { orderBy?: SecurityAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecurityAlert model
   */
  readonly fields: SecurityAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecurityAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends SecurityAlert$userArgs<ExtArgs> = {}>(args?: Subset<T, SecurityAlert$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SecurityAlert model
   */
  interface SecurityAlertFieldRefs {
    readonly id: FieldRef<"SecurityAlert", 'String'>
    readonly userId: FieldRef<"SecurityAlert", 'String'>
    readonly alertType: FieldRef<"SecurityAlert", 'String'>
    readonly severity: FieldRef<"SecurityAlert", 'String'>
    readonly description: FieldRef<"SecurityAlert", 'String'>
    readonly actionRequired: FieldRef<"SecurityAlert", 'String'>
    readonly acknowledged: FieldRef<"SecurityAlert", 'Boolean'>
    readonly createdAt: FieldRef<"SecurityAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SecurityAlert findUnique
   */
  export type SecurityAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * Filter, which SecurityAlert to fetch.
     */
    where: SecurityAlertWhereUniqueInput
  }

  /**
   * SecurityAlert findUniqueOrThrow
   */
  export type SecurityAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * Filter, which SecurityAlert to fetch.
     */
    where: SecurityAlertWhereUniqueInput
  }

  /**
   * SecurityAlert findFirst
   */
  export type SecurityAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * Filter, which SecurityAlert to fetch.
     */
    where?: SecurityAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityAlerts to fetch.
     */
    orderBy?: SecurityAlertOrderByWithRelationInput | SecurityAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityAlerts.
     */
    cursor?: SecurityAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityAlerts.
     */
    distinct?: SecurityAlertScalarFieldEnum | SecurityAlertScalarFieldEnum[]
  }

  /**
   * SecurityAlert findFirstOrThrow
   */
  export type SecurityAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * Filter, which SecurityAlert to fetch.
     */
    where?: SecurityAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityAlerts to fetch.
     */
    orderBy?: SecurityAlertOrderByWithRelationInput | SecurityAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityAlerts.
     */
    cursor?: SecurityAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityAlerts.
     */
    distinct?: SecurityAlertScalarFieldEnum | SecurityAlertScalarFieldEnum[]
  }

  /**
   * SecurityAlert findMany
   */
  export type SecurityAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * Filter, which SecurityAlerts to fetch.
     */
    where?: SecurityAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityAlerts to fetch.
     */
    orderBy?: SecurityAlertOrderByWithRelationInput | SecurityAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityAlerts.
     */
    cursor?: SecurityAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityAlerts.
     */
    skip?: number
    distinct?: SecurityAlertScalarFieldEnum | SecurityAlertScalarFieldEnum[]
  }

  /**
   * SecurityAlert create
   */
  export type SecurityAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a SecurityAlert.
     */
    data: XOR<SecurityAlertCreateInput, SecurityAlertUncheckedCreateInput>
  }

  /**
   * SecurityAlert createMany
   */
  export type SecurityAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecurityAlerts.
     */
    data: SecurityAlertCreateManyInput | SecurityAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityAlert createManyAndReturn
   */
  export type SecurityAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * The data used to create many SecurityAlerts.
     */
    data: SecurityAlertCreateManyInput | SecurityAlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SecurityAlert update
   */
  export type SecurityAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a SecurityAlert.
     */
    data: XOR<SecurityAlertUpdateInput, SecurityAlertUncheckedUpdateInput>
    /**
     * Choose, which SecurityAlert to update.
     */
    where: SecurityAlertWhereUniqueInput
  }

  /**
   * SecurityAlert updateMany
   */
  export type SecurityAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecurityAlerts.
     */
    data: XOR<SecurityAlertUpdateManyMutationInput, SecurityAlertUncheckedUpdateManyInput>
    /**
     * Filter which SecurityAlerts to update
     */
    where?: SecurityAlertWhereInput
    /**
     * Limit how many SecurityAlerts to update.
     */
    limit?: number
  }

  /**
   * SecurityAlert updateManyAndReturn
   */
  export type SecurityAlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * The data used to update SecurityAlerts.
     */
    data: XOR<SecurityAlertUpdateManyMutationInput, SecurityAlertUncheckedUpdateManyInput>
    /**
     * Filter which SecurityAlerts to update
     */
    where?: SecurityAlertWhereInput
    /**
     * Limit how many SecurityAlerts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SecurityAlert upsert
   */
  export type SecurityAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the SecurityAlert to update in case it exists.
     */
    where: SecurityAlertWhereUniqueInput
    /**
     * In case the SecurityAlert found by the `where` argument doesn't exist, create a new SecurityAlert with this data.
     */
    create: XOR<SecurityAlertCreateInput, SecurityAlertUncheckedCreateInput>
    /**
     * In case the SecurityAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecurityAlertUpdateInput, SecurityAlertUncheckedUpdateInput>
  }

  /**
   * SecurityAlert delete
   */
  export type SecurityAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
    /**
     * Filter which SecurityAlert to delete.
     */
    where: SecurityAlertWhereUniqueInput
  }

  /**
   * SecurityAlert deleteMany
   */
  export type SecurityAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityAlerts to delete
     */
    where?: SecurityAlertWhereInput
    /**
     * Limit how many SecurityAlerts to delete.
     */
    limit?: number
  }

  /**
   * SecurityAlert.user
   */
  export type SecurityAlert$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SecurityAlert without action
   */
  export type SecurityAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAlert
     */
    select?: SecurityAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAlert
     */
    omit?: SecurityAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityAlertInclude<ExtArgs> | null
  }


  /**
   * Model Promotion
   */

  export type AggregatePromotion = {
    _count: PromotionCountAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  export type PromotionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    promotionType: string | null
    termsAndConditions: string | null
    startDate: Date | null
    endDate: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    promotionType: string | null
    termsAndConditions: string | null
    startDate: Date | null
    endDate: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    promotionType: number
    termsAndConditions: number
    startDate: number
    endDate: number
    active: number
    eligibilityCriteria: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromotionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    promotionType?: true
    termsAndConditions?: true
    startDate?: true
    endDate?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    promotionType?: true
    termsAndConditions?: true
    startDate?: true
    endDate?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    promotionType?: true
    termsAndConditions?: true
    startDate?: true
    endDate?: true
    active?: true
    eligibilityCriteria?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotion to aggregate.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Promotions
    **/
    _count?: true | PromotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionMaxAggregateInputType
  }

  export type GetPromotionAggregateType<T extends PromotionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotion[P]>
      : GetScalarType<T[P], AggregatePromotion[P]>
  }




  export type PromotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithAggregationInput | PromotionOrderByWithAggregationInput[]
    by: PromotionScalarFieldEnum[] | PromotionScalarFieldEnum
    having?: PromotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionCountAggregateInputType | true
    _min?: PromotionMinAggregateInputType
    _max?: PromotionMaxAggregateInputType
  }

  export type PromotionGroupByOutputType = {
    id: string
    name: string
    description: string | null
    promotionType: string
    termsAndConditions: string | null
    startDate: Date
    endDate: Date
    active: boolean
    eligibilityCriteria: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PromotionCountAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  type GetPromotionGroupByPayload<T extends PromotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionGroupByOutputType[P]>
        }
      >
    >


  export type PromotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    promotionType?: boolean
    termsAndConditions?: boolean
    startDate?: boolean
    endDate?: boolean
    active?: boolean
    eligibilityCriteria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userBonuses?: boolean | Promotion$userBonusesArgs<ExtArgs>
    _count?: boolean | PromotionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    promotionType?: boolean
    termsAndConditions?: boolean
    startDate?: boolean
    endDate?: boolean
    active?: boolean
    eligibilityCriteria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    promotionType?: boolean
    termsAndConditions?: boolean
    startDate?: boolean
    endDate?: boolean
    active?: boolean
    eligibilityCriteria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    promotionType?: boolean
    termsAndConditions?: boolean
    startDate?: boolean
    endDate?: boolean
    active?: boolean
    eligibilityCriteria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PromotionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "promotionType" | "termsAndConditions" | "startDate" | "endDate" | "active" | "eligibilityCriteria" | "createdAt" | "updatedAt", ExtArgs["result"]["promotion"]>
  export type PromotionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userBonuses?: boolean | Promotion$userBonusesArgs<ExtArgs>
    _count?: boolean | PromotionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PromotionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PromotionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PromotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Promotion"
    objects: {
      userBonuses: Prisma.$UserBonusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      promotionType: string
      termsAndConditions: string | null
      startDate: Date
      endDate: Date
      active: boolean
      eligibilityCriteria: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["promotion"]>
    composites: {}
  }

  type PromotionGetPayload<S extends boolean | null | undefined | PromotionDefaultArgs> = $Result.GetResult<Prisma.$PromotionPayload, S>

  type PromotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromotionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromotionCountAggregateInputType | true
    }

  export interface PromotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Promotion'], meta: { name: 'Promotion' } }
    /**
     * Find zero or one Promotion that matches the filter.
     * @param {PromotionFindUniqueArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionFindUniqueArgs>(args: SelectSubset<T, PromotionFindUniqueArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Promotion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromotionFindUniqueOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionFindFirstArgs>(args?: SelectSubset<T, PromotionFindFirstArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Promotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promotions
     * const promotions = await prisma.promotion.findMany()
     * 
     * // Get first 10 Promotions
     * const promotions = await prisma.promotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionWithIdOnly = await prisma.promotion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionFindManyArgs>(args?: SelectSubset<T, PromotionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Promotion.
     * @param {PromotionCreateArgs} args - Arguments to create a Promotion.
     * @example
     * // Create one Promotion
     * const Promotion = await prisma.promotion.create({
     *   data: {
     *     // ... data to create a Promotion
     *   }
     * })
     * 
     */
    create<T extends PromotionCreateArgs>(args: SelectSubset<T, PromotionCreateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Promotions.
     * @param {PromotionCreateManyArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionCreateManyArgs>(args?: SelectSubset<T, PromotionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Promotions and returns the data saved in the database.
     * @param {PromotionCreateManyAndReturnArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Promotions and only return the `id`
     * const promotionWithIdOnly = await prisma.promotion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromotionCreateManyAndReturnArgs>(args?: SelectSubset<T, PromotionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Promotion.
     * @param {PromotionDeleteArgs} args - Arguments to delete one Promotion.
     * @example
     * // Delete one Promotion
     * const Promotion = await prisma.promotion.delete({
     *   where: {
     *     // ... filter to delete one Promotion
     *   }
     * })
     * 
     */
    delete<T extends PromotionDeleteArgs>(args: SelectSubset<T, PromotionDeleteArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Promotion.
     * @param {PromotionUpdateArgs} args - Arguments to update one Promotion.
     * @example
     * // Update one Promotion
     * const promotion = await prisma.promotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionUpdateArgs>(args: SelectSubset<T, PromotionUpdateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Promotions.
     * @param {PromotionDeleteManyArgs} args - Arguments to filter Promotions to delete.
     * @example
     * // Delete a few Promotions
     * const { count } = await prisma.promotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionDeleteManyArgs>(args?: SelectSubset<T, PromotionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionUpdateManyArgs>(args: SelectSubset<T, PromotionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions and returns the data updated in the database.
     * @param {PromotionUpdateManyAndReturnArgs} args - Arguments to update many Promotions.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Promotions and only return the `id`
     * const promotionWithIdOnly = await prisma.promotion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromotionUpdateManyAndReturnArgs>(args: SelectSubset<T, PromotionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Promotion.
     * @param {PromotionUpsertArgs} args - Arguments to update or create a Promotion.
     * @example
     * // Update or create a Promotion
     * const promotion = await prisma.promotion.upsert({
     *   create: {
     *     // ... data to create a Promotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promotion we want to update
     *   }
     * })
     */
    upsert<T extends PromotionUpsertArgs>(args: SelectSubset<T, PromotionUpsertArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCountArgs} args - Arguments to filter Promotions to count.
     * @example
     * // Count the number of Promotions
     * const count = await prisma.promotion.count({
     *   where: {
     *     // ... the filter for the Promotions we want to count
     *   }
     * })
    **/
    count<T extends PromotionCountArgs>(
      args?: Subset<T, PromotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionAggregateArgs>(args: Subset<T, PromotionAggregateArgs>): Prisma.PrismaPromise<GetPromotionAggregateType<T>>

    /**
     * Group by Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionGroupByArgs['orderBy'] }
        : { orderBy?: PromotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Promotion model
   */
  readonly fields: PromotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Promotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userBonuses<T extends Promotion$userBonusesArgs<ExtArgs> = {}>(args?: Subset<T, Promotion$userBonusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Promotion model
   */
  interface PromotionFieldRefs {
    readonly id: FieldRef<"Promotion", 'String'>
    readonly name: FieldRef<"Promotion", 'String'>
    readonly description: FieldRef<"Promotion", 'String'>
    readonly promotionType: FieldRef<"Promotion", 'String'>
    readonly termsAndConditions: FieldRef<"Promotion", 'String'>
    readonly startDate: FieldRef<"Promotion", 'DateTime'>
    readonly endDate: FieldRef<"Promotion", 'DateTime'>
    readonly active: FieldRef<"Promotion", 'Boolean'>
    readonly eligibilityCriteria: FieldRef<"Promotion", 'Json'>
    readonly createdAt: FieldRef<"Promotion", 'DateTime'>
    readonly updatedAt: FieldRef<"Promotion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Promotion findUnique
   */
  export type PromotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findUniqueOrThrow
   */
  export type PromotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findFirst
   */
  export type PromotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findFirstOrThrow
   */
  export type PromotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findMany
   */
  export type PromotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotions to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion create
   */
  export type PromotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to create a Promotion.
     */
    data: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
  }

  /**
   * Promotion createMany
   */
  export type PromotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promotion createManyAndReturn
   */
  export type PromotionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promotion update
   */
  export type PromotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to update a Promotion.
     */
    data: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
    /**
     * Choose, which Promotion to update.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion updateMany
   */
  export type PromotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to update.
     */
    limit?: number
  }

  /**
   * Promotion updateManyAndReturn
   */
  export type PromotionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to update.
     */
    limit?: number
  }

  /**
   * Promotion upsert
   */
  export type PromotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The filter to search for the Promotion to update in case it exists.
     */
    where: PromotionWhereUniqueInput
    /**
     * In case the Promotion found by the `where` argument doesn't exist, create a new Promotion with this data.
     */
    create: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
    /**
     * In case the Promotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
  }

  /**
   * Promotion delete
   */
  export type PromotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter which Promotion to delete.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion deleteMany
   */
  export type PromotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotions to delete
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to delete.
     */
    limit?: number
  }

  /**
   * Promotion.userBonuses
   */
  export type Promotion$userBonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBonus
     */
    omit?: UserBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    where?: UserBonusWhereInput
    orderBy?: UserBonusOrderByWithRelationInput | UserBonusOrderByWithRelationInput[]
    cursor?: UserBonusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBonusScalarFieldEnum | UserBonusScalarFieldEnum[]
  }

  /**
   * Promotion without action
   */
  export type PromotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
  }


  /**
   * Model UserBonus
   */

  export type AggregateUserBonus = {
    _count: UserBonusCountAggregateOutputType | null
    _avg: UserBonusAvgAggregateOutputType | null
    _sum: UserBonusSumAggregateOutputType | null
    _min: UserBonusMinAggregateOutputType | null
    _max: UserBonusMaxAggregateOutputType | null
  }

  export type UserBonusAvgAggregateOutputType = {
    bonusAmount: Decimal | null
    wageringRequirement: Decimal | null
    wageredAmount: Decimal | null
  }

  export type UserBonusSumAggregateOutputType = {
    bonusAmount: Decimal | null
    wageringRequirement: Decimal | null
    wageredAmount: Decimal | null
  }

  export type UserBonusMinAggregateOutputType = {
    id: string | null
    userId: string | null
    promotionId: string | null
    bonusAmount: Decimal | null
    wageringRequirement: Decimal | null
    wageredAmount: Decimal | null
    status: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserBonusMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    promotionId: string | null
    bonusAmount: Decimal | null
    wageringRequirement: Decimal | null
    wageredAmount: Decimal | null
    status: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserBonusCountAggregateOutputType = {
    id: number
    userId: number
    promotionId: number
    bonusAmount: number
    wageringRequirement: number
    wageredAmount: number
    status: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserBonusAvgAggregateInputType = {
    bonusAmount?: true
    wageringRequirement?: true
    wageredAmount?: true
  }

  export type UserBonusSumAggregateInputType = {
    bonusAmount?: true
    wageringRequirement?: true
    wageredAmount?: true
  }

  export type UserBonusMinAggregateInputType = {
    id?: true
    userId?: true
    promotionId?: true
    bonusAmount?: true
    wageringRequirement?: true
    wageredAmount?: true
    status?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserBonusMaxAggregateInputType = {
    id?: true
    userId?: true
    promotionId?: true
    bonusAmount?: true
    wageringRequirement?: true
    wageredAmount?: true
    status?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserBonusCountAggregateInputType = {
    id?: true
    userId?: true
    promotionId?: true
    bonusAmount?: true
    wageringRequirement?: true
    wageredAmount?: true
    status?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserBonusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBonus to aggregate.
     */
    where?: UserBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBonuses to fetch.
     */
    orderBy?: UserBonusOrderByWithRelationInput | UserBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBonuses
    **/
    _count?: true | UserBonusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserBonusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserBonusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBonusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBonusMaxAggregateInputType
  }

  export type GetUserBonusAggregateType<T extends UserBonusAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBonus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBonus[P]>
      : GetScalarType<T[P], AggregateUserBonus[P]>
  }




  export type UserBonusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBonusWhereInput
    orderBy?: UserBonusOrderByWithAggregationInput | UserBonusOrderByWithAggregationInput[]
    by: UserBonusScalarFieldEnum[] | UserBonusScalarFieldEnum
    having?: UserBonusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBonusCountAggregateInputType | true
    _avg?: UserBonusAvgAggregateInputType
    _sum?: UserBonusSumAggregateInputType
    _min?: UserBonusMinAggregateInputType
    _max?: UserBonusMaxAggregateInputType
  }

  export type UserBonusGroupByOutputType = {
    id: string
    userId: string
    promotionId: string
    bonusAmount: Decimal
    wageringRequirement: Decimal
    wageredAmount: Decimal
    status: string
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserBonusCountAggregateOutputType | null
    _avg: UserBonusAvgAggregateOutputType | null
    _sum: UserBonusSumAggregateOutputType | null
    _min: UserBonusMinAggregateOutputType | null
    _max: UserBonusMaxAggregateOutputType | null
  }

  type GetUserBonusGroupByPayload<T extends UserBonusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBonusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBonusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBonusGroupByOutputType[P]>
            : GetScalarType<T[P], UserBonusGroupByOutputType[P]>
        }
      >
    >


  export type UserBonusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    promotionId?: boolean
    bonusAmount?: boolean
    wageringRequirement?: boolean
    wageredAmount?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBonus"]>

  export type UserBonusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    promotionId?: boolean
    bonusAmount?: boolean
    wageringRequirement?: boolean
    wageredAmount?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBonus"]>

  export type UserBonusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    promotionId?: boolean
    bonusAmount?: boolean
    wageringRequirement?: boolean
    wageredAmount?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBonus"]>

  export type UserBonusSelectScalar = {
    id?: boolean
    userId?: boolean
    promotionId?: boolean
    bonusAmount?: boolean
    wageringRequirement?: boolean
    wageredAmount?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserBonusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "promotionId" | "bonusAmount" | "wageringRequirement" | "wageredAmount" | "status" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["userBonus"]>
  export type UserBonusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
  }
  export type UserBonusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
  }
  export type UserBonusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
  }

  export type $UserBonusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBonus"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      promotion: Prisma.$PromotionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      promotionId: string
      bonusAmount: Prisma.Decimal
      wageringRequirement: Prisma.Decimal
      wageredAmount: Prisma.Decimal
      status: string
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userBonus"]>
    composites: {}
  }

  type UserBonusGetPayload<S extends boolean | null | undefined | UserBonusDefaultArgs> = $Result.GetResult<Prisma.$UserBonusPayload, S>

  type UserBonusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserBonusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserBonusCountAggregateInputType | true
    }

  export interface UserBonusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBonus'], meta: { name: 'UserBonus' } }
    /**
     * Find zero or one UserBonus that matches the filter.
     * @param {UserBonusFindUniqueArgs} args - Arguments to find a UserBonus
     * @example
     * // Get one UserBonus
     * const userBonus = await prisma.userBonus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBonusFindUniqueArgs>(args: SelectSubset<T, UserBonusFindUniqueArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserBonus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserBonusFindUniqueOrThrowArgs} args - Arguments to find a UserBonus
     * @example
     * // Get one UserBonus
     * const userBonus = await prisma.userBonus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBonusFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBonusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBonus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBonusFindFirstArgs} args - Arguments to find a UserBonus
     * @example
     * // Get one UserBonus
     * const userBonus = await prisma.userBonus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBonusFindFirstArgs>(args?: SelectSubset<T, UserBonusFindFirstArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBonus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBonusFindFirstOrThrowArgs} args - Arguments to find a UserBonus
     * @example
     * // Get one UserBonus
     * const userBonus = await prisma.userBonus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBonusFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBonusFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserBonuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBonusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBonuses
     * const userBonuses = await prisma.userBonus.findMany()
     * 
     * // Get first 10 UserBonuses
     * const userBonuses = await prisma.userBonus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBonusWithIdOnly = await prisma.userBonus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserBonusFindManyArgs>(args?: SelectSubset<T, UserBonusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserBonus.
     * @param {UserBonusCreateArgs} args - Arguments to create a UserBonus.
     * @example
     * // Create one UserBonus
     * const UserBonus = await prisma.userBonus.create({
     *   data: {
     *     // ... data to create a UserBonus
     *   }
     * })
     * 
     */
    create<T extends UserBonusCreateArgs>(args: SelectSubset<T, UserBonusCreateArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserBonuses.
     * @param {UserBonusCreateManyArgs} args - Arguments to create many UserBonuses.
     * @example
     * // Create many UserBonuses
     * const userBonus = await prisma.userBonus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBonusCreateManyArgs>(args?: SelectSubset<T, UserBonusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBonuses and returns the data saved in the database.
     * @param {UserBonusCreateManyAndReturnArgs} args - Arguments to create many UserBonuses.
     * @example
     * // Create many UserBonuses
     * const userBonus = await prisma.userBonus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBonuses and only return the `id`
     * const userBonusWithIdOnly = await prisma.userBonus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBonusCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBonusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserBonus.
     * @param {UserBonusDeleteArgs} args - Arguments to delete one UserBonus.
     * @example
     * // Delete one UserBonus
     * const UserBonus = await prisma.userBonus.delete({
     *   where: {
     *     // ... filter to delete one UserBonus
     *   }
     * })
     * 
     */
    delete<T extends UserBonusDeleteArgs>(args: SelectSubset<T, UserBonusDeleteArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserBonus.
     * @param {UserBonusUpdateArgs} args - Arguments to update one UserBonus.
     * @example
     * // Update one UserBonus
     * const userBonus = await prisma.userBonus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBonusUpdateArgs>(args: SelectSubset<T, UserBonusUpdateArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserBonuses.
     * @param {UserBonusDeleteManyArgs} args - Arguments to filter UserBonuses to delete.
     * @example
     * // Delete a few UserBonuses
     * const { count } = await prisma.userBonus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBonusDeleteManyArgs>(args?: SelectSubset<T, UserBonusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBonusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBonuses
     * const userBonus = await prisma.userBonus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBonusUpdateManyArgs>(args: SelectSubset<T, UserBonusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBonuses and returns the data updated in the database.
     * @param {UserBonusUpdateManyAndReturnArgs} args - Arguments to update many UserBonuses.
     * @example
     * // Update many UserBonuses
     * const userBonus = await prisma.userBonus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserBonuses and only return the `id`
     * const userBonusWithIdOnly = await prisma.userBonus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserBonusUpdateManyAndReturnArgs>(args: SelectSubset<T, UserBonusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserBonus.
     * @param {UserBonusUpsertArgs} args - Arguments to update or create a UserBonus.
     * @example
     * // Update or create a UserBonus
     * const userBonus = await prisma.userBonus.upsert({
     *   create: {
     *     // ... data to create a UserBonus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBonus we want to update
     *   }
     * })
     */
    upsert<T extends UserBonusUpsertArgs>(args: SelectSubset<T, UserBonusUpsertArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBonusCountArgs} args - Arguments to filter UserBonuses to count.
     * @example
     * // Count the number of UserBonuses
     * const count = await prisma.userBonus.count({
     *   where: {
     *     // ... the filter for the UserBonuses we want to count
     *   }
     * })
    **/
    count<T extends UserBonusCountArgs>(
      args?: Subset<T, UserBonusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBonusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBonusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBonusAggregateArgs>(args: Subset<T, UserBonusAggregateArgs>): Prisma.PrismaPromise<GetUserBonusAggregateType<T>>

    /**
     * Group by UserBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBonusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBonusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBonusGroupByArgs['orderBy'] }
        : { orderBy?: UserBonusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBonusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBonusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBonus model
   */
  readonly fields: UserBonusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBonus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBonusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    promotion<T extends PromotionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PromotionDefaultArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBonus model
   */
  interface UserBonusFieldRefs {
    readonly id: FieldRef<"UserBonus", 'String'>
    readonly userId: FieldRef<"UserBonus", 'String'>
    readonly promotionId: FieldRef<"UserBonus", 'String'>
    readonly bonusAmount: FieldRef<"UserBonus", 'Decimal'>
    readonly wageringRequirement: FieldRef<"UserBonus", 'Decimal'>
    readonly wageredAmount: FieldRef<"UserBonus", 'Decimal'>
    readonly status: FieldRef<"UserBonus", 'String'>
    readonly expiresAt: FieldRef<"UserBonus", 'DateTime'>
    readonly createdAt: FieldRef<"UserBonus", 'DateTime'>
    readonly updatedAt: FieldRef<"UserBonus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserBonus findUnique
   */
  export type UserBonusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBonus
     */
    omit?: UserBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * Filter, which UserBonus to fetch.
     */
    where: UserBonusWhereUniqueInput
  }

  /**
   * UserBonus findUniqueOrThrow
   */
  export type UserBonusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBonus
     */
    omit?: UserBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * Filter, which UserBonus to fetch.
     */
    where: UserBonusWhereUniqueInput
  }

  /**
   * UserBonus findFirst
   */
  export type UserBonusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBonus
     */
    omit?: UserBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * Filter, which UserBonus to fetch.
     */
    where?: UserBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBonuses to fetch.
     */
    orderBy?: UserBonusOrderByWithRelationInput | UserBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBonuses.
     */
    cursor?: UserBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBonuses.
     */
    distinct?: UserBonusScalarFieldEnum | UserBonusScalarFieldEnum[]
  }

  /**
   * UserBonus findFirstOrThrow
   */
  export type UserBonusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBonus
     */
    omit?: UserBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * Filter, which UserBonus to fetch.
     */
    where?: UserBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBonuses to fetch.
     */
    orderBy?: UserBonusOrderByWithRelationInput | UserBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBonuses.
     */
    cursor?: UserBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBonuses.
     */
    distinct?: UserBonusScalarFieldEnum | UserBonusScalarFieldEnum[]
  }

  /**
   * UserBonus findMany
   */
  export type UserBonusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBonus
     */
    omit?: UserBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * Filter, which UserBonuses to fetch.
     */
    where?: UserBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBonuses to fetch.
     */
    orderBy?: UserBonusOrderByWithRelationInput | UserBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBonuses.
     */
    cursor?: UserBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBonuses.
     */
    skip?: number
    distinct?: UserBonusScalarFieldEnum | UserBonusScalarFieldEnum[]
  }

  /**
   * UserBonus create
   */
  export type UserBonusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBonus
     */
    omit?: UserBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBonus.
     */
    data: XOR<UserBonusCreateInput, UserBonusUncheckedCreateInput>
  }

  /**
   * UserBonus createMany
   */
  export type UserBonusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBonuses.
     */
    data: UserBonusCreateManyInput | UserBonusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserBonus createManyAndReturn
   */
  export type UserBonusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBonus
     */
    omit?: UserBonusOmit<ExtArgs> | null
    /**
     * The data used to create many UserBonuses.
     */
    data: UserBonusCreateManyInput | UserBonusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBonus update
   */
  export type UserBonusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBonus
     */
    omit?: UserBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBonus.
     */
    data: XOR<UserBonusUpdateInput, UserBonusUncheckedUpdateInput>
    /**
     * Choose, which UserBonus to update.
     */
    where: UserBonusWhereUniqueInput
  }

  /**
   * UserBonus updateMany
   */
  export type UserBonusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBonuses.
     */
    data: XOR<UserBonusUpdateManyMutationInput, UserBonusUncheckedUpdateManyInput>
    /**
     * Filter which UserBonuses to update
     */
    where?: UserBonusWhereInput
    /**
     * Limit how many UserBonuses to update.
     */
    limit?: number
  }

  /**
   * UserBonus updateManyAndReturn
   */
  export type UserBonusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBonus
     */
    omit?: UserBonusOmit<ExtArgs> | null
    /**
     * The data used to update UserBonuses.
     */
    data: XOR<UserBonusUpdateManyMutationInput, UserBonusUncheckedUpdateManyInput>
    /**
     * Filter which UserBonuses to update
     */
    where?: UserBonusWhereInput
    /**
     * Limit how many UserBonuses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBonus upsert
   */
  export type UserBonusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBonus
     */
    omit?: UserBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBonus to update in case it exists.
     */
    where: UserBonusWhereUniqueInput
    /**
     * In case the UserBonus found by the `where` argument doesn't exist, create a new UserBonus with this data.
     */
    create: XOR<UserBonusCreateInput, UserBonusUncheckedCreateInput>
    /**
     * In case the UserBonus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBonusUpdateInput, UserBonusUncheckedUpdateInput>
  }

  /**
   * UserBonus delete
   */
  export type UserBonusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBonus
     */
    omit?: UserBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * Filter which UserBonus to delete.
     */
    where: UserBonusWhereUniqueInput
  }

  /**
   * UserBonus deleteMany
   */
  export type UserBonusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBonuses to delete
     */
    where?: UserBonusWhereInput
    /**
     * Limit how many UserBonuses to delete.
     */
    limit?: number
  }

  /**
   * UserBonus without action
   */
  export type UserBonusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBonus
     */
    omit?: UserBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
  }


  /**
   * Model CurrentOdds
   */

  export type AggregateCurrentOdds = {
    _count: CurrentOddsCountAggregateOutputType | null
    _avg: CurrentOddsAvgAggregateOutputType | null
    _sum: CurrentOddsSumAggregateOutputType | null
    _min: CurrentOddsMinAggregateOutputType | null
    _max: CurrentOddsMaxAggregateOutputType | null
  }

  export type CurrentOddsAvgAggregateOutputType = {
    currentOdds: Decimal | null
    previousOdds: Decimal | null
  }

  export type CurrentOddsSumAggregateOutputType = {
    currentOdds: Decimal | null
    previousOdds: Decimal | null
  }

  export type CurrentOddsMinAggregateOutputType = {
    id: string | null
    selectionId: string | null
    currentOdds: Decimal | null
    previousOdds: Decimal | null
    oddsMovement: string | null
    lastUpdatedAt: Date | null
    syncedAt: Date | null
    externalOddsId: string | null
    suspended: boolean | null
  }

  export type CurrentOddsMaxAggregateOutputType = {
    id: string | null
    selectionId: string | null
    currentOdds: Decimal | null
    previousOdds: Decimal | null
    oddsMovement: string | null
    lastUpdatedAt: Date | null
    syncedAt: Date | null
    externalOddsId: string | null
    suspended: boolean | null
  }

  export type CurrentOddsCountAggregateOutputType = {
    id: number
    selectionId: number
    currentOdds: number
    previousOdds: number
    oddsMovement: number
    lastUpdatedAt: number
    syncedAt: number
    externalOddsId: number
    suspended: number
    _all: number
  }


  export type CurrentOddsAvgAggregateInputType = {
    currentOdds?: true
    previousOdds?: true
  }

  export type CurrentOddsSumAggregateInputType = {
    currentOdds?: true
    previousOdds?: true
  }

  export type CurrentOddsMinAggregateInputType = {
    id?: true
    selectionId?: true
    currentOdds?: true
    previousOdds?: true
    oddsMovement?: true
    lastUpdatedAt?: true
    syncedAt?: true
    externalOddsId?: true
    suspended?: true
  }

  export type CurrentOddsMaxAggregateInputType = {
    id?: true
    selectionId?: true
    currentOdds?: true
    previousOdds?: true
    oddsMovement?: true
    lastUpdatedAt?: true
    syncedAt?: true
    externalOddsId?: true
    suspended?: true
  }

  export type CurrentOddsCountAggregateInputType = {
    id?: true
    selectionId?: true
    currentOdds?: true
    previousOdds?: true
    oddsMovement?: true
    lastUpdatedAt?: true
    syncedAt?: true
    externalOddsId?: true
    suspended?: true
    _all?: true
  }

  export type CurrentOddsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CurrentOdds to aggregate.
     */
    where?: CurrentOddsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrentOdds to fetch.
     */
    orderBy?: CurrentOddsOrderByWithRelationInput | CurrentOddsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurrentOddsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrentOdds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrentOdds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CurrentOdds
    **/
    _count?: true | CurrentOddsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CurrentOddsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CurrentOddsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrentOddsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrentOddsMaxAggregateInputType
  }

  export type GetCurrentOddsAggregateType<T extends CurrentOddsAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrentOdds]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrentOdds[P]>
      : GetScalarType<T[P], AggregateCurrentOdds[P]>
  }




  export type CurrentOddsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrentOddsWhereInput
    orderBy?: CurrentOddsOrderByWithAggregationInput | CurrentOddsOrderByWithAggregationInput[]
    by: CurrentOddsScalarFieldEnum[] | CurrentOddsScalarFieldEnum
    having?: CurrentOddsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrentOddsCountAggregateInputType | true
    _avg?: CurrentOddsAvgAggregateInputType
    _sum?: CurrentOddsSumAggregateInputType
    _min?: CurrentOddsMinAggregateInputType
    _max?: CurrentOddsMaxAggregateInputType
  }

  export type CurrentOddsGroupByOutputType = {
    id: string
    selectionId: string
    currentOdds: Decimal
    previousOdds: Decimal | null
    oddsMovement: string | null
    lastUpdatedAt: Date
    syncedAt: Date
    externalOddsId: string | null
    suspended: boolean
    _count: CurrentOddsCountAggregateOutputType | null
    _avg: CurrentOddsAvgAggregateOutputType | null
    _sum: CurrentOddsSumAggregateOutputType | null
    _min: CurrentOddsMinAggregateOutputType | null
    _max: CurrentOddsMaxAggregateOutputType | null
  }

  type GetCurrentOddsGroupByPayload<T extends CurrentOddsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurrentOddsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrentOddsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrentOddsGroupByOutputType[P]>
            : GetScalarType<T[P], CurrentOddsGroupByOutputType[P]>
        }
      >
    >


  export type CurrentOddsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    selectionId?: boolean
    currentOdds?: boolean
    previousOdds?: boolean
    oddsMovement?: boolean
    lastUpdatedAt?: boolean
    syncedAt?: boolean
    externalOddsId?: boolean
    suspended?: boolean
    selection?: boolean | BetSelectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["currentOdds"]>

  export type CurrentOddsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    selectionId?: boolean
    currentOdds?: boolean
    previousOdds?: boolean
    oddsMovement?: boolean
    lastUpdatedAt?: boolean
    syncedAt?: boolean
    externalOddsId?: boolean
    suspended?: boolean
    selection?: boolean | BetSelectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["currentOdds"]>

  export type CurrentOddsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    selectionId?: boolean
    currentOdds?: boolean
    previousOdds?: boolean
    oddsMovement?: boolean
    lastUpdatedAt?: boolean
    syncedAt?: boolean
    externalOddsId?: boolean
    suspended?: boolean
    selection?: boolean | BetSelectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["currentOdds"]>

  export type CurrentOddsSelectScalar = {
    id?: boolean
    selectionId?: boolean
    currentOdds?: boolean
    previousOdds?: boolean
    oddsMovement?: boolean
    lastUpdatedAt?: boolean
    syncedAt?: boolean
    externalOddsId?: boolean
    suspended?: boolean
  }

  export type CurrentOddsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "selectionId" | "currentOdds" | "previousOdds" | "oddsMovement" | "lastUpdatedAt" | "syncedAt" | "externalOddsId" | "suspended", ExtArgs["result"]["currentOdds"]>
  export type CurrentOddsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    selection?: boolean | BetSelectionDefaultArgs<ExtArgs>
  }
  export type CurrentOddsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    selection?: boolean | BetSelectionDefaultArgs<ExtArgs>
  }
  export type CurrentOddsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    selection?: boolean | BetSelectionDefaultArgs<ExtArgs>
  }

  export type $CurrentOddsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CurrentOdds"
    objects: {
      selection: Prisma.$BetSelectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      selectionId: string
      currentOdds: Prisma.Decimal
      previousOdds: Prisma.Decimal | null
      oddsMovement: string | null
      lastUpdatedAt: Date
      syncedAt: Date
      externalOddsId: string | null
      suspended: boolean
    }, ExtArgs["result"]["currentOdds"]>
    composites: {}
  }

  type CurrentOddsGetPayload<S extends boolean | null | undefined | CurrentOddsDefaultArgs> = $Result.GetResult<Prisma.$CurrentOddsPayload, S>

  type CurrentOddsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CurrentOddsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CurrentOddsCountAggregateInputType | true
    }

  export interface CurrentOddsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CurrentOdds'], meta: { name: 'CurrentOdds' } }
    /**
     * Find zero or one CurrentOdds that matches the filter.
     * @param {CurrentOddsFindUniqueArgs} args - Arguments to find a CurrentOdds
     * @example
     * // Get one CurrentOdds
     * const currentOdds = await prisma.currentOdds.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CurrentOddsFindUniqueArgs>(args: SelectSubset<T, CurrentOddsFindUniqueArgs<ExtArgs>>): Prisma__CurrentOddsClient<$Result.GetResult<Prisma.$CurrentOddsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CurrentOdds that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CurrentOddsFindUniqueOrThrowArgs} args - Arguments to find a CurrentOdds
     * @example
     * // Get one CurrentOdds
     * const currentOdds = await prisma.currentOdds.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CurrentOddsFindUniqueOrThrowArgs>(args: SelectSubset<T, CurrentOddsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CurrentOddsClient<$Result.GetResult<Prisma.$CurrentOddsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CurrentOdds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentOddsFindFirstArgs} args - Arguments to find a CurrentOdds
     * @example
     * // Get one CurrentOdds
     * const currentOdds = await prisma.currentOdds.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CurrentOddsFindFirstArgs>(args?: SelectSubset<T, CurrentOddsFindFirstArgs<ExtArgs>>): Prisma__CurrentOddsClient<$Result.GetResult<Prisma.$CurrentOddsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CurrentOdds that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentOddsFindFirstOrThrowArgs} args - Arguments to find a CurrentOdds
     * @example
     * // Get one CurrentOdds
     * const currentOdds = await prisma.currentOdds.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CurrentOddsFindFirstOrThrowArgs>(args?: SelectSubset<T, CurrentOddsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CurrentOddsClient<$Result.GetResult<Prisma.$CurrentOddsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CurrentOdds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentOddsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CurrentOdds
     * const currentOdds = await prisma.currentOdds.findMany()
     * 
     * // Get first 10 CurrentOdds
     * const currentOdds = await prisma.currentOdds.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const currentOddsWithIdOnly = await prisma.currentOdds.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CurrentOddsFindManyArgs>(args?: SelectSubset<T, CurrentOddsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrentOddsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CurrentOdds.
     * @param {CurrentOddsCreateArgs} args - Arguments to create a CurrentOdds.
     * @example
     * // Create one CurrentOdds
     * const CurrentOdds = await prisma.currentOdds.create({
     *   data: {
     *     // ... data to create a CurrentOdds
     *   }
     * })
     * 
     */
    create<T extends CurrentOddsCreateArgs>(args: SelectSubset<T, CurrentOddsCreateArgs<ExtArgs>>): Prisma__CurrentOddsClient<$Result.GetResult<Prisma.$CurrentOddsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CurrentOdds.
     * @param {CurrentOddsCreateManyArgs} args - Arguments to create many CurrentOdds.
     * @example
     * // Create many CurrentOdds
     * const currentOdds = await prisma.currentOdds.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CurrentOddsCreateManyArgs>(args?: SelectSubset<T, CurrentOddsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CurrentOdds and returns the data saved in the database.
     * @param {CurrentOddsCreateManyAndReturnArgs} args - Arguments to create many CurrentOdds.
     * @example
     * // Create many CurrentOdds
     * const currentOdds = await prisma.currentOdds.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CurrentOdds and only return the `id`
     * const currentOddsWithIdOnly = await prisma.currentOdds.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CurrentOddsCreateManyAndReturnArgs>(args?: SelectSubset<T, CurrentOddsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrentOddsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CurrentOdds.
     * @param {CurrentOddsDeleteArgs} args - Arguments to delete one CurrentOdds.
     * @example
     * // Delete one CurrentOdds
     * const CurrentOdds = await prisma.currentOdds.delete({
     *   where: {
     *     // ... filter to delete one CurrentOdds
     *   }
     * })
     * 
     */
    delete<T extends CurrentOddsDeleteArgs>(args: SelectSubset<T, CurrentOddsDeleteArgs<ExtArgs>>): Prisma__CurrentOddsClient<$Result.GetResult<Prisma.$CurrentOddsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CurrentOdds.
     * @param {CurrentOddsUpdateArgs} args - Arguments to update one CurrentOdds.
     * @example
     * // Update one CurrentOdds
     * const currentOdds = await prisma.currentOdds.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CurrentOddsUpdateArgs>(args: SelectSubset<T, CurrentOddsUpdateArgs<ExtArgs>>): Prisma__CurrentOddsClient<$Result.GetResult<Prisma.$CurrentOddsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CurrentOdds.
     * @param {CurrentOddsDeleteManyArgs} args - Arguments to filter CurrentOdds to delete.
     * @example
     * // Delete a few CurrentOdds
     * const { count } = await prisma.currentOdds.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CurrentOddsDeleteManyArgs>(args?: SelectSubset<T, CurrentOddsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CurrentOdds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentOddsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CurrentOdds
     * const currentOdds = await prisma.currentOdds.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CurrentOddsUpdateManyArgs>(args: SelectSubset<T, CurrentOddsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CurrentOdds and returns the data updated in the database.
     * @param {CurrentOddsUpdateManyAndReturnArgs} args - Arguments to update many CurrentOdds.
     * @example
     * // Update many CurrentOdds
     * const currentOdds = await prisma.currentOdds.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CurrentOdds and only return the `id`
     * const currentOddsWithIdOnly = await prisma.currentOdds.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CurrentOddsUpdateManyAndReturnArgs>(args: SelectSubset<T, CurrentOddsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrentOddsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CurrentOdds.
     * @param {CurrentOddsUpsertArgs} args - Arguments to update or create a CurrentOdds.
     * @example
     * // Update or create a CurrentOdds
     * const currentOdds = await prisma.currentOdds.upsert({
     *   create: {
     *     // ... data to create a CurrentOdds
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CurrentOdds we want to update
     *   }
     * })
     */
    upsert<T extends CurrentOddsUpsertArgs>(args: SelectSubset<T, CurrentOddsUpsertArgs<ExtArgs>>): Prisma__CurrentOddsClient<$Result.GetResult<Prisma.$CurrentOddsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CurrentOdds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentOddsCountArgs} args - Arguments to filter CurrentOdds to count.
     * @example
     * // Count the number of CurrentOdds
     * const count = await prisma.currentOdds.count({
     *   where: {
     *     // ... the filter for the CurrentOdds we want to count
     *   }
     * })
    **/
    count<T extends CurrentOddsCountArgs>(
      args?: Subset<T, CurrentOddsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrentOddsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CurrentOdds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentOddsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrentOddsAggregateArgs>(args: Subset<T, CurrentOddsAggregateArgs>): Prisma.PrismaPromise<GetCurrentOddsAggregateType<T>>

    /**
     * Group by CurrentOdds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentOddsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurrentOddsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurrentOddsGroupByArgs['orderBy'] }
        : { orderBy?: CurrentOddsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurrentOddsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrentOddsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CurrentOdds model
   */
  readonly fields: CurrentOddsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CurrentOdds.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CurrentOddsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    selection<T extends BetSelectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BetSelectionDefaultArgs<ExtArgs>>): Prisma__BetSelectionClient<$Result.GetResult<Prisma.$BetSelectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CurrentOdds model
   */
  interface CurrentOddsFieldRefs {
    readonly id: FieldRef<"CurrentOdds", 'String'>
    readonly selectionId: FieldRef<"CurrentOdds", 'String'>
    readonly currentOdds: FieldRef<"CurrentOdds", 'Decimal'>
    readonly previousOdds: FieldRef<"CurrentOdds", 'Decimal'>
    readonly oddsMovement: FieldRef<"CurrentOdds", 'String'>
    readonly lastUpdatedAt: FieldRef<"CurrentOdds", 'DateTime'>
    readonly syncedAt: FieldRef<"CurrentOdds", 'DateTime'>
    readonly externalOddsId: FieldRef<"CurrentOdds", 'String'>
    readonly suspended: FieldRef<"CurrentOdds", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * CurrentOdds findUnique
   */
  export type CurrentOddsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentOdds
     */
    select?: CurrentOddsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentOdds
     */
    omit?: CurrentOddsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentOddsInclude<ExtArgs> | null
    /**
     * Filter, which CurrentOdds to fetch.
     */
    where: CurrentOddsWhereUniqueInput
  }

  /**
   * CurrentOdds findUniqueOrThrow
   */
  export type CurrentOddsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentOdds
     */
    select?: CurrentOddsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentOdds
     */
    omit?: CurrentOddsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentOddsInclude<ExtArgs> | null
    /**
     * Filter, which CurrentOdds to fetch.
     */
    where: CurrentOddsWhereUniqueInput
  }

  /**
   * CurrentOdds findFirst
   */
  export type CurrentOddsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentOdds
     */
    select?: CurrentOddsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentOdds
     */
    omit?: CurrentOddsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentOddsInclude<ExtArgs> | null
    /**
     * Filter, which CurrentOdds to fetch.
     */
    where?: CurrentOddsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrentOdds to fetch.
     */
    orderBy?: CurrentOddsOrderByWithRelationInput | CurrentOddsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CurrentOdds.
     */
    cursor?: CurrentOddsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrentOdds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrentOdds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CurrentOdds.
     */
    distinct?: CurrentOddsScalarFieldEnum | CurrentOddsScalarFieldEnum[]
  }

  /**
   * CurrentOdds findFirstOrThrow
   */
  export type CurrentOddsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentOdds
     */
    select?: CurrentOddsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentOdds
     */
    omit?: CurrentOddsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentOddsInclude<ExtArgs> | null
    /**
     * Filter, which CurrentOdds to fetch.
     */
    where?: CurrentOddsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrentOdds to fetch.
     */
    orderBy?: CurrentOddsOrderByWithRelationInput | CurrentOddsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CurrentOdds.
     */
    cursor?: CurrentOddsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrentOdds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrentOdds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CurrentOdds.
     */
    distinct?: CurrentOddsScalarFieldEnum | CurrentOddsScalarFieldEnum[]
  }

  /**
   * CurrentOdds findMany
   */
  export type CurrentOddsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentOdds
     */
    select?: CurrentOddsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentOdds
     */
    omit?: CurrentOddsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentOddsInclude<ExtArgs> | null
    /**
     * Filter, which CurrentOdds to fetch.
     */
    where?: CurrentOddsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrentOdds to fetch.
     */
    orderBy?: CurrentOddsOrderByWithRelationInput | CurrentOddsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CurrentOdds.
     */
    cursor?: CurrentOddsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrentOdds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrentOdds.
     */
    skip?: number
    distinct?: CurrentOddsScalarFieldEnum | CurrentOddsScalarFieldEnum[]
  }

  /**
   * CurrentOdds create
   */
  export type CurrentOddsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentOdds
     */
    select?: CurrentOddsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentOdds
     */
    omit?: CurrentOddsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentOddsInclude<ExtArgs> | null
    /**
     * The data needed to create a CurrentOdds.
     */
    data: XOR<CurrentOddsCreateInput, CurrentOddsUncheckedCreateInput>
  }

  /**
   * CurrentOdds createMany
   */
  export type CurrentOddsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CurrentOdds.
     */
    data: CurrentOddsCreateManyInput | CurrentOddsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CurrentOdds createManyAndReturn
   */
  export type CurrentOddsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentOdds
     */
    select?: CurrentOddsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentOdds
     */
    omit?: CurrentOddsOmit<ExtArgs> | null
    /**
     * The data used to create many CurrentOdds.
     */
    data: CurrentOddsCreateManyInput | CurrentOddsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentOddsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CurrentOdds update
   */
  export type CurrentOddsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentOdds
     */
    select?: CurrentOddsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentOdds
     */
    omit?: CurrentOddsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentOddsInclude<ExtArgs> | null
    /**
     * The data needed to update a CurrentOdds.
     */
    data: XOR<CurrentOddsUpdateInput, CurrentOddsUncheckedUpdateInput>
    /**
     * Choose, which CurrentOdds to update.
     */
    where: CurrentOddsWhereUniqueInput
  }

  /**
   * CurrentOdds updateMany
   */
  export type CurrentOddsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CurrentOdds.
     */
    data: XOR<CurrentOddsUpdateManyMutationInput, CurrentOddsUncheckedUpdateManyInput>
    /**
     * Filter which CurrentOdds to update
     */
    where?: CurrentOddsWhereInput
    /**
     * Limit how many CurrentOdds to update.
     */
    limit?: number
  }

  /**
   * CurrentOdds updateManyAndReturn
   */
  export type CurrentOddsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentOdds
     */
    select?: CurrentOddsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentOdds
     */
    omit?: CurrentOddsOmit<ExtArgs> | null
    /**
     * The data used to update CurrentOdds.
     */
    data: XOR<CurrentOddsUpdateManyMutationInput, CurrentOddsUncheckedUpdateManyInput>
    /**
     * Filter which CurrentOdds to update
     */
    where?: CurrentOddsWhereInput
    /**
     * Limit how many CurrentOdds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentOddsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CurrentOdds upsert
   */
  export type CurrentOddsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentOdds
     */
    select?: CurrentOddsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentOdds
     */
    omit?: CurrentOddsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentOddsInclude<ExtArgs> | null
    /**
     * The filter to search for the CurrentOdds to update in case it exists.
     */
    where: CurrentOddsWhereUniqueInput
    /**
     * In case the CurrentOdds found by the `where` argument doesn't exist, create a new CurrentOdds with this data.
     */
    create: XOR<CurrentOddsCreateInput, CurrentOddsUncheckedCreateInput>
    /**
     * In case the CurrentOdds was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurrentOddsUpdateInput, CurrentOddsUncheckedUpdateInput>
  }

  /**
   * CurrentOdds delete
   */
  export type CurrentOddsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentOdds
     */
    select?: CurrentOddsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentOdds
     */
    omit?: CurrentOddsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentOddsInclude<ExtArgs> | null
    /**
     * Filter which CurrentOdds to delete.
     */
    where: CurrentOddsWhereUniqueInput
  }

  /**
   * CurrentOdds deleteMany
   */
  export type CurrentOddsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CurrentOdds to delete
     */
    where?: CurrentOddsWhereInput
    /**
     * Limit how many CurrentOdds to delete.
     */
    limit?: number
  }

  /**
   * CurrentOdds without action
   */
  export type CurrentOddsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentOdds
     */
    select?: CurrentOddsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentOdds
     */
    omit?: CurrentOddsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentOddsInclude<ExtArgs> | null
  }


  /**
   * Model OddsSnapshot
   */

  export type AggregateOddsSnapshot = {
    _count: OddsSnapshotCountAggregateOutputType | null
    _avg: OddsSnapshotAvgAggregateOutputType | null
    _sum: OddsSnapshotSumAggregateOutputType | null
    _min: OddsSnapshotMinAggregateOutputType | null
    _max: OddsSnapshotMaxAggregateOutputType | null
  }

  export type OddsSnapshotAvgAggregateOutputType = {
    odds: Decimal | null
  }

  export type OddsSnapshotSumAggregateOutputType = {
    odds: Decimal | null
  }

  export type OddsSnapshotMinAggregateOutputType = {
    id: string | null
    selectionId: string | null
    odds: Decimal | null
    timestamp: Date | null
    source: string | null
  }

  export type OddsSnapshotMaxAggregateOutputType = {
    id: string | null
    selectionId: string | null
    odds: Decimal | null
    timestamp: Date | null
    source: string | null
  }

  export type OddsSnapshotCountAggregateOutputType = {
    id: number
    selectionId: number
    odds: number
    timestamp: number
    source: number
    metadata: number
    _all: number
  }


  export type OddsSnapshotAvgAggregateInputType = {
    odds?: true
  }

  export type OddsSnapshotSumAggregateInputType = {
    odds?: true
  }

  export type OddsSnapshotMinAggregateInputType = {
    id?: true
    selectionId?: true
    odds?: true
    timestamp?: true
    source?: true
  }

  export type OddsSnapshotMaxAggregateInputType = {
    id?: true
    selectionId?: true
    odds?: true
    timestamp?: true
    source?: true
  }

  export type OddsSnapshotCountAggregateInputType = {
    id?: true
    selectionId?: true
    odds?: true
    timestamp?: true
    source?: true
    metadata?: true
    _all?: true
  }

  export type OddsSnapshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OddsSnapshot to aggregate.
     */
    where?: OddsSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OddsSnapshots to fetch.
     */
    orderBy?: OddsSnapshotOrderByWithRelationInput | OddsSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OddsSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OddsSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OddsSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OddsSnapshots
    **/
    _count?: true | OddsSnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OddsSnapshotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OddsSnapshotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OddsSnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OddsSnapshotMaxAggregateInputType
  }

  export type GetOddsSnapshotAggregateType<T extends OddsSnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregateOddsSnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOddsSnapshot[P]>
      : GetScalarType<T[P], AggregateOddsSnapshot[P]>
  }




  export type OddsSnapshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OddsSnapshotWhereInput
    orderBy?: OddsSnapshotOrderByWithAggregationInput | OddsSnapshotOrderByWithAggregationInput[]
    by: OddsSnapshotScalarFieldEnum[] | OddsSnapshotScalarFieldEnum
    having?: OddsSnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OddsSnapshotCountAggregateInputType | true
    _avg?: OddsSnapshotAvgAggregateInputType
    _sum?: OddsSnapshotSumAggregateInputType
    _min?: OddsSnapshotMinAggregateInputType
    _max?: OddsSnapshotMaxAggregateInputType
  }

  export type OddsSnapshotGroupByOutputType = {
    id: string
    selectionId: string
    odds: Decimal
    timestamp: Date
    source: string
    metadata: JsonValue | null
    _count: OddsSnapshotCountAggregateOutputType | null
    _avg: OddsSnapshotAvgAggregateOutputType | null
    _sum: OddsSnapshotSumAggregateOutputType | null
    _min: OddsSnapshotMinAggregateOutputType | null
    _max: OddsSnapshotMaxAggregateOutputType | null
  }

  type GetOddsSnapshotGroupByPayload<T extends OddsSnapshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OddsSnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OddsSnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OddsSnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], OddsSnapshotGroupByOutputType[P]>
        }
      >
    >


  export type OddsSnapshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    selectionId?: boolean
    odds?: boolean
    timestamp?: boolean
    source?: boolean
    metadata?: boolean
    selection?: boolean | BetSelectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oddsSnapshot"]>

  export type OddsSnapshotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    selectionId?: boolean
    odds?: boolean
    timestamp?: boolean
    source?: boolean
    metadata?: boolean
    selection?: boolean | BetSelectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oddsSnapshot"]>

  export type OddsSnapshotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    selectionId?: boolean
    odds?: boolean
    timestamp?: boolean
    source?: boolean
    metadata?: boolean
    selection?: boolean | BetSelectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oddsSnapshot"]>

  export type OddsSnapshotSelectScalar = {
    id?: boolean
    selectionId?: boolean
    odds?: boolean
    timestamp?: boolean
    source?: boolean
    metadata?: boolean
  }

  export type OddsSnapshotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "selectionId" | "odds" | "timestamp" | "source" | "metadata", ExtArgs["result"]["oddsSnapshot"]>
  export type OddsSnapshotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    selection?: boolean | BetSelectionDefaultArgs<ExtArgs>
  }
  export type OddsSnapshotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    selection?: boolean | BetSelectionDefaultArgs<ExtArgs>
  }
  export type OddsSnapshotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    selection?: boolean | BetSelectionDefaultArgs<ExtArgs>
  }

  export type $OddsSnapshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OddsSnapshot"
    objects: {
      selection: Prisma.$BetSelectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      selectionId: string
      odds: Prisma.Decimal
      timestamp: Date
      source: string
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["oddsSnapshot"]>
    composites: {}
  }

  type OddsSnapshotGetPayload<S extends boolean | null | undefined | OddsSnapshotDefaultArgs> = $Result.GetResult<Prisma.$OddsSnapshotPayload, S>

  type OddsSnapshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OddsSnapshotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OddsSnapshotCountAggregateInputType | true
    }

  export interface OddsSnapshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OddsSnapshot'], meta: { name: 'OddsSnapshot' } }
    /**
     * Find zero or one OddsSnapshot that matches the filter.
     * @param {OddsSnapshotFindUniqueArgs} args - Arguments to find a OddsSnapshot
     * @example
     * // Get one OddsSnapshot
     * const oddsSnapshot = await prisma.oddsSnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OddsSnapshotFindUniqueArgs>(args: SelectSubset<T, OddsSnapshotFindUniqueArgs<ExtArgs>>): Prisma__OddsSnapshotClient<$Result.GetResult<Prisma.$OddsSnapshotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OddsSnapshot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OddsSnapshotFindUniqueOrThrowArgs} args - Arguments to find a OddsSnapshot
     * @example
     * // Get one OddsSnapshot
     * const oddsSnapshot = await prisma.oddsSnapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OddsSnapshotFindUniqueOrThrowArgs>(args: SelectSubset<T, OddsSnapshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OddsSnapshotClient<$Result.GetResult<Prisma.$OddsSnapshotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OddsSnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsSnapshotFindFirstArgs} args - Arguments to find a OddsSnapshot
     * @example
     * // Get one OddsSnapshot
     * const oddsSnapshot = await prisma.oddsSnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OddsSnapshotFindFirstArgs>(args?: SelectSubset<T, OddsSnapshotFindFirstArgs<ExtArgs>>): Prisma__OddsSnapshotClient<$Result.GetResult<Prisma.$OddsSnapshotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OddsSnapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsSnapshotFindFirstOrThrowArgs} args - Arguments to find a OddsSnapshot
     * @example
     * // Get one OddsSnapshot
     * const oddsSnapshot = await prisma.oddsSnapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OddsSnapshotFindFirstOrThrowArgs>(args?: SelectSubset<T, OddsSnapshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__OddsSnapshotClient<$Result.GetResult<Prisma.$OddsSnapshotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OddsSnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsSnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OddsSnapshots
     * const oddsSnapshots = await prisma.oddsSnapshot.findMany()
     * 
     * // Get first 10 OddsSnapshots
     * const oddsSnapshots = await prisma.oddsSnapshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oddsSnapshotWithIdOnly = await prisma.oddsSnapshot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OddsSnapshotFindManyArgs>(args?: SelectSubset<T, OddsSnapshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OddsSnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OddsSnapshot.
     * @param {OddsSnapshotCreateArgs} args - Arguments to create a OddsSnapshot.
     * @example
     * // Create one OddsSnapshot
     * const OddsSnapshot = await prisma.oddsSnapshot.create({
     *   data: {
     *     // ... data to create a OddsSnapshot
     *   }
     * })
     * 
     */
    create<T extends OddsSnapshotCreateArgs>(args: SelectSubset<T, OddsSnapshotCreateArgs<ExtArgs>>): Prisma__OddsSnapshotClient<$Result.GetResult<Prisma.$OddsSnapshotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OddsSnapshots.
     * @param {OddsSnapshotCreateManyArgs} args - Arguments to create many OddsSnapshots.
     * @example
     * // Create many OddsSnapshots
     * const oddsSnapshot = await prisma.oddsSnapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OddsSnapshotCreateManyArgs>(args?: SelectSubset<T, OddsSnapshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OddsSnapshots and returns the data saved in the database.
     * @param {OddsSnapshotCreateManyAndReturnArgs} args - Arguments to create many OddsSnapshots.
     * @example
     * // Create many OddsSnapshots
     * const oddsSnapshot = await prisma.oddsSnapshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OddsSnapshots and only return the `id`
     * const oddsSnapshotWithIdOnly = await prisma.oddsSnapshot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OddsSnapshotCreateManyAndReturnArgs>(args?: SelectSubset<T, OddsSnapshotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OddsSnapshotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OddsSnapshot.
     * @param {OddsSnapshotDeleteArgs} args - Arguments to delete one OddsSnapshot.
     * @example
     * // Delete one OddsSnapshot
     * const OddsSnapshot = await prisma.oddsSnapshot.delete({
     *   where: {
     *     // ... filter to delete one OddsSnapshot
     *   }
     * })
     * 
     */
    delete<T extends OddsSnapshotDeleteArgs>(args: SelectSubset<T, OddsSnapshotDeleteArgs<ExtArgs>>): Prisma__OddsSnapshotClient<$Result.GetResult<Prisma.$OddsSnapshotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OddsSnapshot.
     * @param {OddsSnapshotUpdateArgs} args - Arguments to update one OddsSnapshot.
     * @example
     * // Update one OddsSnapshot
     * const oddsSnapshot = await prisma.oddsSnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OddsSnapshotUpdateArgs>(args: SelectSubset<T, OddsSnapshotUpdateArgs<ExtArgs>>): Prisma__OddsSnapshotClient<$Result.GetResult<Prisma.$OddsSnapshotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OddsSnapshots.
     * @param {OddsSnapshotDeleteManyArgs} args - Arguments to filter OddsSnapshots to delete.
     * @example
     * // Delete a few OddsSnapshots
     * const { count } = await prisma.oddsSnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OddsSnapshotDeleteManyArgs>(args?: SelectSubset<T, OddsSnapshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OddsSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsSnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OddsSnapshots
     * const oddsSnapshot = await prisma.oddsSnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OddsSnapshotUpdateManyArgs>(args: SelectSubset<T, OddsSnapshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OddsSnapshots and returns the data updated in the database.
     * @param {OddsSnapshotUpdateManyAndReturnArgs} args - Arguments to update many OddsSnapshots.
     * @example
     * // Update many OddsSnapshots
     * const oddsSnapshot = await prisma.oddsSnapshot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OddsSnapshots and only return the `id`
     * const oddsSnapshotWithIdOnly = await prisma.oddsSnapshot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OddsSnapshotUpdateManyAndReturnArgs>(args: SelectSubset<T, OddsSnapshotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OddsSnapshotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OddsSnapshot.
     * @param {OddsSnapshotUpsertArgs} args - Arguments to update or create a OddsSnapshot.
     * @example
     * // Update or create a OddsSnapshot
     * const oddsSnapshot = await prisma.oddsSnapshot.upsert({
     *   create: {
     *     // ... data to create a OddsSnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OddsSnapshot we want to update
     *   }
     * })
     */
    upsert<T extends OddsSnapshotUpsertArgs>(args: SelectSubset<T, OddsSnapshotUpsertArgs<ExtArgs>>): Prisma__OddsSnapshotClient<$Result.GetResult<Prisma.$OddsSnapshotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OddsSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsSnapshotCountArgs} args - Arguments to filter OddsSnapshots to count.
     * @example
     * // Count the number of OddsSnapshots
     * const count = await prisma.oddsSnapshot.count({
     *   where: {
     *     // ... the filter for the OddsSnapshots we want to count
     *   }
     * })
    **/
    count<T extends OddsSnapshotCountArgs>(
      args?: Subset<T, OddsSnapshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OddsSnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OddsSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsSnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OddsSnapshotAggregateArgs>(args: Subset<T, OddsSnapshotAggregateArgs>): Prisma.PrismaPromise<GetOddsSnapshotAggregateType<T>>

    /**
     * Group by OddsSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsSnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OddsSnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OddsSnapshotGroupByArgs['orderBy'] }
        : { orderBy?: OddsSnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OddsSnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOddsSnapshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OddsSnapshot model
   */
  readonly fields: OddsSnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OddsSnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OddsSnapshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    selection<T extends BetSelectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BetSelectionDefaultArgs<ExtArgs>>): Prisma__BetSelectionClient<$Result.GetResult<Prisma.$BetSelectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OddsSnapshot model
   */
  interface OddsSnapshotFieldRefs {
    readonly id: FieldRef<"OddsSnapshot", 'String'>
    readonly selectionId: FieldRef<"OddsSnapshot", 'String'>
    readonly odds: FieldRef<"OddsSnapshot", 'Decimal'>
    readonly timestamp: FieldRef<"OddsSnapshot", 'DateTime'>
    readonly source: FieldRef<"OddsSnapshot", 'String'>
    readonly metadata: FieldRef<"OddsSnapshot", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * OddsSnapshot findUnique
   */
  export type OddsSnapshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSnapshot
     */
    select?: OddsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSnapshot
     */
    omit?: OddsSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which OddsSnapshot to fetch.
     */
    where: OddsSnapshotWhereUniqueInput
  }

  /**
   * OddsSnapshot findUniqueOrThrow
   */
  export type OddsSnapshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSnapshot
     */
    select?: OddsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSnapshot
     */
    omit?: OddsSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which OddsSnapshot to fetch.
     */
    where: OddsSnapshotWhereUniqueInput
  }

  /**
   * OddsSnapshot findFirst
   */
  export type OddsSnapshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSnapshot
     */
    select?: OddsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSnapshot
     */
    omit?: OddsSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which OddsSnapshot to fetch.
     */
    where?: OddsSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OddsSnapshots to fetch.
     */
    orderBy?: OddsSnapshotOrderByWithRelationInput | OddsSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OddsSnapshots.
     */
    cursor?: OddsSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OddsSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OddsSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OddsSnapshots.
     */
    distinct?: OddsSnapshotScalarFieldEnum | OddsSnapshotScalarFieldEnum[]
  }

  /**
   * OddsSnapshot findFirstOrThrow
   */
  export type OddsSnapshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSnapshot
     */
    select?: OddsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSnapshot
     */
    omit?: OddsSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which OddsSnapshot to fetch.
     */
    where?: OddsSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OddsSnapshots to fetch.
     */
    orderBy?: OddsSnapshotOrderByWithRelationInput | OddsSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OddsSnapshots.
     */
    cursor?: OddsSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OddsSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OddsSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OddsSnapshots.
     */
    distinct?: OddsSnapshotScalarFieldEnum | OddsSnapshotScalarFieldEnum[]
  }

  /**
   * OddsSnapshot findMany
   */
  export type OddsSnapshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSnapshot
     */
    select?: OddsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSnapshot
     */
    omit?: OddsSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which OddsSnapshots to fetch.
     */
    where?: OddsSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OddsSnapshots to fetch.
     */
    orderBy?: OddsSnapshotOrderByWithRelationInput | OddsSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OddsSnapshots.
     */
    cursor?: OddsSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OddsSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OddsSnapshots.
     */
    skip?: number
    distinct?: OddsSnapshotScalarFieldEnum | OddsSnapshotScalarFieldEnum[]
  }

  /**
   * OddsSnapshot create
   */
  export type OddsSnapshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSnapshot
     */
    select?: OddsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSnapshot
     */
    omit?: OddsSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to create a OddsSnapshot.
     */
    data: XOR<OddsSnapshotCreateInput, OddsSnapshotUncheckedCreateInput>
  }

  /**
   * OddsSnapshot createMany
   */
  export type OddsSnapshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OddsSnapshots.
     */
    data: OddsSnapshotCreateManyInput | OddsSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OddsSnapshot createManyAndReturn
   */
  export type OddsSnapshotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSnapshot
     */
    select?: OddsSnapshotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSnapshot
     */
    omit?: OddsSnapshotOmit<ExtArgs> | null
    /**
     * The data used to create many OddsSnapshots.
     */
    data: OddsSnapshotCreateManyInput | OddsSnapshotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSnapshotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OddsSnapshot update
   */
  export type OddsSnapshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSnapshot
     */
    select?: OddsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSnapshot
     */
    omit?: OddsSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to update a OddsSnapshot.
     */
    data: XOR<OddsSnapshotUpdateInput, OddsSnapshotUncheckedUpdateInput>
    /**
     * Choose, which OddsSnapshot to update.
     */
    where: OddsSnapshotWhereUniqueInput
  }

  /**
   * OddsSnapshot updateMany
   */
  export type OddsSnapshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OddsSnapshots.
     */
    data: XOR<OddsSnapshotUpdateManyMutationInput, OddsSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which OddsSnapshots to update
     */
    where?: OddsSnapshotWhereInput
    /**
     * Limit how many OddsSnapshots to update.
     */
    limit?: number
  }

  /**
   * OddsSnapshot updateManyAndReturn
   */
  export type OddsSnapshotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSnapshot
     */
    select?: OddsSnapshotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSnapshot
     */
    omit?: OddsSnapshotOmit<ExtArgs> | null
    /**
     * The data used to update OddsSnapshots.
     */
    data: XOR<OddsSnapshotUpdateManyMutationInput, OddsSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which OddsSnapshots to update
     */
    where?: OddsSnapshotWhereInput
    /**
     * Limit how many OddsSnapshots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSnapshotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OddsSnapshot upsert
   */
  export type OddsSnapshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSnapshot
     */
    select?: OddsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSnapshot
     */
    omit?: OddsSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSnapshotInclude<ExtArgs> | null
    /**
     * The filter to search for the OddsSnapshot to update in case it exists.
     */
    where: OddsSnapshotWhereUniqueInput
    /**
     * In case the OddsSnapshot found by the `where` argument doesn't exist, create a new OddsSnapshot with this data.
     */
    create: XOR<OddsSnapshotCreateInput, OddsSnapshotUncheckedCreateInput>
    /**
     * In case the OddsSnapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OddsSnapshotUpdateInput, OddsSnapshotUncheckedUpdateInput>
  }

  /**
   * OddsSnapshot delete
   */
  export type OddsSnapshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSnapshot
     */
    select?: OddsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSnapshot
     */
    omit?: OddsSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSnapshotInclude<ExtArgs> | null
    /**
     * Filter which OddsSnapshot to delete.
     */
    where: OddsSnapshotWhereUniqueInput
  }

  /**
   * OddsSnapshot deleteMany
   */
  export type OddsSnapshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OddsSnapshots to delete
     */
    where?: OddsSnapshotWhereInput
    /**
     * Limit how many OddsSnapshots to delete.
     */
    limit?: number
  }

  /**
   * OddsSnapshot without action
   */
  export type OddsSnapshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSnapshot
     */
    select?: OddsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSnapshot
     */
    omit?: OddsSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSnapshotInclude<ExtArgs> | null
  }


  /**
   * Model OddsSyncStatus
   */

  export type AggregateOddsSyncStatus = {
    _count: OddsSyncStatusCountAggregateOutputType | null
    _avg: OddsSyncStatusAvgAggregateOutputType | null
    _sum: OddsSyncStatusSumAggregateOutputType | null
    _min: OddsSyncStatusMinAggregateOutputType | null
    _max: OddsSyncStatusMaxAggregateOutputType | null
  }

  export type OddsSyncStatusAvgAggregateOutputType = {
    failureCount: number | null
    syncInterval: number | null
  }

  export type OddsSyncStatusSumAggregateOutputType = {
    failureCount: number | null
    syncInterval: number | null
  }

  export type OddsSyncStatusMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    lastSyncAt: Date | null
    nextSyncAt: Date | null
    syncStatus: string | null
    failureCount: number | null
    lastError: string | null
    syncInterval: number | null
  }

  export type OddsSyncStatusMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    lastSyncAt: Date | null
    nextSyncAt: Date | null
    syncStatus: string | null
    failureCount: number | null
    lastError: string | null
    syncInterval: number | null
  }

  export type OddsSyncStatusCountAggregateOutputType = {
    id: number
    gameId: number
    lastSyncAt: number
    nextSyncAt: number
    syncStatus: number
    failureCount: number
    lastError: number
    syncInterval: number
    _all: number
  }


  export type OddsSyncStatusAvgAggregateInputType = {
    failureCount?: true
    syncInterval?: true
  }

  export type OddsSyncStatusSumAggregateInputType = {
    failureCount?: true
    syncInterval?: true
  }

  export type OddsSyncStatusMinAggregateInputType = {
    id?: true
    gameId?: true
    lastSyncAt?: true
    nextSyncAt?: true
    syncStatus?: true
    failureCount?: true
    lastError?: true
    syncInterval?: true
  }

  export type OddsSyncStatusMaxAggregateInputType = {
    id?: true
    gameId?: true
    lastSyncAt?: true
    nextSyncAt?: true
    syncStatus?: true
    failureCount?: true
    lastError?: true
    syncInterval?: true
  }

  export type OddsSyncStatusCountAggregateInputType = {
    id?: true
    gameId?: true
    lastSyncAt?: true
    nextSyncAt?: true
    syncStatus?: true
    failureCount?: true
    lastError?: true
    syncInterval?: true
    _all?: true
  }

  export type OddsSyncStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OddsSyncStatus to aggregate.
     */
    where?: OddsSyncStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OddsSyncStatuses to fetch.
     */
    orderBy?: OddsSyncStatusOrderByWithRelationInput | OddsSyncStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OddsSyncStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OddsSyncStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OddsSyncStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OddsSyncStatuses
    **/
    _count?: true | OddsSyncStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OddsSyncStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OddsSyncStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OddsSyncStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OddsSyncStatusMaxAggregateInputType
  }

  export type GetOddsSyncStatusAggregateType<T extends OddsSyncStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateOddsSyncStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOddsSyncStatus[P]>
      : GetScalarType<T[P], AggregateOddsSyncStatus[P]>
  }




  export type OddsSyncStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OddsSyncStatusWhereInput
    orderBy?: OddsSyncStatusOrderByWithAggregationInput | OddsSyncStatusOrderByWithAggregationInput[]
    by: OddsSyncStatusScalarFieldEnum[] | OddsSyncStatusScalarFieldEnum
    having?: OddsSyncStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OddsSyncStatusCountAggregateInputType | true
    _avg?: OddsSyncStatusAvgAggregateInputType
    _sum?: OddsSyncStatusSumAggregateInputType
    _min?: OddsSyncStatusMinAggregateInputType
    _max?: OddsSyncStatusMaxAggregateInputType
  }

  export type OddsSyncStatusGroupByOutputType = {
    id: string
    gameId: string
    lastSyncAt: Date
    nextSyncAt: Date | null
    syncStatus: string
    failureCount: number
    lastError: string | null
    syncInterval: number
    _count: OddsSyncStatusCountAggregateOutputType | null
    _avg: OddsSyncStatusAvgAggregateOutputType | null
    _sum: OddsSyncStatusSumAggregateOutputType | null
    _min: OddsSyncStatusMinAggregateOutputType | null
    _max: OddsSyncStatusMaxAggregateOutputType | null
  }

  type GetOddsSyncStatusGroupByPayload<T extends OddsSyncStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OddsSyncStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OddsSyncStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OddsSyncStatusGroupByOutputType[P]>
            : GetScalarType<T[P], OddsSyncStatusGroupByOutputType[P]>
        }
      >
    >


  export type OddsSyncStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    lastSyncAt?: boolean
    nextSyncAt?: boolean
    syncStatus?: boolean
    failureCount?: boolean
    lastError?: boolean
    syncInterval?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oddsSyncStatus"]>

  export type OddsSyncStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    lastSyncAt?: boolean
    nextSyncAt?: boolean
    syncStatus?: boolean
    failureCount?: boolean
    lastError?: boolean
    syncInterval?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oddsSyncStatus"]>

  export type OddsSyncStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    lastSyncAt?: boolean
    nextSyncAt?: boolean
    syncStatus?: boolean
    failureCount?: boolean
    lastError?: boolean
    syncInterval?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oddsSyncStatus"]>

  export type OddsSyncStatusSelectScalar = {
    id?: boolean
    gameId?: boolean
    lastSyncAt?: boolean
    nextSyncAt?: boolean
    syncStatus?: boolean
    failureCount?: boolean
    lastError?: boolean
    syncInterval?: boolean
  }

  export type OddsSyncStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gameId" | "lastSyncAt" | "nextSyncAt" | "syncStatus" | "failureCount" | "lastError" | "syncInterval", ExtArgs["result"]["oddsSyncStatus"]>
  export type OddsSyncStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type OddsSyncStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type OddsSyncStatusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
  }

  export type $OddsSyncStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OddsSyncStatus"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      lastSyncAt: Date
      nextSyncAt: Date | null
      syncStatus: string
      failureCount: number
      lastError: string | null
      syncInterval: number
    }, ExtArgs["result"]["oddsSyncStatus"]>
    composites: {}
  }

  type OddsSyncStatusGetPayload<S extends boolean | null | undefined | OddsSyncStatusDefaultArgs> = $Result.GetResult<Prisma.$OddsSyncStatusPayload, S>

  type OddsSyncStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OddsSyncStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OddsSyncStatusCountAggregateInputType | true
    }

  export interface OddsSyncStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OddsSyncStatus'], meta: { name: 'OddsSyncStatus' } }
    /**
     * Find zero or one OddsSyncStatus that matches the filter.
     * @param {OddsSyncStatusFindUniqueArgs} args - Arguments to find a OddsSyncStatus
     * @example
     * // Get one OddsSyncStatus
     * const oddsSyncStatus = await prisma.oddsSyncStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OddsSyncStatusFindUniqueArgs>(args: SelectSubset<T, OddsSyncStatusFindUniqueArgs<ExtArgs>>): Prisma__OddsSyncStatusClient<$Result.GetResult<Prisma.$OddsSyncStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OddsSyncStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OddsSyncStatusFindUniqueOrThrowArgs} args - Arguments to find a OddsSyncStatus
     * @example
     * // Get one OddsSyncStatus
     * const oddsSyncStatus = await prisma.oddsSyncStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OddsSyncStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, OddsSyncStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OddsSyncStatusClient<$Result.GetResult<Prisma.$OddsSyncStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OddsSyncStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsSyncStatusFindFirstArgs} args - Arguments to find a OddsSyncStatus
     * @example
     * // Get one OddsSyncStatus
     * const oddsSyncStatus = await prisma.oddsSyncStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OddsSyncStatusFindFirstArgs>(args?: SelectSubset<T, OddsSyncStatusFindFirstArgs<ExtArgs>>): Prisma__OddsSyncStatusClient<$Result.GetResult<Prisma.$OddsSyncStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OddsSyncStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsSyncStatusFindFirstOrThrowArgs} args - Arguments to find a OddsSyncStatus
     * @example
     * // Get one OddsSyncStatus
     * const oddsSyncStatus = await prisma.oddsSyncStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OddsSyncStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, OddsSyncStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__OddsSyncStatusClient<$Result.GetResult<Prisma.$OddsSyncStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OddsSyncStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsSyncStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OddsSyncStatuses
     * const oddsSyncStatuses = await prisma.oddsSyncStatus.findMany()
     * 
     * // Get first 10 OddsSyncStatuses
     * const oddsSyncStatuses = await prisma.oddsSyncStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oddsSyncStatusWithIdOnly = await prisma.oddsSyncStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OddsSyncStatusFindManyArgs>(args?: SelectSubset<T, OddsSyncStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OddsSyncStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OddsSyncStatus.
     * @param {OddsSyncStatusCreateArgs} args - Arguments to create a OddsSyncStatus.
     * @example
     * // Create one OddsSyncStatus
     * const OddsSyncStatus = await prisma.oddsSyncStatus.create({
     *   data: {
     *     // ... data to create a OddsSyncStatus
     *   }
     * })
     * 
     */
    create<T extends OddsSyncStatusCreateArgs>(args: SelectSubset<T, OddsSyncStatusCreateArgs<ExtArgs>>): Prisma__OddsSyncStatusClient<$Result.GetResult<Prisma.$OddsSyncStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OddsSyncStatuses.
     * @param {OddsSyncStatusCreateManyArgs} args - Arguments to create many OddsSyncStatuses.
     * @example
     * // Create many OddsSyncStatuses
     * const oddsSyncStatus = await prisma.oddsSyncStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OddsSyncStatusCreateManyArgs>(args?: SelectSubset<T, OddsSyncStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OddsSyncStatuses and returns the data saved in the database.
     * @param {OddsSyncStatusCreateManyAndReturnArgs} args - Arguments to create many OddsSyncStatuses.
     * @example
     * // Create many OddsSyncStatuses
     * const oddsSyncStatus = await prisma.oddsSyncStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OddsSyncStatuses and only return the `id`
     * const oddsSyncStatusWithIdOnly = await prisma.oddsSyncStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OddsSyncStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, OddsSyncStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OddsSyncStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OddsSyncStatus.
     * @param {OddsSyncStatusDeleteArgs} args - Arguments to delete one OddsSyncStatus.
     * @example
     * // Delete one OddsSyncStatus
     * const OddsSyncStatus = await prisma.oddsSyncStatus.delete({
     *   where: {
     *     // ... filter to delete one OddsSyncStatus
     *   }
     * })
     * 
     */
    delete<T extends OddsSyncStatusDeleteArgs>(args: SelectSubset<T, OddsSyncStatusDeleteArgs<ExtArgs>>): Prisma__OddsSyncStatusClient<$Result.GetResult<Prisma.$OddsSyncStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OddsSyncStatus.
     * @param {OddsSyncStatusUpdateArgs} args - Arguments to update one OddsSyncStatus.
     * @example
     * // Update one OddsSyncStatus
     * const oddsSyncStatus = await prisma.oddsSyncStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OddsSyncStatusUpdateArgs>(args: SelectSubset<T, OddsSyncStatusUpdateArgs<ExtArgs>>): Prisma__OddsSyncStatusClient<$Result.GetResult<Prisma.$OddsSyncStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OddsSyncStatuses.
     * @param {OddsSyncStatusDeleteManyArgs} args - Arguments to filter OddsSyncStatuses to delete.
     * @example
     * // Delete a few OddsSyncStatuses
     * const { count } = await prisma.oddsSyncStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OddsSyncStatusDeleteManyArgs>(args?: SelectSubset<T, OddsSyncStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OddsSyncStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsSyncStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OddsSyncStatuses
     * const oddsSyncStatus = await prisma.oddsSyncStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OddsSyncStatusUpdateManyArgs>(args: SelectSubset<T, OddsSyncStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OddsSyncStatuses and returns the data updated in the database.
     * @param {OddsSyncStatusUpdateManyAndReturnArgs} args - Arguments to update many OddsSyncStatuses.
     * @example
     * // Update many OddsSyncStatuses
     * const oddsSyncStatus = await prisma.oddsSyncStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OddsSyncStatuses and only return the `id`
     * const oddsSyncStatusWithIdOnly = await prisma.oddsSyncStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OddsSyncStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, OddsSyncStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OddsSyncStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OddsSyncStatus.
     * @param {OddsSyncStatusUpsertArgs} args - Arguments to update or create a OddsSyncStatus.
     * @example
     * // Update or create a OddsSyncStatus
     * const oddsSyncStatus = await prisma.oddsSyncStatus.upsert({
     *   create: {
     *     // ... data to create a OddsSyncStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OddsSyncStatus we want to update
     *   }
     * })
     */
    upsert<T extends OddsSyncStatusUpsertArgs>(args: SelectSubset<T, OddsSyncStatusUpsertArgs<ExtArgs>>): Prisma__OddsSyncStatusClient<$Result.GetResult<Prisma.$OddsSyncStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OddsSyncStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsSyncStatusCountArgs} args - Arguments to filter OddsSyncStatuses to count.
     * @example
     * // Count the number of OddsSyncStatuses
     * const count = await prisma.oddsSyncStatus.count({
     *   where: {
     *     // ... the filter for the OddsSyncStatuses we want to count
     *   }
     * })
    **/
    count<T extends OddsSyncStatusCountArgs>(
      args?: Subset<T, OddsSyncStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OddsSyncStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OddsSyncStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsSyncStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OddsSyncStatusAggregateArgs>(args: Subset<T, OddsSyncStatusAggregateArgs>): Prisma.PrismaPromise<GetOddsSyncStatusAggregateType<T>>

    /**
     * Group by OddsSyncStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsSyncStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OddsSyncStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OddsSyncStatusGroupByArgs['orderBy'] }
        : { orderBy?: OddsSyncStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OddsSyncStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOddsSyncStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OddsSyncStatus model
   */
  readonly fields: OddsSyncStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OddsSyncStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OddsSyncStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OddsSyncStatus model
   */
  interface OddsSyncStatusFieldRefs {
    readonly id: FieldRef<"OddsSyncStatus", 'String'>
    readonly gameId: FieldRef<"OddsSyncStatus", 'String'>
    readonly lastSyncAt: FieldRef<"OddsSyncStatus", 'DateTime'>
    readonly nextSyncAt: FieldRef<"OddsSyncStatus", 'DateTime'>
    readonly syncStatus: FieldRef<"OddsSyncStatus", 'String'>
    readonly failureCount: FieldRef<"OddsSyncStatus", 'Int'>
    readonly lastError: FieldRef<"OddsSyncStatus", 'String'>
    readonly syncInterval: FieldRef<"OddsSyncStatus", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OddsSyncStatus findUnique
   */
  export type OddsSyncStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSyncStatus
     */
    select?: OddsSyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSyncStatus
     */
    omit?: OddsSyncStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSyncStatusInclude<ExtArgs> | null
    /**
     * Filter, which OddsSyncStatus to fetch.
     */
    where: OddsSyncStatusWhereUniqueInput
  }

  /**
   * OddsSyncStatus findUniqueOrThrow
   */
  export type OddsSyncStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSyncStatus
     */
    select?: OddsSyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSyncStatus
     */
    omit?: OddsSyncStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSyncStatusInclude<ExtArgs> | null
    /**
     * Filter, which OddsSyncStatus to fetch.
     */
    where: OddsSyncStatusWhereUniqueInput
  }

  /**
   * OddsSyncStatus findFirst
   */
  export type OddsSyncStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSyncStatus
     */
    select?: OddsSyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSyncStatus
     */
    omit?: OddsSyncStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSyncStatusInclude<ExtArgs> | null
    /**
     * Filter, which OddsSyncStatus to fetch.
     */
    where?: OddsSyncStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OddsSyncStatuses to fetch.
     */
    orderBy?: OddsSyncStatusOrderByWithRelationInput | OddsSyncStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OddsSyncStatuses.
     */
    cursor?: OddsSyncStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OddsSyncStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OddsSyncStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OddsSyncStatuses.
     */
    distinct?: OddsSyncStatusScalarFieldEnum | OddsSyncStatusScalarFieldEnum[]
  }

  /**
   * OddsSyncStatus findFirstOrThrow
   */
  export type OddsSyncStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSyncStatus
     */
    select?: OddsSyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSyncStatus
     */
    omit?: OddsSyncStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSyncStatusInclude<ExtArgs> | null
    /**
     * Filter, which OddsSyncStatus to fetch.
     */
    where?: OddsSyncStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OddsSyncStatuses to fetch.
     */
    orderBy?: OddsSyncStatusOrderByWithRelationInput | OddsSyncStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OddsSyncStatuses.
     */
    cursor?: OddsSyncStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OddsSyncStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OddsSyncStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OddsSyncStatuses.
     */
    distinct?: OddsSyncStatusScalarFieldEnum | OddsSyncStatusScalarFieldEnum[]
  }

  /**
   * OddsSyncStatus findMany
   */
  export type OddsSyncStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSyncStatus
     */
    select?: OddsSyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSyncStatus
     */
    omit?: OddsSyncStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSyncStatusInclude<ExtArgs> | null
    /**
     * Filter, which OddsSyncStatuses to fetch.
     */
    where?: OddsSyncStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OddsSyncStatuses to fetch.
     */
    orderBy?: OddsSyncStatusOrderByWithRelationInput | OddsSyncStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OddsSyncStatuses.
     */
    cursor?: OddsSyncStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OddsSyncStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OddsSyncStatuses.
     */
    skip?: number
    distinct?: OddsSyncStatusScalarFieldEnum | OddsSyncStatusScalarFieldEnum[]
  }

  /**
   * OddsSyncStatus create
   */
  export type OddsSyncStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSyncStatus
     */
    select?: OddsSyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSyncStatus
     */
    omit?: OddsSyncStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSyncStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a OddsSyncStatus.
     */
    data: XOR<OddsSyncStatusCreateInput, OddsSyncStatusUncheckedCreateInput>
  }

  /**
   * OddsSyncStatus createMany
   */
  export type OddsSyncStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OddsSyncStatuses.
     */
    data: OddsSyncStatusCreateManyInput | OddsSyncStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OddsSyncStatus createManyAndReturn
   */
  export type OddsSyncStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSyncStatus
     */
    select?: OddsSyncStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSyncStatus
     */
    omit?: OddsSyncStatusOmit<ExtArgs> | null
    /**
     * The data used to create many OddsSyncStatuses.
     */
    data: OddsSyncStatusCreateManyInput | OddsSyncStatusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSyncStatusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OddsSyncStatus update
   */
  export type OddsSyncStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSyncStatus
     */
    select?: OddsSyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSyncStatus
     */
    omit?: OddsSyncStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSyncStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a OddsSyncStatus.
     */
    data: XOR<OddsSyncStatusUpdateInput, OddsSyncStatusUncheckedUpdateInput>
    /**
     * Choose, which OddsSyncStatus to update.
     */
    where: OddsSyncStatusWhereUniqueInput
  }

  /**
   * OddsSyncStatus updateMany
   */
  export type OddsSyncStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OddsSyncStatuses.
     */
    data: XOR<OddsSyncStatusUpdateManyMutationInput, OddsSyncStatusUncheckedUpdateManyInput>
    /**
     * Filter which OddsSyncStatuses to update
     */
    where?: OddsSyncStatusWhereInput
    /**
     * Limit how many OddsSyncStatuses to update.
     */
    limit?: number
  }

  /**
   * OddsSyncStatus updateManyAndReturn
   */
  export type OddsSyncStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSyncStatus
     */
    select?: OddsSyncStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSyncStatus
     */
    omit?: OddsSyncStatusOmit<ExtArgs> | null
    /**
     * The data used to update OddsSyncStatuses.
     */
    data: XOR<OddsSyncStatusUpdateManyMutationInput, OddsSyncStatusUncheckedUpdateManyInput>
    /**
     * Filter which OddsSyncStatuses to update
     */
    where?: OddsSyncStatusWhereInput
    /**
     * Limit how many OddsSyncStatuses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSyncStatusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OddsSyncStatus upsert
   */
  export type OddsSyncStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSyncStatus
     */
    select?: OddsSyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSyncStatus
     */
    omit?: OddsSyncStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSyncStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the OddsSyncStatus to update in case it exists.
     */
    where: OddsSyncStatusWhereUniqueInput
    /**
     * In case the OddsSyncStatus found by the `where` argument doesn't exist, create a new OddsSyncStatus with this data.
     */
    create: XOR<OddsSyncStatusCreateInput, OddsSyncStatusUncheckedCreateInput>
    /**
     * In case the OddsSyncStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OddsSyncStatusUpdateInput, OddsSyncStatusUncheckedUpdateInput>
  }

  /**
   * OddsSyncStatus delete
   */
  export type OddsSyncStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSyncStatus
     */
    select?: OddsSyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSyncStatus
     */
    omit?: OddsSyncStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSyncStatusInclude<ExtArgs> | null
    /**
     * Filter which OddsSyncStatus to delete.
     */
    where: OddsSyncStatusWhereUniqueInput
  }

  /**
   * OddsSyncStatus deleteMany
   */
  export type OddsSyncStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OddsSyncStatuses to delete
     */
    where?: OddsSyncStatusWhereInput
    /**
     * Limit how many OddsSyncStatuses to delete.
     */
    limit?: number
  }

  /**
   * OddsSyncStatus without action
   */
  export type OddsSyncStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsSyncStatus
     */
    select?: OddsSyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsSyncStatus
     */
    omit?: OddsSyncStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OddsSyncStatusInclude<ExtArgs> | null
  }


  /**
   * Model OddsChangeEvent
   */

  export type AggregateOddsChangeEvent = {
    _count: OddsChangeEventCountAggregateOutputType | null
    _avg: OddsChangeEventAvgAggregateOutputType | null
    _sum: OddsChangeEventSumAggregateOutputType | null
    _min: OddsChangeEventMinAggregateOutputType | null
    _max: OddsChangeEventMaxAggregateOutputType | null
  }

  export type OddsChangeEventAvgAggregateOutputType = {
    oldOdds: Decimal | null
    newOdds: Decimal | null
    changePercentage: Decimal | null
  }

  export type OddsChangeEventSumAggregateOutputType = {
    oldOdds: Decimal | null
    newOdds: Decimal | null
    changePercentage: Decimal | null
  }

  export type OddsChangeEventMinAggregateOutputType = {
    id: string | null
    selectionId: string | null
    gameId: string | null
    oldOdds: Decimal | null
    newOdds: Decimal | null
    changePercentage: Decimal | null
    changeType: string | null
    broadcasted: boolean | null
    createdAt: Date | null
  }

  export type OddsChangeEventMaxAggregateOutputType = {
    id: string | null
    selectionId: string | null
    gameId: string | null
    oldOdds: Decimal | null
    newOdds: Decimal | null
    changePercentage: Decimal | null
    changeType: string | null
    broadcasted: boolean | null
    createdAt: Date | null
  }

  export type OddsChangeEventCountAggregateOutputType = {
    id: number
    selectionId: number
    gameId: number
    oldOdds: number
    newOdds: number
    changePercentage: number
    changeType: number
    broadcasted: number
    createdAt: number
    _all: number
  }


  export type OddsChangeEventAvgAggregateInputType = {
    oldOdds?: true
    newOdds?: true
    changePercentage?: true
  }

  export type OddsChangeEventSumAggregateInputType = {
    oldOdds?: true
    newOdds?: true
    changePercentage?: true
  }

  export type OddsChangeEventMinAggregateInputType = {
    id?: true
    selectionId?: true
    gameId?: true
    oldOdds?: true
    newOdds?: true
    changePercentage?: true
    changeType?: true
    broadcasted?: true
    createdAt?: true
  }

  export type OddsChangeEventMaxAggregateInputType = {
    id?: true
    selectionId?: true
    gameId?: true
    oldOdds?: true
    newOdds?: true
    changePercentage?: true
    changeType?: true
    broadcasted?: true
    createdAt?: true
  }

  export type OddsChangeEventCountAggregateInputType = {
    id?: true
    selectionId?: true
    gameId?: true
    oldOdds?: true
    newOdds?: true
    changePercentage?: true
    changeType?: true
    broadcasted?: true
    createdAt?: true
    _all?: true
  }

  export type OddsChangeEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OddsChangeEvent to aggregate.
     */
    where?: OddsChangeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OddsChangeEvents to fetch.
     */
    orderBy?: OddsChangeEventOrderByWithRelationInput | OddsChangeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OddsChangeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OddsChangeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OddsChangeEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OddsChangeEvents
    **/
    _count?: true | OddsChangeEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OddsChangeEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OddsChangeEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OddsChangeEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OddsChangeEventMaxAggregateInputType
  }

  export type GetOddsChangeEventAggregateType<T extends OddsChangeEventAggregateArgs> = {
        [P in keyof T & keyof AggregateOddsChangeEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOddsChangeEvent[P]>
      : GetScalarType<T[P], AggregateOddsChangeEvent[P]>
  }




  export type OddsChangeEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OddsChangeEventWhereInput
    orderBy?: OddsChangeEventOrderByWithAggregationInput | OddsChangeEventOrderByWithAggregationInput[]
    by: OddsChangeEventScalarFieldEnum[] | OddsChangeEventScalarFieldEnum
    having?: OddsChangeEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OddsChangeEventCountAggregateInputType | true
    _avg?: OddsChangeEventAvgAggregateInputType
    _sum?: OddsChangeEventSumAggregateInputType
    _min?: OddsChangeEventMinAggregateInputType
    _max?: OddsChangeEventMaxAggregateInputType
  }

  export type OddsChangeEventGroupByOutputType = {
    id: string
    selectionId: string
    gameId: string
    oldOdds: Decimal
    newOdds: Decimal
    changePercentage: Decimal
    changeType: string
    broadcasted: boolean
    createdAt: Date
    _count: OddsChangeEventCountAggregateOutputType | null
    _avg: OddsChangeEventAvgAggregateOutputType | null
    _sum: OddsChangeEventSumAggregateOutputType | null
    _min: OddsChangeEventMinAggregateOutputType | null
    _max: OddsChangeEventMaxAggregateOutputType | null
  }

  type GetOddsChangeEventGroupByPayload<T extends OddsChangeEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OddsChangeEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OddsChangeEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OddsChangeEventGroupByOutputType[P]>
            : GetScalarType<T[P], OddsChangeEventGroupByOutputType[P]>
        }
      >
    >


  export type OddsChangeEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    selectionId?: boolean
    gameId?: boolean
    oldOdds?: boolean
    newOdds?: boolean
    changePercentage?: boolean
    changeType?: boolean
    broadcasted?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["oddsChangeEvent"]>

  export type OddsChangeEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    selectionId?: boolean
    gameId?: boolean
    oldOdds?: boolean
    newOdds?: boolean
    changePercentage?: boolean
    changeType?: boolean
    broadcasted?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["oddsChangeEvent"]>

  export type OddsChangeEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    selectionId?: boolean
    gameId?: boolean
    oldOdds?: boolean
    newOdds?: boolean
    changePercentage?: boolean
    changeType?: boolean
    broadcasted?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["oddsChangeEvent"]>

  export type OddsChangeEventSelectScalar = {
    id?: boolean
    selectionId?: boolean
    gameId?: boolean
    oldOdds?: boolean
    newOdds?: boolean
    changePercentage?: boolean
    changeType?: boolean
    broadcasted?: boolean
    createdAt?: boolean
  }

  export type OddsChangeEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "selectionId" | "gameId" | "oldOdds" | "newOdds" | "changePercentage" | "changeType" | "broadcasted" | "createdAt", ExtArgs["result"]["oddsChangeEvent"]>

  export type $OddsChangeEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OddsChangeEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      selectionId: string
      gameId: string
      oldOdds: Prisma.Decimal
      newOdds: Prisma.Decimal
      changePercentage: Prisma.Decimal
      changeType: string
      broadcasted: boolean
      createdAt: Date
    }, ExtArgs["result"]["oddsChangeEvent"]>
    composites: {}
  }

  type OddsChangeEventGetPayload<S extends boolean | null | undefined | OddsChangeEventDefaultArgs> = $Result.GetResult<Prisma.$OddsChangeEventPayload, S>

  type OddsChangeEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OddsChangeEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OddsChangeEventCountAggregateInputType | true
    }

  export interface OddsChangeEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OddsChangeEvent'], meta: { name: 'OddsChangeEvent' } }
    /**
     * Find zero or one OddsChangeEvent that matches the filter.
     * @param {OddsChangeEventFindUniqueArgs} args - Arguments to find a OddsChangeEvent
     * @example
     * // Get one OddsChangeEvent
     * const oddsChangeEvent = await prisma.oddsChangeEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OddsChangeEventFindUniqueArgs>(args: SelectSubset<T, OddsChangeEventFindUniqueArgs<ExtArgs>>): Prisma__OddsChangeEventClient<$Result.GetResult<Prisma.$OddsChangeEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OddsChangeEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OddsChangeEventFindUniqueOrThrowArgs} args - Arguments to find a OddsChangeEvent
     * @example
     * // Get one OddsChangeEvent
     * const oddsChangeEvent = await prisma.oddsChangeEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OddsChangeEventFindUniqueOrThrowArgs>(args: SelectSubset<T, OddsChangeEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OddsChangeEventClient<$Result.GetResult<Prisma.$OddsChangeEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OddsChangeEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsChangeEventFindFirstArgs} args - Arguments to find a OddsChangeEvent
     * @example
     * // Get one OddsChangeEvent
     * const oddsChangeEvent = await prisma.oddsChangeEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OddsChangeEventFindFirstArgs>(args?: SelectSubset<T, OddsChangeEventFindFirstArgs<ExtArgs>>): Prisma__OddsChangeEventClient<$Result.GetResult<Prisma.$OddsChangeEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OddsChangeEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsChangeEventFindFirstOrThrowArgs} args - Arguments to find a OddsChangeEvent
     * @example
     * // Get one OddsChangeEvent
     * const oddsChangeEvent = await prisma.oddsChangeEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OddsChangeEventFindFirstOrThrowArgs>(args?: SelectSubset<T, OddsChangeEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__OddsChangeEventClient<$Result.GetResult<Prisma.$OddsChangeEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OddsChangeEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsChangeEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OddsChangeEvents
     * const oddsChangeEvents = await prisma.oddsChangeEvent.findMany()
     * 
     * // Get first 10 OddsChangeEvents
     * const oddsChangeEvents = await prisma.oddsChangeEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oddsChangeEventWithIdOnly = await prisma.oddsChangeEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OddsChangeEventFindManyArgs>(args?: SelectSubset<T, OddsChangeEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OddsChangeEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OddsChangeEvent.
     * @param {OddsChangeEventCreateArgs} args - Arguments to create a OddsChangeEvent.
     * @example
     * // Create one OddsChangeEvent
     * const OddsChangeEvent = await prisma.oddsChangeEvent.create({
     *   data: {
     *     // ... data to create a OddsChangeEvent
     *   }
     * })
     * 
     */
    create<T extends OddsChangeEventCreateArgs>(args: SelectSubset<T, OddsChangeEventCreateArgs<ExtArgs>>): Prisma__OddsChangeEventClient<$Result.GetResult<Prisma.$OddsChangeEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OddsChangeEvents.
     * @param {OddsChangeEventCreateManyArgs} args - Arguments to create many OddsChangeEvents.
     * @example
     * // Create many OddsChangeEvents
     * const oddsChangeEvent = await prisma.oddsChangeEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OddsChangeEventCreateManyArgs>(args?: SelectSubset<T, OddsChangeEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OddsChangeEvents and returns the data saved in the database.
     * @param {OddsChangeEventCreateManyAndReturnArgs} args - Arguments to create many OddsChangeEvents.
     * @example
     * // Create many OddsChangeEvents
     * const oddsChangeEvent = await prisma.oddsChangeEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OddsChangeEvents and only return the `id`
     * const oddsChangeEventWithIdOnly = await prisma.oddsChangeEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OddsChangeEventCreateManyAndReturnArgs>(args?: SelectSubset<T, OddsChangeEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OddsChangeEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OddsChangeEvent.
     * @param {OddsChangeEventDeleteArgs} args - Arguments to delete one OddsChangeEvent.
     * @example
     * // Delete one OddsChangeEvent
     * const OddsChangeEvent = await prisma.oddsChangeEvent.delete({
     *   where: {
     *     // ... filter to delete one OddsChangeEvent
     *   }
     * })
     * 
     */
    delete<T extends OddsChangeEventDeleteArgs>(args: SelectSubset<T, OddsChangeEventDeleteArgs<ExtArgs>>): Prisma__OddsChangeEventClient<$Result.GetResult<Prisma.$OddsChangeEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OddsChangeEvent.
     * @param {OddsChangeEventUpdateArgs} args - Arguments to update one OddsChangeEvent.
     * @example
     * // Update one OddsChangeEvent
     * const oddsChangeEvent = await prisma.oddsChangeEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OddsChangeEventUpdateArgs>(args: SelectSubset<T, OddsChangeEventUpdateArgs<ExtArgs>>): Prisma__OddsChangeEventClient<$Result.GetResult<Prisma.$OddsChangeEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OddsChangeEvents.
     * @param {OddsChangeEventDeleteManyArgs} args - Arguments to filter OddsChangeEvents to delete.
     * @example
     * // Delete a few OddsChangeEvents
     * const { count } = await prisma.oddsChangeEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OddsChangeEventDeleteManyArgs>(args?: SelectSubset<T, OddsChangeEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OddsChangeEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsChangeEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OddsChangeEvents
     * const oddsChangeEvent = await prisma.oddsChangeEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OddsChangeEventUpdateManyArgs>(args: SelectSubset<T, OddsChangeEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OddsChangeEvents and returns the data updated in the database.
     * @param {OddsChangeEventUpdateManyAndReturnArgs} args - Arguments to update many OddsChangeEvents.
     * @example
     * // Update many OddsChangeEvents
     * const oddsChangeEvent = await prisma.oddsChangeEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OddsChangeEvents and only return the `id`
     * const oddsChangeEventWithIdOnly = await prisma.oddsChangeEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OddsChangeEventUpdateManyAndReturnArgs>(args: SelectSubset<T, OddsChangeEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OddsChangeEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OddsChangeEvent.
     * @param {OddsChangeEventUpsertArgs} args - Arguments to update or create a OddsChangeEvent.
     * @example
     * // Update or create a OddsChangeEvent
     * const oddsChangeEvent = await prisma.oddsChangeEvent.upsert({
     *   create: {
     *     // ... data to create a OddsChangeEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OddsChangeEvent we want to update
     *   }
     * })
     */
    upsert<T extends OddsChangeEventUpsertArgs>(args: SelectSubset<T, OddsChangeEventUpsertArgs<ExtArgs>>): Prisma__OddsChangeEventClient<$Result.GetResult<Prisma.$OddsChangeEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OddsChangeEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsChangeEventCountArgs} args - Arguments to filter OddsChangeEvents to count.
     * @example
     * // Count the number of OddsChangeEvents
     * const count = await prisma.oddsChangeEvent.count({
     *   where: {
     *     // ... the filter for the OddsChangeEvents we want to count
     *   }
     * })
    **/
    count<T extends OddsChangeEventCountArgs>(
      args?: Subset<T, OddsChangeEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OddsChangeEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OddsChangeEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsChangeEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OddsChangeEventAggregateArgs>(args: Subset<T, OddsChangeEventAggregateArgs>): Prisma.PrismaPromise<GetOddsChangeEventAggregateType<T>>

    /**
     * Group by OddsChangeEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsChangeEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OddsChangeEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OddsChangeEventGroupByArgs['orderBy'] }
        : { orderBy?: OddsChangeEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OddsChangeEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOddsChangeEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OddsChangeEvent model
   */
  readonly fields: OddsChangeEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OddsChangeEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OddsChangeEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OddsChangeEvent model
   */
  interface OddsChangeEventFieldRefs {
    readonly id: FieldRef<"OddsChangeEvent", 'String'>
    readonly selectionId: FieldRef<"OddsChangeEvent", 'String'>
    readonly gameId: FieldRef<"OddsChangeEvent", 'String'>
    readonly oldOdds: FieldRef<"OddsChangeEvent", 'Decimal'>
    readonly newOdds: FieldRef<"OddsChangeEvent", 'Decimal'>
    readonly changePercentage: FieldRef<"OddsChangeEvent", 'Decimal'>
    readonly changeType: FieldRef<"OddsChangeEvent", 'String'>
    readonly broadcasted: FieldRef<"OddsChangeEvent", 'Boolean'>
    readonly createdAt: FieldRef<"OddsChangeEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OddsChangeEvent findUnique
   */
  export type OddsChangeEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsChangeEvent
     */
    select?: OddsChangeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsChangeEvent
     */
    omit?: OddsChangeEventOmit<ExtArgs> | null
    /**
     * Filter, which OddsChangeEvent to fetch.
     */
    where: OddsChangeEventWhereUniqueInput
  }

  /**
   * OddsChangeEvent findUniqueOrThrow
   */
  export type OddsChangeEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsChangeEvent
     */
    select?: OddsChangeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsChangeEvent
     */
    omit?: OddsChangeEventOmit<ExtArgs> | null
    /**
     * Filter, which OddsChangeEvent to fetch.
     */
    where: OddsChangeEventWhereUniqueInput
  }

  /**
   * OddsChangeEvent findFirst
   */
  export type OddsChangeEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsChangeEvent
     */
    select?: OddsChangeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsChangeEvent
     */
    omit?: OddsChangeEventOmit<ExtArgs> | null
    /**
     * Filter, which OddsChangeEvent to fetch.
     */
    where?: OddsChangeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OddsChangeEvents to fetch.
     */
    orderBy?: OddsChangeEventOrderByWithRelationInput | OddsChangeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OddsChangeEvents.
     */
    cursor?: OddsChangeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OddsChangeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OddsChangeEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OddsChangeEvents.
     */
    distinct?: OddsChangeEventScalarFieldEnum | OddsChangeEventScalarFieldEnum[]
  }

  /**
   * OddsChangeEvent findFirstOrThrow
   */
  export type OddsChangeEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsChangeEvent
     */
    select?: OddsChangeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsChangeEvent
     */
    omit?: OddsChangeEventOmit<ExtArgs> | null
    /**
     * Filter, which OddsChangeEvent to fetch.
     */
    where?: OddsChangeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OddsChangeEvents to fetch.
     */
    orderBy?: OddsChangeEventOrderByWithRelationInput | OddsChangeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OddsChangeEvents.
     */
    cursor?: OddsChangeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OddsChangeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OddsChangeEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OddsChangeEvents.
     */
    distinct?: OddsChangeEventScalarFieldEnum | OddsChangeEventScalarFieldEnum[]
  }

  /**
   * OddsChangeEvent findMany
   */
  export type OddsChangeEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsChangeEvent
     */
    select?: OddsChangeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsChangeEvent
     */
    omit?: OddsChangeEventOmit<ExtArgs> | null
    /**
     * Filter, which OddsChangeEvents to fetch.
     */
    where?: OddsChangeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OddsChangeEvents to fetch.
     */
    orderBy?: OddsChangeEventOrderByWithRelationInput | OddsChangeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OddsChangeEvents.
     */
    cursor?: OddsChangeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OddsChangeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OddsChangeEvents.
     */
    skip?: number
    distinct?: OddsChangeEventScalarFieldEnum | OddsChangeEventScalarFieldEnum[]
  }

  /**
   * OddsChangeEvent create
   */
  export type OddsChangeEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsChangeEvent
     */
    select?: OddsChangeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsChangeEvent
     */
    omit?: OddsChangeEventOmit<ExtArgs> | null
    /**
     * The data needed to create a OddsChangeEvent.
     */
    data: XOR<OddsChangeEventCreateInput, OddsChangeEventUncheckedCreateInput>
  }

  /**
   * OddsChangeEvent createMany
   */
  export type OddsChangeEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OddsChangeEvents.
     */
    data: OddsChangeEventCreateManyInput | OddsChangeEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OddsChangeEvent createManyAndReturn
   */
  export type OddsChangeEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsChangeEvent
     */
    select?: OddsChangeEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OddsChangeEvent
     */
    omit?: OddsChangeEventOmit<ExtArgs> | null
    /**
     * The data used to create many OddsChangeEvents.
     */
    data: OddsChangeEventCreateManyInput | OddsChangeEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OddsChangeEvent update
   */
  export type OddsChangeEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsChangeEvent
     */
    select?: OddsChangeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsChangeEvent
     */
    omit?: OddsChangeEventOmit<ExtArgs> | null
    /**
     * The data needed to update a OddsChangeEvent.
     */
    data: XOR<OddsChangeEventUpdateInput, OddsChangeEventUncheckedUpdateInput>
    /**
     * Choose, which OddsChangeEvent to update.
     */
    where: OddsChangeEventWhereUniqueInput
  }

  /**
   * OddsChangeEvent updateMany
   */
  export type OddsChangeEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OddsChangeEvents.
     */
    data: XOR<OddsChangeEventUpdateManyMutationInput, OddsChangeEventUncheckedUpdateManyInput>
    /**
     * Filter which OddsChangeEvents to update
     */
    where?: OddsChangeEventWhereInput
    /**
     * Limit how many OddsChangeEvents to update.
     */
    limit?: number
  }

  /**
   * OddsChangeEvent updateManyAndReturn
   */
  export type OddsChangeEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsChangeEvent
     */
    select?: OddsChangeEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OddsChangeEvent
     */
    omit?: OddsChangeEventOmit<ExtArgs> | null
    /**
     * The data used to update OddsChangeEvents.
     */
    data: XOR<OddsChangeEventUpdateManyMutationInput, OddsChangeEventUncheckedUpdateManyInput>
    /**
     * Filter which OddsChangeEvents to update
     */
    where?: OddsChangeEventWhereInput
    /**
     * Limit how many OddsChangeEvents to update.
     */
    limit?: number
  }

  /**
   * OddsChangeEvent upsert
   */
  export type OddsChangeEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsChangeEvent
     */
    select?: OddsChangeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsChangeEvent
     */
    omit?: OddsChangeEventOmit<ExtArgs> | null
    /**
     * The filter to search for the OddsChangeEvent to update in case it exists.
     */
    where: OddsChangeEventWhereUniqueInput
    /**
     * In case the OddsChangeEvent found by the `where` argument doesn't exist, create a new OddsChangeEvent with this data.
     */
    create: XOR<OddsChangeEventCreateInput, OddsChangeEventUncheckedCreateInput>
    /**
     * In case the OddsChangeEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OddsChangeEventUpdateInput, OddsChangeEventUncheckedUpdateInput>
  }

  /**
   * OddsChangeEvent delete
   */
  export type OddsChangeEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsChangeEvent
     */
    select?: OddsChangeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsChangeEvent
     */
    omit?: OddsChangeEventOmit<ExtArgs> | null
    /**
     * Filter which OddsChangeEvent to delete.
     */
    where: OddsChangeEventWhereUniqueInput
  }

  /**
   * OddsChangeEvent deleteMany
   */
  export type OddsChangeEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OddsChangeEvents to delete
     */
    where?: OddsChangeEventWhereInput
    /**
     * Limit how many OddsChangeEvents to delete.
     */
    limit?: number
  }

  /**
   * OddsChangeEvent without action
   */
  export type OddsChangeEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsChangeEvent
     */
    select?: OddsChangeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsChangeEvent
     */
    omit?: OddsChangeEventOmit<ExtArgs> | null
  }


  /**
   * Model ApiOddsSnapshot
   */

  export type AggregateApiOddsSnapshot = {
    _count: ApiOddsSnapshotCountAggregateOutputType | null
    _min: ApiOddsSnapshotMinAggregateOutputType | null
    _max: ApiOddsSnapshotMaxAggregateOutputType | null
  }

  export type ApiOddsSnapshotMinAggregateOutputType = {
    id: string | null
    externalGameId: string | null
    sportKey: string | null
    homeTeam: string | null
    awayTeam: string | null
    commenceTime: Date | null
    bookmaker: string | null
    timestamp: Date | null
  }

  export type ApiOddsSnapshotMaxAggregateOutputType = {
    id: string | null
    externalGameId: string | null
    sportKey: string | null
    homeTeam: string | null
    awayTeam: string | null
    commenceTime: Date | null
    bookmaker: string | null
    timestamp: Date | null
  }

  export type ApiOddsSnapshotCountAggregateOutputType = {
    id: number
    externalGameId: number
    sportKey: number
    homeTeam: number
    awayTeam: number
    commenceTime: number
    bookmaker: number
    rawData: number
    timestamp: number
    _all: number
  }


  export type ApiOddsSnapshotMinAggregateInputType = {
    id?: true
    externalGameId?: true
    sportKey?: true
    homeTeam?: true
    awayTeam?: true
    commenceTime?: true
    bookmaker?: true
    timestamp?: true
  }

  export type ApiOddsSnapshotMaxAggregateInputType = {
    id?: true
    externalGameId?: true
    sportKey?: true
    homeTeam?: true
    awayTeam?: true
    commenceTime?: true
    bookmaker?: true
    timestamp?: true
  }

  export type ApiOddsSnapshotCountAggregateInputType = {
    id?: true
    externalGameId?: true
    sportKey?: true
    homeTeam?: true
    awayTeam?: true
    commenceTime?: true
    bookmaker?: true
    rawData?: true
    timestamp?: true
    _all?: true
  }

  export type ApiOddsSnapshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiOddsSnapshot to aggregate.
     */
    where?: ApiOddsSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiOddsSnapshots to fetch.
     */
    orderBy?: ApiOddsSnapshotOrderByWithRelationInput | ApiOddsSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiOddsSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiOddsSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiOddsSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiOddsSnapshots
    **/
    _count?: true | ApiOddsSnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiOddsSnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiOddsSnapshotMaxAggregateInputType
  }

  export type GetApiOddsSnapshotAggregateType<T extends ApiOddsSnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregateApiOddsSnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiOddsSnapshot[P]>
      : GetScalarType<T[P], AggregateApiOddsSnapshot[P]>
  }




  export type ApiOddsSnapshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiOddsSnapshotWhereInput
    orderBy?: ApiOddsSnapshotOrderByWithAggregationInput | ApiOddsSnapshotOrderByWithAggregationInput[]
    by: ApiOddsSnapshotScalarFieldEnum[] | ApiOddsSnapshotScalarFieldEnum
    having?: ApiOddsSnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiOddsSnapshotCountAggregateInputType | true
    _min?: ApiOddsSnapshotMinAggregateInputType
    _max?: ApiOddsSnapshotMaxAggregateInputType
  }

  export type ApiOddsSnapshotGroupByOutputType = {
    id: string
    externalGameId: string
    sportKey: string
    homeTeam: string
    awayTeam: string
    commenceTime: Date
    bookmaker: string
    rawData: JsonValue
    timestamp: Date
    _count: ApiOddsSnapshotCountAggregateOutputType | null
    _min: ApiOddsSnapshotMinAggregateOutputType | null
    _max: ApiOddsSnapshotMaxAggregateOutputType | null
  }

  type GetApiOddsSnapshotGroupByPayload<T extends ApiOddsSnapshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiOddsSnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiOddsSnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiOddsSnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], ApiOddsSnapshotGroupByOutputType[P]>
        }
      >
    >


  export type ApiOddsSnapshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalGameId?: boolean
    sportKey?: boolean
    homeTeam?: boolean
    awayTeam?: boolean
    commenceTime?: boolean
    bookmaker?: boolean
    rawData?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["apiOddsSnapshot"]>

  export type ApiOddsSnapshotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalGameId?: boolean
    sportKey?: boolean
    homeTeam?: boolean
    awayTeam?: boolean
    commenceTime?: boolean
    bookmaker?: boolean
    rawData?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["apiOddsSnapshot"]>

  export type ApiOddsSnapshotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalGameId?: boolean
    sportKey?: boolean
    homeTeam?: boolean
    awayTeam?: boolean
    commenceTime?: boolean
    bookmaker?: boolean
    rawData?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["apiOddsSnapshot"]>

  export type ApiOddsSnapshotSelectScalar = {
    id?: boolean
    externalGameId?: boolean
    sportKey?: boolean
    homeTeam?: boolean
    awayTeam?: boolean
    commenceTime?: boolean
    bookmaker?: boolean
    rawData?: boolean
    timestamp?: boolean
  }

  export type ApiOddsSnapshotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "externalGameId" | "sportKey" | "homeTeam" | "awayTeam" | "commenceTime" | "bookmaker" | "rawData" | "timestamp", ExtArgs["result"]["apiOddsSnapshot"]>

  export type $ApiOddsSnapshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiOddsSnapshot"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalGameId: string
      sportKey: string
      homeTeam: string
      awayTeam: string
      commenceTime: Date
      bookmaker: string
      rawData: Prisma.JsonValue
      timestamp: Date
    }, ExtArgs["result"]["apiOddsSnapshot"]>
    composites: {}
  }

  type ApiOddsSnapshotGetPayload<S extends boolean | null | undefined | ApiOddsSnapshotDefaultArgs> = $Result.GetResult<Prisma.$ApiOddsSnapshotPayload, S>

  type ApiOddsSnapshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiOddsSnapshotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiOddsSnapshotCountAggregateInputType | true
    }

  export interface ApiOddsSnapshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiOddsSnapshot'], meta: { name: 'ApiOddsSnapshot' } }
    /**
     * Find zero or one ApiOddsSnapshot that matches the filter.
     * @param {ApiOddsSnapshotFindUniqueArgs} args - Arguments to find a ApiOddsSnapshot
     * @example
     * // Get one ApiOddsSnapshot
     * const apiOddsSnapshot = await prisma.apiOddsSnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiOddsSnapshotFindUniqueArgs>(args: SelectSubset<T, ApiOddsSnapshotFindUniqueArgs<ExtArgs>>): Prisma__ApiOddsSnapshotClient<$Result.GetResult<Prisma.$ApiOddsSnapshotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiOddsSnapshot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiOddsSnapshotFindUniqueOrThrowArgs} args - Arguments to find a ApiOddsSnapshot
     * @example
     * // Get one ApiOddsSnapshot
     * const apiOddsSnapshot = await prisma.apiOddsSnapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiOddsSnapshotFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiOddsSnapshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiOddsSnapshotClient<$Result.GetResult<Prisma.$ApiOddsSnapshotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiOddsSnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiOddsSnapshotFindFirstArgs} args - Arguments to find a ApiOddsSnapshot
     * @example
     * // Get one ApiOddsSnapshot
     * const apiOddsSnapshot = await prisma.apiOddsSnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiOddsSnapshotFindFirstArgs>(args?: SelectSubset<T, ApiOddsSnapshotFindFirstArgs<ExtArgs>>): Prisma__ApiOddsSnapshotClient<$Result.GetResult<Prisma.$ApiOddsSnapshotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiOddsSnapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiOddsSnapshotFindFirstOrThrowArgs} args - Arguments to find a ApiOddsSnapshot
     * @example
     * // Get one ApiOddsSnapshot
     * const apiOddsSnapshot = await prisma.apiOddsSnapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiOddsSnapshotFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiOddsSnapshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiOddsSnapshotClient<$Result.GetResult<Prisma.$ApiOddsSnapshotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiOddsSnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiOddsSnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiOddsSnapshots
     * const apiOddsSnapshots = await prisma.apiOddsSnapshot.findMany()
     * 
     * // Get first 10 ApiOddsSnapshots
     * const apiOddsSnapshots = await prisma.apiOddsSnapshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiOddsSnapshotWithIdOnly = await prisma.apiOddsSnapshot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiOddsSnapshotFindManyArgs>(args?: SelectSubset<T, ApiOddsSnapshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiOddsSnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiOddsSnapshot.
     * @param {ApiOddsSnapshotCreateArgs} args - Arguments to create a ApiOddsSnapshot.
     * @example
     * // Create one ApiOddsSnapshot
     * const ApiOddsSnapshot = await prisma.apiOddsSnapshot.create({
     *   data: {
     *     // ... data to create a ApiOddsSnapshot
     *   }
     * })
     * 
     */
    create<T extends ApiOddsSnapshotCreateArgs>(args: SelectSubset<T, ApiOddsSnapshotCreateArgs<ExtArgs>>): Prisma__ApiOddsSnapshotClient<$Result.GetResult<Prisma.$ApiOddsSnapshotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiOddsSnapshots.
     * @param {ApiOddsSnapshotCreateManyArgs} args - Arguments to create many ApiOddsSnapshots.
     * @example
     * // Create many ApiOddsSnapshots
     * const apiOddsSnapshot = await prisma.apiOddsSnapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiOddsSnapshotCreateManyArgs>(args?: SelectSubset<T, ApiOddsSnapshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiOddsSnapshots and returns the data saved in the database.
     * @param {ApiOddsSnapshotCreateManyAndReturnArgs} args - Arguments to create many ApiOddsSnapshots.
     * @example
     * // Create many ApiOddsSnapshots
     * const apiOddsSnapshot = await prisma.apiOddsSnapshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiOddsSnapshots and only return the `id`
     * const apiOddsSnapshotWithIdOnly = await prisma.apiOddsSnapshot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiOddsSnapshotCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiOddsSnapshotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiOddsSnapshotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiOddsSnapshot.
     * @param {ApiOddsSnapshotDeleteArgs} args - Arguments to delete one ApiOddsSnapshot.
     * @example
     * // Delete one ApiOddsSnapshot
     * const ApiOddsSnapshot = await prisma.apiOddsSnapshot.delete({
     *   where: {
     *     // ... filter to delete one ApiOddsSnapshot
     *   }
     * })
     * 
     */
    delete<T extends ApiOddsSnapshotDeleteArgs>(args: SelectSubset<T, ApiOddsSnapshotDeleteArgs<ExtArgs>>): Prisma__ApiOddsSnapshotClient<$Result.GetResult<Prisma.$ApiOddsSnapshotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiOddsSnapshot.
     * @param {ApiOddsSnapshotUpdateArgs} args - Arguments to update one ApiOddsSnapshot.
     * @example
     * // Update one ApiOddsSnapshot
     * const apiOddsSnapshot = await prisma.apiOddsSnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiOddsSnapshotUpdateArgs>(args: SelectSubset<T, ApiOddsSnapshotUpdateArgs<ExtArgs>>): Prisma__ApiOddsSnapshotClient<$Result.GetResult<Prisma.$ApiOddsSnapshotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiOddsSnapshots.
     * @param {ApiOddsSnapshotDeleteManyArgs} args - Arguments to filter ApiOddsSnapshots to delete.
     * @example
     * // Delete a few ApiOddsSnapshots
     * const { count } = await prisma.apiOddsSnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiOddsSnapshotDeleteManyArgs>(args?: SelectSubset<T, ApiOddsSnapshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiOddsSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiOddsSnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiOddsSnapshots
     * const apiOddsSnapshot = await prisma.apiOddsSnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiOddsSnapshotUpdateManyArgs>(args: SelectSubset<T, ApiOddsSnapshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiOddsSnapshots and returns the data updated in the database.
     * @param {ApiOddsSnapshotUpdateManyAndReturnArgs} args - Arguments to update many ApiOddsSnapshots.
     * @example
     * // Update many ApiOddsSnapshots
     * const apiOddsSnapshot = await prisma.apiOddsSnapshot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiOddsSnapshots and only return the `id`
     * const apiOddsSnapshotWithIdOnly = await prisma.apiOddsSnapshot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiOddsSnapshotUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiOddsSnapshotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiOddsSnapshotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiOddsSnapshot.
     * @param {ApiOddsSnapshotUpsertArgs} args - Arguments to update or create a ApiOddsSnapshot.
     * @example
     * // Update or create a ApiOddsSnapshot
     * const apiOddsSnapshot = await prisma.apiOddsSnapshot.upsert({
     *   create: {
     *     // ... data to create a ApiOddsSnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiOddsSnapshot we want to update
     *   }
     * })
     */
    upsert<T extends ApiOddsSnapshotUpsertArgs>(args: SelectSubset<T, ApiOddsSnapshotUpsertArgs<ExtArgs>>): Prisma__ApiOddsSnapshotClient<$Result.GetResult<Prisma.$ApiOddsSnapshotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiOddsSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiOddsSnapshotCountArgs} args - Arguments to filter ApiOddsSnapshots to count.
     * @example
     * // Count the number of ApiOddsSnapshots
     * const count = await prisma.apiOddsSnapshot.count({
     *   where: {
     *     // ... the filter for the ApiOddsSnapshots we want to count
     *   }
     * })
    **/
    count<T extends ApiOddsSnapshotCountArgs>(
      args?: Subset<T, ApiOddsSnapshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiOddsSnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiOddsSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiOddsSnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiOddsSnapshotAggregateArgs>(args: Subset<T, ApiOddsSnapshotAggregateArgs>): Prisma.PrismaPromise<GetApiOddsSnapshotAggregateType<T>>

    /**
     * Group by ApiOddsSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiOddsSnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiOddsSnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiOddsSnapshotGroupByArgs['orderBy'] }
        : { orderBy?: ApiOddsSnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiOddsSnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiOddsSnapshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiOddsSnapshot model
   */
  readonly fields: ApiOddsSnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiOddsSnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiOddsSnapshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiOddsSnapshot model
   */
  interface ApiOddsSnapshotFieldRefs {
    readonly id: FieldRef<"ApiOddsSnapshot", 'String'>
    readonly externalGameId: FieldRef<"ApiOddsSnapshot", 'String'>
    readonly sportKey: FieldRef<"ApiOddsSnapshot", 'String'>
    readonly homeTeam: FieldRef<"ApiOddsSnapshot", 'String'>
    readonly awayTeam: FieldRef<"ApiOddsSnapshot", 'String'>
    readonly commenceTime: FieldRef<"ApiOddsSnapshot", 'DateTime'>
    readonly bookmaker: FieldRef<"ApiOddsSnapshot", 'String'>
    readonly rawData: FieldRef<"ApiOddsSnapshot", 'Json'>
    readonly timestamp: FieldRef<"ApiOddsSnapshot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiOddsSnapshot findUnique
   */
  export type ApiOddsSnapshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiOddsSnapshot
     */
    select?: ApiOddsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiOddsSnapshot
     */
    omit?: ApiOddsSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which ApiOddsSnapshot to fetch.
     */
    where: ApiOddsSnapshotWhereUniqueInput
  }

  /**
   * ApiOddsSnapshot findUniqueOrThrow
   */
  export type ApiOddsSnapshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiOddsSnapshot
     */
    select?: ApiOddsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiOddsSnapshot
     */
    omit?: ApiOddsSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which ApiOddsSnapshot to fetch.
     */
    where: ApiOddsSnapshotWhereUniqueInput
  }

  /**
   * ApiOddsSnapshot findFirst
   */
  export type ApiOddsSnapshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiOddsSnapshot
     */
    select?: ApiOddsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiOddsSnapshot
     */
    omit?: ApiOddsSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which ApiOddsSnapshot to fetch.
     */
    where?: ApiOddsSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiOddsSnapshots to fetch.
     */
    orderBy?: ApiOddsSnapshotOrderByWithRelationInput | ApiOddsSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiOddsSnapshots.
     */
    cursor?: ApiOddsSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiOddsSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiOddsSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiOddsSnapshots.
     */
    distinct?: ApiOddsSnapshotScalarFieldEnum | ApiOddsSnapshotScalarFieldEnum[]
  }

  /**
   * ApiOddsSnapshot findFirstOrThrow
   */
  export type ApiOddsSnapshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiOddsSnapshot
     */
    select?: ApiOddsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiOddsSnapshot
     */
    omit?: ApiOddsSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which ApiOddsSnapshot to fetch.
     */
    where?: ApiOddsSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiOddsSnapshots to fetch.
     */
    orderBy?: ApiOddsSnapshotOrderByWithRelationInput | ApiOddsSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiOddsSnapshots.
     */
    cursor?: ApiOddsSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiOddsSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiOddsSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiOddsSnapshots.
     */
    distinct?: ApiOddsSnapshotScalarFieldEnum | ApiOddsSnapshotScalarFieldEnum[]
  }

  /**
   * ApiOddsSnapshot findMany
   */
  export type ApiOddsSnapshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiOddsSnapshot
     */
    select?: ApiOddsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiOddsSnapshot
     */
    omit?: ApiOddsSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which ApiOddsSnapshots to fetch.
     */
    where?: ApiOddsSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiOddsSnapshots to fetch.
     */
    orderBy?: ApiOddsSnapshotOrderByWithRelationInput | ApiOddsSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiOddsSnapshots.
     */
    cursor?: ApiOddsSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiOddsSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiOddsSnapshots.
     */
    skip?: number
    distinct?: ApiOddsSnapshotScalarFieldEnum | ApiOddsSnapshotScalarFieldEnum[]
  }

  /**
   * ApiOddsSnapshot create
   */
  export type ApiOddsSnapshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiOddsSnapshot
     */
    select?: ApiOddsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiOddsSnapshot
     */
    omit?: ApiOddsSnapshotOmit<ExtArgs> | null
    /**
     * The data needed to create a ApiOddsSnapshot.
     */
    data: XOR<ApiOddsSnapshotCreateInput, ApiOddsSnapshotUncheckedCreateInput>
  }

  /**
   * ApiOddsSnapshot createMany
   */
  export type ApiOddsSnapshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiOddsSnapshots.
     */
    data: ApiOddsSnapshotCreateManyInput | ApiOddsSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiOddsSnapshot createManyAndReturn
   */
  export type ApiOddsSnapshotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiOddsSnapshot
     */
    select?: ApiOddsSnapshotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiOddsSnapshot
     */
    omit?: ApiOddsSnapshotOmit<ExtArgs> | null
    /**
     * The data used to create many ApiOddsSnapshots.
     */
    data: ApiOddsSnapshotCreateManyInput | ApiOddsSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiOddsSnapshot update
   */
  export type ApiOddsSnapshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiOddsSnapshot
     */
    select?: ApiOddsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiOddsSnapshot
     */
    omit?: ApiOddsSnapshotOmit<ExtArgs> | null
    /**
     * The data needed to update a ApiOddsSnapshot.
     */
    data: XOR<ApiOddsSnapshotUpdateInput, ApiOddsSnapshotUncheckedUpdateInput>
    /**
     * Choose, which ApiOddsSnapshot to update.
     */
    where: ApiOddsSnapshotWhereUniqueInput
  }

  /**
   * ApiOddsSnapshot updateMany
   */
  export type ApiOddsSnapshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiOddsSnapshots.
     */
    data: XOR<ApiOddsSnapshotUpdateManyMutationInput, ApiOddsSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which ApiOddsSnapshots to update
     */
    where?: ApiOddsSnapshotWhereInput
    /**
     * Limit how many ApiOddsSnapshots to update.
     */
    limit?: number
  }

  /**
   * ApiOddsSnapshot updateManyAndReturn
   */
  export type ApiOddsSnapshotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiOddsSnapshot
     */
    select?: ApiOddsSnapshotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiOddsSnapshot
     */
    omit?: ApiOddsSnapshotOmit<ExtArgs> | null
    /**
     * The data used to update ApiOddsSnapshots.
     */
    data: XOR<ApiOddsSnapshotUpdateManyMutationInput, ApiOddsSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which ApiOddsSnapshots to update
     */
    where?: ApiOddsSnapshotWhereInput
    /**
     * Limit how many ApiOddsSnapshots to update.
     */
    limit?: number
  }

  /**
   * ApiOddsSnapshot upsert
   */
  export type ApiOddsSnapshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiOddsSnapshot
     */
    select?: ApiOddsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiOddsSnapshot
     */
    omit?: ApiOddsSnapshotOmit<ExtArgs> | null
    /**
     * The filter to search for the ApiOddsSnapshot to update in case it exists.
     */
    where: ApiOddsSnapshotWhereUniqueInput
    /**
     * In case the ApiOddsSnapshot found by the `where` argument doesn't exist, create a new ApiOddsSnapshot with this data.
     */
    create: XOR<ApiOddsSnapshotCreateInput, ApiOddsSnapshotUncheckedCreateInput>
    /**
     * In case the ApiOddsSnapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiOddsSnapshotUpdateInput, ApiOddsSnapshotUncheckedUpdateInput>
  }

  /**
   * ApiOddsSnapshot delete
   */
  export type ApiOddsSnapshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiOddsSnapshot
     */
    select?: ApiOddsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiOddsSnapshot
     */
    omit?: ApiOddsSnapshotOmit<ExtArgs> | null
    /**
     * Filter which ApiOddsSnapshot to delete.
     */
    where: ApiOddsSnapshotWhereUniqueInput
  }

  /**
   * ApiOddsSnapshot deleteMany
   */
  export type ApiOddsSnapshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiOddsSnapshots to delete
     */
    where?: ApiOddsSnapshotWhereInput
    /**
     * Limit how many ApiOddsSnapshots to delete.
     */
    limit?: number
  }

  /**
   * ApiOddsSnapshot without action
   */
  export type ApiOddsSnapshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiOddsSnapshot
     */
    select?: ApiOddsSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiOddsSnapshot
     */
    omit?: ApiOddsSnapshotOmit<ExtArgs> | null
  }


  /**
   * Model OddsAuditLog
   */

  export type AggregateOddsAuditLog = {
    _count: OddsAuditLogCountAggregateOutputType | null
    _avg: OddsAuditLogAvgAggregateOutputType | null
    _sum: OddsAuditLogSumAggregateOutputType | null
    _min: OddsAuditLogMinAggregateOutputType | null
    _max: OddsAuditLogMaxAggregateOutputType | null
  }

  export type OddsAuditLogAvgAggregateOutputType = {
    oldOdds: Decimal | null
    newOdds: Decimal | null
    changePercent: Decimal | null
  }

  export type OddsAuditLogSumAggregateOutputType = {
    oldOdds: Decimal | null
    newOdds: Decimal | null
    changePercent: Decimal | null
  }

  export type OddsAuditLogMinAggregateOutputType = {
    id: string | null
    externalGameId: string | null
    sportKey: string | null
    marketKey: string | null
    selectionName: string | null
    bookmaker: string | null
    oldOdds: Decimal | null
    newOdds: Decimal | null
    changePercent: Decimal | null
    changeType: string | null
    createdAt: Date | null
  }

  export type OddsAuditLogMaxAggregateOutputType = {
    id: string | null
    externalGameId: string | null
    sportKey: string | null
    marketKey: string | null
    selectionName: string | null
    bookmaker: string | null
    oldOdds: Decimal | null
    newOdds: Decimal | null
    changePercent: Decimal | null
    changeType: string | null
    createdAt: Date | null
  }

  export type OddsAuditLogCountAggregateOutputType = {
    id: number
    externalGameId: number
    sportKey: number
    marketKey: number
    selectionName: number
    bookmaker: number
    oldOdds: number
    newOdds: number
    changePercent: number
    changeType: number
    createdAt: number
    _all: number
  }


  export type OddsAuditLogAvgAggregateInputType = {
    oldOdds?: true
    newOdds?: true
    changePercent?: true
  }

  export type OddsAuditLogSumAggregateInputType = {
    oldOdds?: true
    newOdds?: true
    changePercent?: true
  }

  export type OddsAuditLogMinAggregateInputType = {
    id?: true
    externalGameId?: true
    sportKey?: true
    marketKey?: true
    selectionName?: true
    bookmaker?: true
    oldOdds?: true
    newOdds?: true
    changePercent?: true
    changeType?: true
    createdAt?: true
  }

  export type OddsAuditLogMaxAggregateInputType = {
    id?: true
    externalGameId?: true
    sportKey?: true
    marketKey?: true
    selectionName?: true
    bookmaker?: true
    oldOdds?: true
    newOdds?: true
    changePercent?: true
    changeType?: true
    createdAt?: true
  }

  export type OddsAuditLogCountAggregateInputType = {
    id?: true
    externalGameId?: true
    sportKey?: true
    marketKey?: true
    selectionName?: true
    bookmaker?: true
    oldOdds?: true
    newOdds?: true
    changePercent?: true
    changeType?: true
    createdAt?: true
    _all?: true
  }

  export type OddsAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OddsAuditLog to aggregate.
     */
    where?: OddsAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OddsAuditLogs to fetch.
     */
    orderBy?: OddsAuditLogOrderByWithRelationInput | OddsAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OddsAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OddsAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OddsAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OddsAuditLogs
    **/
    _count?: true | OddsAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OddsAuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OddsAuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OddsAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OddsAuditLogMaxAggregateInputType
  }

  export type GetOddsAuditLogAggregateType<T extends OddsAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateOddsAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOddsAuditLog[P]>
      : GetScalarType<T[P], AggregateOddsAuditLog[P]>
  }




  export type OddsAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OddsAuditLogWhereInput
    orderBy?: OddsAuditLogOrderByWithAggregationInput | OddsAuditLogOrderByWithAggregationInput[]
    by: OddsAuditLogScalarFieldEnum[] | OddsAuditLogScalarFieldEnum
    having?: OddsAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OddsAuditLogCountAggregateInputType | true
    _avg?: OddsAuditLogAvgAggregateInputType
    _sum?: OddsAuditLogSumAggregateInputType
    _min?: OddsAuditLogMinAggregateInputType
    _max?: OddsAuditLogMaxAggregateInputType
  }

  export type OddsAuditLogGroupByOutputType = {
    id: string
    externalGameId: string
    sportKey: string
    marketKey: string
    selectionName: string
    bookmaker: string
    oldOdds: Decimal
    newOdds: Decimal
    changePercent: Decimal
    changeType: string
    createdAt: Date
    _count: OddsAuditLogCountAggregateOutputType | null
    _avg: OddsAuditLogAvgAggregateOutputType | null
    _sum: OddsAuditLogSumAggregateOutputType | null
    _min: OddsAuditLogMinAggregateOutputType | null
    _max: OddsAuditLogMaxAggregateOutputType | null
  }

  type GetOddsAuditLogGroupByPayload<T extends OddsAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OddsAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OddsAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OddsAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], OddsAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type OddsAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalGameId?: boolean
    sportKey?: boolean
    marketKey?: boolean
    selectionName?: boolean
    bookmaker?: boolean
    oldOdds?: boolean
    newOdds?: boolean
    changePercent?: boolean
    changeType?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["oddsAuditLog"]>

  export type OddsAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalGameId?: boolean
    sportKey?: boolean
    marketKey?: boolean
    selectionName?: boolean
    bookmaker?: boolean
    oldOdds?: boolean
    newOdds?: boolean
    changePercent?: boolean
    changeType?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["oddsAuditLog"]>

  export type OddsAuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalGameId?: boolean
    sportKey?: boolean
    marketKey?: boolean
    selectionName?: boolean
    bookmaker?: boolean
    oldOdds?: boolean
    newOdds?: boolean
    changePercent?: boolean
    changeType?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["oddsAuditLog"]>

  export type OddsAuditLogSelectScalar = {
    id?: boolean
    externalGameId?: boolean
    sportKey?: boolean
    marketKey?: boolean
    selectionName?: boolean
    bookmaker?: boolean
    oldOdds?: boolean
    newOdds?: boolean
    changePercent?: boolean
    changeType?: boolean
    createdAt?: boolean
  }

  export type OddsAuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "externalGameId" | "sportKey" | "marketKey" | "selectionName" | "bookmaker" | "oldOdds" | "newOdds" | "changePercent" | "changeType" | "createdAt", ExtArgs["result"]["oddsAuditLog"]>

  export type $OddsAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OddsAuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalGameId: string
      sportKey: string
      marketKey: string
      selectionName: string
      bookmaker: string
      oldOdds: Prisma.Decimal
      newOdds: Prisma.Decimal
      changePercent: Prisma.Decimal
      changeType: string
      createdAt: Date
    }, ExtArgs["result"]["oddsAuditLog"]>
    composites: {}
  }

  type OddsAuditLogGetPayload<S extends boolean | null | undefined | OddsAuditLogDefaultArgs> = $Result.GetResult<Prisma.$OddsAuditLogPayload, S>

  type OddsAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OddsAuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OddsAuditLogCountAggregateInputType | true
    }

  export interface OddsAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OddsAuditLog'], meta: { name: 'OddsAuditLog' } }
    /**
     * Find zero or one OddsAuditLog that matches the filter.
     * @param {OddsAuditLogFindUniqueArgs} args - Arguments to find a OddsAuditLog
     * @example
     * // Get one OddsAuditLog
     * const oddsAuditLog = await prisma.oddsAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OddsAuditLogFindUniqueArgs>(args: SelectSubset<T, OddsAuditLogFindUniqueArgs<ExtArgs>>): Prisma__OddsAuditLogClient<$Result.GetResult<Prisma.$OddsAuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OddsAuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OddsAuditLogFindUniqueOrThrowArgs} args - Arguments to find a OddsAuditLog
     * @example
     * // Get one OddsAuditLog
     * const oddsAuditLog = await prisma.oddsAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OddsAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, OddsAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OddsAuditLogClient<$Result.GetResult<Prisma.$OddsAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OddsAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsAuditLogFindFirstArgs} args - Arguments to find a OddsAuditLog
     * @example
     * // Get one OddsAuditLog
     * const oddsAuditLog = await prisma.oddsAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OddsAuditLogFindFirstArgs>(args?: SelectSubset<T, OddsAuditLogFindFirstArgs<ExtArgs>>): Prisma__OddsAuditLogClient<$Result.GetResult<Prisma.$OddsAuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OddsAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsAuditLogFindFirstOrThrowArgs} args - Arguments to find a OddsAuditLog
     * @example
     * // Get one OddsAuditLog
     * const oddsAuditLog = await prisma.oddsAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OddsAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, OddsAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__OddsAuditLogClient<$Result.GetResult<Prisma.$OddsAuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OddsAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OddsAuditLogs
     * const oddsAuditLogs = await prisma.oddsAuditLog.findMany()
     * 
     * // Get first 10 OddsAuditLogs
     * const oddsAuditLogs = await prisma.oddsAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oddsAuditLogWithIdOnly = await prisma.oddsAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OddsAuditLogFindManyArgs>(args?: SelectSubset<T, OddsAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OddsAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OddsAuditLog.
     * @param {OddsAuditLogCreateArgs} args - Arguments to create a OddsAuditLog.
     * @example
     * // Create one OddsAuditLog
     * const OddsAuditLog = await prisma.oddsAuditLog.create({
     *   data: {
     *     // ... data to create a OddsAuditLog
     *   }
     * })
     * 
     */
    create<T extends OddsAuditLogCreateArgs>(args: SelectSubset<T, OddsAuditLogCreateArgs<ExtArgs>>): Prisma__OddsAuditLogClient<$Result.GetResult<Prisma.$OddsAuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OddsAuditLogs.
     * @param {OddsAuditLogCreateManyArgs} args - Arguments to create many OddsAuditLogs.
     * @example
     * // Create many OddsAuditLogs
     * const oddsAuditLog = await prisma.oddsAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OddsAuditLogCreateManyArgs>(args?: SelectSubset<T, OddsAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OddsAuditLogs and returns the data saved in the database.
     * @param {OddsAuditLogCreateManyAndReturnArgs} args - Arguments to create many OddsAuditLogs.
     * @example
     * // Create many OddsAuditLogs
     * const oddsAuditLog = await prisma.oddsAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OddsAuditLogs and only return the `id`
     * const oddsAuditLogWithIdOnly = await prisma.oddsAuditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OddsAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, OddsAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OddsAuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OddsAuditLog.
     * @param {OddsAuditLogDeleteArgs} args - Arguments to delete one OddsAuditLog.
     * @example
     * // Delete one OddsAuditLog
     * const OddsAuditLog = await prisma.oddsAuditLog.delete({
     *   where: {
     *     // ... filter to delete one OddsAuditLog
     *   }
     * })
     * 
     */
    delete<T extends OddsAuditLogDeleteArgs>(args: SelectSubset<T, OddsAuditLogDeleteArgs<ExtArgs>>): Prisma__OddsAuditLogClient<$Result.GetResult<Prisma.$OddsAuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OddsAuditLog.
     * @param {OddsAuditLogUpdateArgs} args - Arguments to update one OddsAuditLog.
     * @example
     * // Update one OddsAuditLog
     * const oddsAuditLog = await prisma.oddsAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OddsAuditLogUpdateArgs>(args: SelectSubset<T, OddsAuditLogUpdateArgs<ExtArgs>>): Prisma__OddsAuditLogClient<$Result.GetResult<Prisma.$OddsAuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OddsAuditLogs.
     * @param {OddsAuditLogDeleteManyArgs} args - Arguments to filter OddsAuditLogs to delete.
     * @example
     * // Delete a few OddsAuditLogs
     * const { count } = await prisma.oddsAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OddsAuditLogDeleteManyArgs>(args?: SelectSubset<T, OddsAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OddsAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OddsAuditLogs
     * const oddsAuditLog = await prisma.oddsAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OddsAuditLogUpdateManyArgs>(args: SelectSubset<T, OddsAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OddsAuditLogs and returns the data updated in the database.
     * @param {OddsAuditLogUpdateManyAndReturnArgs} args - Arguments to update many OddsAuditLogs.
     * @example
     * // Update many OddsAuditLogs
     * const oddsAuditLog = await prisma.oddsAuditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OddsAuditLogs and only return the `id`
     * const oddsAuditLogWithIdOnly = await prisma.oddsAuditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OddsAuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, OddsAuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OddsAuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OddsAuditLog.
     * @param {OddsAuditLogUpsertArgs} args - Arguments to update or create a OddsAuditLog.
     * @example
     * // Update or create a OddsAuditLog
     * const oddsAuditLog = await prisma.oddsAuditLog.upsert({
     *   create: {
     *     // ... data to create a OddsAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OddsAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends OddsAuditLogUpsertArgs>(args: SelectSubset<T, OddsAuditLogUpsertArgs<ExtArgs>>): Prisma__OddsAuditLogClient<$Result.GetResult<Prisma.$OddsAuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OddsAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsAuditLogCountArgs} args - Arguments to filter OddsAuditLogs to count.
     * @example
     * // Count the number of OddsAuditLogs
     * const count = await prisma.oddsAuditLog.count({
     *   where: {
     *     // ... the filter for the OddsAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends OddsAuditLogCountArgs>(
      args?: Subset<T, OddsAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OddsAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OddsAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OddsAuditLogAggregateArgs>(args: Subset<T, OddsAuditLogAggregateArgs>): Prisma.PrismaPromise<GetOddsAuditLogAggregateType<T>>

    /**
     * Group by OddsAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OddsAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OddsAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OddsAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: OddsAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OddsAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOddsAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OddsAuditLog model
   */
  readonly fields: OddsAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OddsAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OddsAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OddsAuditLog model
   */
  interface OddsAuditLogFieldRefs {
    readonly id: FieldRef<"OddsAuditLog", 'String'>
    readonly externalGameId: FieldRef<"OddsAuditLog", 'String'>
    readonly sportKey: FieldRef<"OddsAuditLog", 'String'>
    readonly marketKey: FieldRef<"OddsAuditLog", 'String'>
    readonly selectionName: FieldRef<"OddsAuditLog", 'String'>
    readonly bookmaker: FieldRef<"OddsAuditLog", 'String'>
    readonly oldOdds: FieldRef<"OddsAuditLog", 'Decimal'>
    readonly newOdds: FieldRef<"OddsAuditLog", 'Decimal'>
    readonly changePercent: FieldRef<"OddsAuditLog", 'Decimal'>
    readonly changeType: FieldRef<"OddsAuditLog", 'String'>
    readonly createdAt: FieldRef<"OddsAuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OddsAuditLog findUnique
   */
  export type OddsAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsAuditLog
     */
    select?: OddsAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsAuditLog
     */
    omit?: OddsAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which OddsAuditLog to fetch.
     */
    where: OddsAuditLogWhereUniqueInput
  }

  /**
   * OddsAuditLog findUniqueOrThrow
   */
  export type OddsAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsAuditLog
     */
    select?: OddsAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsAuditLog
     */
    omit?: OddsAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which OddsAuditLog to fetch.
     */
    where: OddsAuditLogWhereUniqueInput
  }

  /**
   * OddsAuditLog findFirst
   */
  export type OddsAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsAuditLog
     */
    select?: OddsAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsAuditLog
     */
    omit?: OddsAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which OddsAuditLog to fetch.
     */
    where?: OddsAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OddsAuditLogs to fetch.
     */
    orderBy?: OddsAuditLogOrderByWithRelationInput | OddsAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OddsAuditLogs.
     */
    cursor?: OddsAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OddsAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OddsAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OddsAuditLogs.
     */
    distinct?: OddsAuditLogScalarFieldEnum | OddsAuditLogScalarFieldEnum[]
  }

  /**
   * OddsAuditLog findFirstOrThrow
   */
  export type OddsAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsAuditLog
     */
    select?: OddsAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsAuditLog
     */
    omit?: OddsAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which OddsAuditLog to fetch.
     */
    where?: OddsAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OddsAuditLogs to fetch.
     */
    orderBy?: OddsAuditLogOrderByWithRelationInput | OddsAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OddsAuditLogs.
     */
    cursor?: OddsAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OddsAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OddsAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OddsAuditLogs.
     */
    distinct?: OddsAuditLogScalarFieldEnum | OddsAuditLogScalarFieldEnum[]
  }

  /**
   * OddsAuditLog findMany
   */
  export type OddsAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsAuditLog
     */
    select?: OddsAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsAuditLog
     */
    omit?: OddsAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which OddsAuditLogs to fetch.
     */
    where?: OddsAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OddsAuditLogs to fetch.
     */
    orderBy?: OddsAuditLogOrderByWithRelationInput | OddsAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OddsAuditLogs.
     */
    cursor?: OddsAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OddsAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OddsAuditLogs.
     */
    skip?: number
    distinct?: OddsAuditLogScalarFieldEnum | OddsAuditLogScalarFieldEnum[]
  }

  /**
   * OddsAuditLog create
   */
  export type OddsAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsAuditLog
     */
    select?: OddsAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsAuditLog
     */
    omit?: OddsAuditLogOmit<ExtArgs> | null
    /**
     * The data needed to create a OddsAuditLog.
     */
    data: XOR<OddsAuditLogCreateInput, OddsAuditLogUncheckedCreateInput>
  }

  /**
   * OddsAuditLog createMany
   */
  export type OddsAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OddsAuditLogs.
     */
    data: OddsAuditLogCreateManyInput | OddsAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OddsAuditLog createManyAndReturn
   */
  export type OddsAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsAuditLog
     */
    select?: OddsAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OddsAuditLog
     */
    omit?: OddsAuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many OddsAuditLogs.
     */
    data: OddsAuditLogCreateManyInput | OddsAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OddsAuditLog update
   */
  export type OddsAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsAuditLog
     */
    select?: OddsAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsAuditLog
     */
    omit?: OddsAuditLogOmit<ExtArgs> | null
    /**
     * The data needed to update a OddsAuditLog.
     */
    data: XOR<OddsAuditLogUpdateInput, OddsAuditLogUncheckedUpdateInput>
    /**
     * Choose, which OddsAuditLog to update.
     */
    where: OddsAuditLogWhereUniqueInput
  }

  /**
   * OddsAuditLog updateMany
   */
  export type OddsAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OddsAuditLogs.
     */
    data: XOR<OddsAuditLogUpdateManyMutationInput, OddsAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which OddsAuditLogs to update
     */
    where?: OddsAuditLogWhereInput
    /**
     * Limit how many OddsAuditLogs to update.
     */
    limit?: number
  }

  /**
   * OddsAuditLog updateManyAndReturn
   */
  export type OddsAuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsAuditLog
     */
    select?: OddsAuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OddsAuditLog
     */
    omit?: OddsAuditLogOmit<ExtArgs> | null
    /**
     * The data used to update OddsAuditLogs.
     */
    data: XOR<OddsAuditLogUpdateManyMutationInput, OddsAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which OddsAuditLogs to update
     */
    where?: OddsAuditLogWhereInput
    /**
     * Limit how many OddsAuditLogs to update.
     */
    limit?: number
  }

  /**
   * OddsAuditLog upsert
   */
  export type OddsAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsAuditLog
     */
    select?: OddsAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsAuditLog
     */
    omit?: OddsAuditLogOmit<ExtArgs> | null
    /**
     * The filter to search for the OddsAuditLog to update in case it exists.
     */
    where: OddsAuditLogWhereUniqueInput
    /**
     * In case the OddsAuditLog found by the `where` argument doesn't exist, create a new OddsAuditLog with this data.
     */
    create: XOR<OddsAuditLogCreateInput, OddsAuditLogUncheckedCreateInput>
    /**
     * In case the OddsAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OddsAuditLogUpdateInput, OddsAuditLogUncheckedUpdateInput>
  }

  /**
   * OddsAuditLog delete
   */
  export type OddsAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsAuditLog
     */
    select?: OddsAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsAuditLog
     */
    omit?: OddsAuditLogOmit<ExtArgs> | null
    /**
     * Filter which OddsAuditLog to delete.
     */
    where: OddsAuditLogWhereUniqueInput
  }

  /**
   * OddsAuditLog deleteMany
   */
  export type OddsAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OddsAuditLogs to delete
     */
    where?: OddsAuditLogWhereInput
    /**
     * Limit how many OddsAuditLogs to delete.
     */
    limit?: number
  }

  /**
   * OddsAuditLog without action
   */
  export type OddsAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OddsAuditLog
     */
    select?: OddsAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OddsAuditLog
     */
    omit?: OddsAuditLogOmit<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    priority: string | null
    title: string | null
    message: string | null
    read: boolean | null
    dismissed: boolean | null
    actionUrl: string | null
    actionLabel: string | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    priority: string | null
    title: string | null
    message: string | null
    read: boolean | null
    dismissed: boolean | null
    actionUrl: string | null
    actionLabel: string | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    priority: number
    title: number
    message: number
    read: number
    dismissed: number
    actionUrl: number
    actionLabel: number
    metadata: number
    createdAt: number
    readAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    priority?: true
    title?: true
    message?: true
    read?: true
    dismissed?: true
    actionUrl?: true
    actionLabel?: true
    createdAt?: true
    readAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    priority?: true
    title?: true
    message?: true
    read?: true
    dismissed?: true
    actionUrl?: true
    actionLabel?: true
    createdAt?: true
    readAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    priority?: true
    title?: true
    message?: true
    read?: true
    dismissed?: true
    actionUrl?: true
    actionLabel?: true
    metadata?: true
    createdAt?: true
    readAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    priority: string
    title: string
    message: string
    read: boolean
    dismissed: boolean
    actionUrl: string | null
    actionLabel: string | null
    metadata: JsonValue | null
    createdAt: Date
    readAt: Date | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    priority?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    dismissed?: boolean
    actionUrl?: boolean
    actionLabel?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    priority?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    dismissed?: boolean
    actionUrl?: boolean
    actionLabel?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    priority?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    dismissed?: boolean
    actionUrl?: boolean
    actionLabel?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    priority?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    dismissed?: boolean
    actionUrl?: boolean
    actionLabel?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "priority" | "title" | "message" | "read" | "dismissed" | "actionUrl" | "actionLabel" | "metadata" | "createdAt" | "readAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      priority: string
      title: string
      message: string
      read: boolean
      dismissed: boolean
      actionUrl: string | null
      actionLabel: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      readAt: Date | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly priority: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly dismissed: FieldRef<"Notification", 'Boolean'>
    readonly actionUrl: FieldRef<"Notification", 'String'>
    readonly actionLabel: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    accountStatus: 'accountStatus',
    kycVerified: 'kycVerified',
    kycLevel: 'kycLevel',
    gdprConsentGiven: 'gdprConsentGiven',
    marketingConsent: 'marketingConsent',
    riskScore: 'riskScore',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    dateOfBirth: 'dateOfBirth',
    address: 'address',
    phoneNumber: 'phoneNumber',
    country: 'country',
    timezone: 'timezone',
    language: 'language',
    marketingOptIn: 'marketingOptIn',
    responsibleGamingSettings: 'responsibleGamingSettings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const UserPasswordScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    passwordHash: 'passwordHash',
    passwordHistory: 'passwordHistory',
    resetToken: 'resetToken',
    resetTokenExpiresAt: 'resetTokenExpiresAt',
    passwordChangedAt: 'passwordChangedAt',
    failedLoginAttempts: 'failedLoginAttempts',
    lockedUntil: 'lockedUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPasswordScalarFieldEnum = (typeof UserPasswordScalarFieldEnum)[keyof typeof UserPasswordScalarFieldEnum]


  export const TwoFactorAuthScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    method: 'method',
    secretKey: 'secretKey',
    backupCodes: 'backupCodes',
    enabled: 'enabled',
    lastVerifiedAt: 'lastVerifiedAt',
    recoveryEmail: 'recoveryEmail',
    recoveryPhone: 'recoveryPhone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwoFactorAuthScalarFieldEnum = (typeof TwoFactorAuthScalarFieldEnum)[keyof typeof TwoFactorAuthScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    deviceFingerprint: 'deviceFingerprint',
    ipAddressHash: 'ipAddressHash',
    userAgent: 'userAgent',
    lastActivityAt: 'lastActivityAt',
    expiresAt: 'expiresAt',
    revoked: 'revoked',
    createdAt: 'createdAt'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const LoginAttemptScalarFieldEnum: {
    id: 'id',
    emailHash: 'emailHash',
    ipAddressHash: 'ipAddressHash',
    success: 'success',
    deviceFingerprint: 'deviceFingerprint',
    country: 'country',
    region: 'region',
    city: 'city',
    riskScore: 'riskScore',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type LoginAttemptScalarFieldEnum = (typeof LoginAttemptScalarFieldEnum)[keyof typeof LoginAttemptScalarFieldEnum]


  export const SportScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    active: 'active',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SportScalarFieldEnum = (typeof SportScalarFieldEnum)[keyof typeof SportScalarFieldEnum]


  export const LeagueScalarFieldEnum: {
    id: 'id',
    sportId: 'sportId',
    name: 'name',
    code: 'code',
    country: 'country',
    region: 'region',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeagueScalarFieldEnum = (typeof LeagueScalarFieldEnum)[keyof typeof LeagueScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    leagueId: 'leagueId',
    name: 'name',
    code: 'code',
    logoUrl: 'logoUrl',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const GameScalarFieldEnum: {
    id: 'id',
    sportId: 'sportId',
    leagueId: 'leagueId',
    homeTeamId: 'homeTeamId',
    awayTeamId: 'awayTeamId',
    scheduledStartAt: 'scheduledStartAt',
    actualStartAt: 'actualStartAt',
    status: 'status',
    homeScore: 'homeScore',
    awayScore: 'awayScore',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameScalarFieldEnum = (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum]


  export const BetMarketScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    marketType: 'marketType',
    name: 'name',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BetMarketScalarFieldEnum = (typeof BetMarketScalarFieldEnum)[keyof typeof BetMarketScalarFieldEnum]


  export const BetSelectionScalarFieldEnum: {
    id: 'id',
    marketId: 'marketId',
    name: 'name',
    odds: 'odds',
    status: 'status',
    result: 'result',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BetSelectionScalarFieldEnum = (typeof BetSelectionScalarFieldEnum)[keyof typeof BetSelectionScalarFieldEnum]


  export const BetScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    betType: 'betType',
    totalStake: 'totalStake',
    potentialPayout: 'potentialPayout',
    actualPayout: 'actualPayout',
    status: 'status',
    placedAt: 'placedAt',
    settledAt: 'settledAt',
    cashoutAt: 'cashoutAt',
    oddsSnapshot: 'oddsSnapshot',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BetScalarFieldEnum = (typeof BetScalarFieldEnum)[keyof typeof BetScalarFieldEnum]


  export const BetSelectionBetScalarFieldEnum: {
    id: 'id',
    betId: 'betId',
    selectionId: 'selectionId',
    oddsAtBet: 'oddsAtBet',
    result: 'result',
    createdAt: 'createdAt'
  };

  export type BetSelectionBetScalarFieldEnum = (typeof BetSelectionBetScalarFieldEnum)[keyof typeof BetSelectionBetScalarFieldEnum]


  export const FinancialAccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accountType: 'accountType',
    balance: 'balance',
    availableBalance: 'availableBalance',
    lockedBalance: 'lockedBalance',
    currency: 'currency',
    lastTransactionAt: 'lastTransactionAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FinancialAccountScalarFieldEnum = (typeof FinancialAccountScalarFieldEnum)[keyof typeof FinancialAccountScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accountId: 'accountId',
    transactionType: 'transactionType',
    amount: 'amount',
    balanceBefore: 'balanceBefore',
    balanceAfter: 'balanceAfter',
    status: 'status',
    paymentMethodId: 'paymentMethodId',
    externalTransactionId: 'externalTransactionId',
    description: 'description',
    metadata: 'metadata',
    createdAt: 'createdAt',
    processedAt: 'processedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const PaymentMethodScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    paymentType: 'paymentType',
    provider: 'provider',
    tokenizedId: 'tokenizedId',
    last4Digits: 'last4Digits',
    expiryDate: 'expiryDate',
    billingAddress: 'billingAddress',
    isDefault: 'isDefault',
    verified: 'verified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


  export const DepositScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    paymentMethodId: 'paymentMethodId',
    amount: 'amount',
    feeAmount: 'feeAmount',
    netAmount: 'netAmount',
    providerTransactionId: 'providerTransactionId',
    status: 'status',
    providerResponse: 'providerResponse',
    processedAt: 'processedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepositScalarFieldEnum = (typeof DepositScalarFieldEnum)[keyof typeof DepositScalarFieldEnum]


  export const WithdrawalScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    paymentMethodId: 'paymentMethodId',
    amount: 'amount',
    feeAmount: 'feeAmount',
    netAmount: 'netAmount',
    status: 'status',
    providerTransactionId: 'providerTransactionId',
    providerResponse: 'providerResponse',
    kycVerificationRequired: 'kycVerificationRequired',
    requestedAt: 'requestedAt',
    processedAt: 'processedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WithdrawalScalarFieldEnum = (typeof WithdrawalScalarFieldEnum)[keyof typeof WithdrawalScalarFieldEnum]


  export const FraudEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    eventType: 'eventType',
    severity: 'severity',
    riskScore: 'riskScore',
    description: 'description',
    metadata: 'metadata',
    status: 'status',
    reviewedBy: 'reviewedBy',
    reviewedAt: 'reviewedAt',
    createdAt: 'createdAt'
  };

  export type FraudEventScalarFieldEnum = (typeof FraudEventScalarFieldEnum)[keyof typeof FraudEventScalarFieldEnum]


  export const BettingPatternScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    patternType: 'patternType',
    patternDetails: 'patternDetails',
    detectedAt: 'detectedAt',
    riskScore: 'riskScore',
    actionTaken: 'actionTaken'
  };

  export type BettingPatternScalarFieldEnum = (typeof BettingPatternScalarFieldEnum)[keyof typeof BettingPatternScalarFieldEnum]


  export const AccountActivityLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    activityType: 'activityType',
    ipAddressHash: 'ipAddressHash',
    deviceFingerprint: 'deviceFingerprint',
    country: 'country',
    region: 'region',
    city: 'city',
    userAgent: 'userAgent',
    success: 'success',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AccountActivityLogScalarFieldEnum = (typeof AccountActivityLogScalarFieldEnum)[keyof typeof AccountActivityLogScalarFieldEnum]


  export const DeviceRegistryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    deviceFingerprint: 'deviceFingerprint',
    deviceName: 'deviceName',
    deviceType: 'deviceType',
    os: 'os',
    browser: 'browser',
    trusted: 'trusted',
    blocked: 'blocked',
    firstSeenAt: 'firstSeenAt',
    lastSeenAt: 'lastSeenAt'
  };

  export type DeviceRegistryScalarFieldEnum = (typeof DeviceRegistryScalarFieldEnum)[keyof typeof DeviceRegistryScalarFieldEnum]


  export const IpAddressScalarFieldEnum: {
    id: 'id',
    ipAddressHash: 'ipAddressHash',
    country: 'country',
    region: 'region',
    city: 'city',
    isp: 'isp',
    isVpn: 'isVpn',
    isProxy: 'isProxy',
    riskScore: 'riskScore',
    blocked: 'blocked',
    firstSeenAt: 'firstSeenAt',
    lastSeenAt: 'lastSeenAt'
  };

  export type IpAddressScalarFieldEnum = (typeof IpAddressScalarFieldEnum)[keyof typeof IpAddressScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    action: 'action',
    userId: 'userId',
    ipAddressHash: 'ipAddressHash',
    changes: 'changes',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const GdprConsentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    consentType: 'consentType',
    consentStatus: 'consentStatus',
    consentMethod: 'consentMethod',
    ipAddressHash: 'ipAddressHash',
    withdrawnAt: 'withdrawnAt',
    createdAt: 'createdAt'
  };

  export type GdprConsentScalarFieldEnum = (typeof GdprConsentScalarFieldEnum)[keyof typeof GdprConsentScalarFieldEnum]


  export const DataDeletionRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    requestedAt: 'requestedAt',
    processedAt: 'processedAt',
    rejectionReason: 'rejectionReason',
    dataDeleted: 'dataDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DataDeletionRequestScalarFieldEnum = (typeof DataDeletionRequestScalarFieldEnum)[keyof typeof DataDeletionRequestScalarFieldEnum]


  export const DataExportRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    exportFormat: 'exportFormat',
    filePath: 'filePath',
    expiresAt: 'expiresAt',
    requestedAt: 'requestedAt',
    processedAt: 'processedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DataExportRequestScalarFieldEnum = (typeof DataExportRequestScalarFieldEnum)[keyof typeof DataExportRequestScalarFieldEnum]


  export const SecurityAlertScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    alertType: 'alertType',
    severity: 'severity',
    description: 'description',
    actionRequired: 'actionRequired',
    acknowledged: 'acknowledged',
    createdAt: 'createdAt'
  };

  export type SecurityAlertScalarFieldEnum = (typeof SecurityAlertScalarFieldEnum)[keyof typeof SecurityAlertScalarFieldEnum]


  export const PromotionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    promotionType: 'promotionType',
    termsAndConditions: 'termsAndConditions',
    startDate: 'startDate',
    endDate: 'endDate',
    active: 'active',
    eligibilityCriteria: 'eligibilityCriteria',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromotionScalarFieldEnum = (typeof PromotionScalarFieldEnum)[keyof typeof PromotionScalarFieldEnum]


  export const UserBonusScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    promotionId: 'promotionId',
    bonusAmount: 'bonusAmount',
    wageringRequirement: 'wageringRequirement',
    wageredAmount: 'wageredAmount',
    status: 'status',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserBonusScalarFieldEnum = (typeof UserBonusScalarFieldEnum)[keyof typeof UserBonusScalarFieldEnum]


  export const CurrentOddsScalarFieldEnum: {
    id: 'id',
    selectionId: 'selectionId',
    currentOdds: 'currentOdds',
    previousOdds: 'previousOdds',
    oddsMovement: 'oddsMovement',
    lastUpdatedAt: 'lastUpdatedAt',
    syncedAt: 'syncedAt',
    externalOddsId: 'externalOddsId',
    suspended: 'suspended'
  };

  export type CurrentOddsScalarFieldEnum = (typeof CurrentOddsScalarFieldEnum)[keyof typeof CurrentOddsScalarFieldEnum]


  export const OddsSnapshotScalarFieldEnum: {
    id: 'id',
    selectionId: 'selectionId',
    odds: 'odds',
    timestamp: 'timestamp',
    source: 'source',
    metadata: 'metadata'
  };

  export type OddsSnapshotScalarFieldEnum = (typeof OddsSnapshotScalarFieldEnum)[keyof typeof OddsSnapshotScalarFieldEnum]


  export const OddsSyncStatusScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    lastSyncAt: 'lastSyncAt',
    nextSyncAt: 'nextSyncAt',
    syncStatus: 'syncStatus',
    failureCount: 'failureCount',
    lastError: 'lastError',
    syncInterval: 'syncInterval'
  };

  export type OddsSyncStatusScalarFieldEnum = (typeof OddsSyncStatusScalarFieldEnum)[keyof typeof OddsSyncStatusScalarFieldEnum]


  export const OddsChangeEventScalarFieldEnum: {
    id: 'id',
    selectionId: 'selectionId',
    gameId: 'gameId',
    oldOdds: 'oldOdds',
    newOdds: 'newOdds',
    changePercentage: 'changePercentage',
    changeType: 'changeType',
    broadcasted: 'broadcasted',
    createdAt: 'createdAt'
  };

  export type OddsChangeEventScalarFieldEnum = (typeof OddsChangeEventScalarFieldEnum)[keyof typeof OddsChangeEventScalarFieldEnum]


  export const ApiOddsSnapshotScalarFieldEnum: {
    id: 'id',
    externalGameId: 'externalGameId',
    sportKey: 'sportKey',
    homeTeam: 'homeTeam',
    awayTeam: 'awayTeam',
    commenceTime: 'commenceTime',
    bookmaker: 'bookmaker',
    rawData: 'rawData',
    timestamp: 'timestamp'
  };

  export type ApiOddsSnapshotScalarFieldEnum = (typeof ApiOddsSnapshotScalarFieldEnum)[keyof typeof ApiOddsSnapshotScalarFieldEnum]


  export const OddsAuditLogScalarFieldEnum: {
    id: 'id',
    externalGameId: 'externalGameId',
    sportKey: 'sportKey',
    marketKey: 'marketKey',
    selectionName: 'selectionName',
    bookmaker: 'bookmaker',
    oldOdds: 'oldOdds',
    newOdds: 'newOdds',
    changePercent: 'changePercent',
    changeType: 'changeType',
    createdAt: 'createdAt'
  };

  export type OddsAuditLogScalarFieldEnum = (typeof OddsAuditLogScalarFieldEnum)[keyof typeof OddsAuditLogScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    priority: 'priority',
    title: 'title',
    message: 'message',
    read: 'read',
    dismissed: 'dismissed',
    actionUrl: 'actionUrl',
    actionLabel: 'actionLabel',
    metadata: 'metadata',
    createdAt: 'createdAt',
    readAt: 'readAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    accountStatus?: StringFilter<"User"> | string
    kycVerified?: BoolFilter<"User"> | boolean
    kycLevel?: StringFilter<"User"> | string
    gdprConsentGiven?: BoolFilter<"User"> | boolean
    marketingConsent?: BoolFilter<"User"> | boolean
    riskScore?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    profile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
    password?: XOR<UserPasswordNullableScalarRelationFilter, UserPasswordWhereInput> | null
    twoFactorAuth?: XOR<TwoFactorAuthNullableScalarRelationFilter, TwoFactorAuthWhereInput> | null
    userSessions?: UserSessionListRelationFilter
    financialAccounts?: FinancialAccountListRelationFilter
    bets?: BetListRelationFilter
    transactions?: TransactionListRelationFilter
    paymentMethods?: PaymentMethodListRelationFilter
    fraudEvents?: FraudEventListRelationFilter
    bettingPatterns?: BettingPatternListRelationFilter
    activityLogs?: AccountActivityLogListRelationFilter
    devices?: DeviceRegistryListRelationFilter
    notifications?: NotificationListRelationFilter
    consents?: GdprConsentListRelationFilter
    deletionRequests?: DataDeletionRequestListRelationFilter
    exportRequests?: DataExportRequestListRelationFilter
    securityAlerts?: SecurityAlertListRelationFilter
    bonuses?: UserBonusListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    accountStatus?: SortOrder
    kycVerified?: SortOrder
    kycLevel?: SortOrder
    gdprConsentGiven?: SortOrder
    marketingConsent?: SortOrder
    riskScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    profile?: UserProfileOrderByWithRelationInput
    password?: UserPasswordOrderByWithRelationInput
    twoFactorAuth?: TwoFactorAuthOrderByWithRelationInput
    userSessions?: UserSessionOrderByRelationAggregateInput
    financialAccounts?: FinancialAccountOrderByRelationAggregateInput
    bets?: BetOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    paymentMethods?: PaymentMethodOrderByRelationAggregateInput
    fraudEvents?: FraudEventOrderByRelationAggregateInput
    bettingPatterns?: BettingPatternOrderByRelationAggregateInput
    activityLogs?: AccountActivityLogOrderByRelationAggregateInput
    devices?: DeviceRegistryOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    consents?: GdprConsentOrderByRelationAggregateInput
    deletionRequests?: DataDeletionRequestOrderByRelationAggregateInput
    exportRequests?: DataExportRequestOrderByRelationAggregateInput
    securityAlerts?: SecurityAlertOrderByRelationAggregateInput
    bonuses?: UserBonusOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    accountStatus?: StringFilter<"User"> | string
    kycVerified?: BoolFilter<"User"> | boolean
    kycLevel?: StringFilter<"User"> | string
    gdprConsentGiven?: BoolFilter<"User"> | boolean
    marketingConsent?: BoolFilter<"User"> | boolean
    riskScore?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    profile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
    password?: XOR<UserPasswordNullableScalarRelationFilter, UserPasswordWhereInput> | null
    twoFactorAuth?: XOR<TwoFactorAuthNullableScalarRelationFilter, TwoFactorAuthWhereInput> | null
    userSessions?: UserSessionListRelationFilter
    financialAccounts?: FinancialAccountListRelationFilter
    bets?: BetListRelationFilter
    transactions?: TransactionListRelationFilter
    paymentMethods?: PaymentMethodListRelationFilter
    fraudEvents?: FraudEventListRelationFilter
    bettingPatterns?: BettingPatternListRelationFilter
    activityLogs?: AccountActivityLogListRelationFilter
    devices?: DeviceRegistryListRelationFilter
    notifications?: NotificationListRelationFilter
    consents?: GdprConsentListRelationFilter
    deletionRequests?: DataDeletionRequestListRelationFilter
    exportRequests?: DataExportRequestListRelationFilter
    securityAlerts?: SecurityAlertListRelationFilter
    bonuses?: UserBonusListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    accountStatus?: SortOrder
    kycVerified?: SortOrder
    kycLevel?: SortOrder
    gdprConsentGiven?: SortOrder
    marketingConsent?: SortOrder
    riskScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    accountStatus?: StringWithAggregatesFilter<"User"> | string
    kycVerified?: BoolWithAggregatesFilter<"User"> | boolean
    kycLevel?: StringWithAggregatesFilter<"User"> | string
    gdprConsentGiven?: BoolWithAggregatesFilter<"User"> | boolean
    marketingConsent?: BoolWithAggregatesFilter<"User"> | boolean
    riskScore?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    id?: StringFilter<"UserProfile"> | string
    userId?: StringFilter<"UserProfile"> | string
    firstName?: StringNullableFilter<"UserProfile"> | string | null
    lastName?: StringNullableFilter<"UserProfile"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    address?: StringNullableFilter<"UserProfile"> | string | null
    phoneNumber?: StringNullableFilter<"UserProfile"> | string | null
    country?: StringNullableFilter<"UserProfile"> | string | null
    timezone?: StringNullableFilter<"UserProfile"> | string | null
    language?: StringNullableFilter<"UserProfile"> | string | null
    marketingOptIn?: BoolFilter<"UserProfile"> | boolean
    responsibleGamingSettings?: JsonNullableFilter<"UserProfile">
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    marketingOptIn?: SortOrder
    responsibleGamingSettings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    firstName?: StringNullableFilter<"UserProfile"> | string | null
    lastName?: StringNullableFilter<"UserProfile"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    address?: StringNullableFilter<"UserProfile"> | string | null
    phoneNumber?: StringNullableFilter<"UserProfile"> | string | null
    country?: StringNullableFilter<"UserProfile"> | string | null
    timezone?: StringNullableFilter<"UserProfile"> | string | null
    language?: StringNullableFilter<"UserProfile"> | string | null
    marketingOptIn?: BoolFilter<"UserProfile"> | boolean
    responsibleGamingSettings?: JsonNullableFilter<"UserProfile">
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    marketingOptIn?: SortOrder
    responsibleGamingSettings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProfile"> | string
    userId?: StringWithAggregatesFilter<"UserProfile"> | string
    firstName?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"UserProfile"> | Date | string | null
    address?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    country?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    timezone?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    language?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    marketingOptIn?: BoolWithAggregatesFilter<"UserProfile"> | boolean
    responsibleGamingSettings?: JsonNullableWithAggregatesFilter<"UserProfile">
    createdAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
  }

  export type UserPasswordWhereInput = {
    AND?: UserPasswordWhereInput | UserPasswordWhereInput[]
    OR?: UserPasswordWhereInput[]
    NOT?: UserPasswordWhereInput | UserPasswordWhereInput[]
    id?: StringFilter<"UserPassword"> | string
    userId?: StringFilter<"UserPassword"> | string
    passwordHash?: StringFilter<"UserPassword"> | string
    passwordHistory?: JsonNullableFilter<"UserPassword">
    resetToken?: StringNullableFilter<"UserPassword"> | string | null
    resetTokenExpiresAt?: DateTimeNullableFilter<"UserPassword"> | Date | string | null
    passwordChangedAt?: DateTimeFilter<"UserPassword"> | Date | string
    failedLoginAttempts?: IntFilter<"UserPassword"> | number
    lockedUntil?: DateTimeNullableFilter<"UserPassword"> | Date | string | null
    createdAt?: DateTimeFilter<"UserPassword"> | Date | string
    updatedAt?: DateTimeFilter<"UserPassword"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPasswordOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    passwordHash?: SortOrder
    passwordHistory?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiresAt?: SortOrderInput | SortOrder
    passwordChangedAt?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPasswordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserPasswordWhereInput | UserPasswordWhereInput[]
    OR?: UserPasswordWhereInput[]
    NOT?: UserPasswordWhereInput | UserPasswordWhereInput[]
    passwordHash?: StringFilter<"UserPassword"> | string
    passwordHistory?: JsonNullableFilter<"UserPassword">
    resetToken?: StringNullableFilter<"UserPassword"> | string | null
    resetTokenExpiresAt?: DateTimeNullableFilter<"UserPassword"> | Date | string | null
    passwordChangedAt?: DateTimeFilter<"UserPassword"> | Date | string
    failedLoginAttempts?: IntFilter<"UserPassword"> | number
    lockedUntil?: DateTimeNullableFilter<"UserPassword"> | Date | string | null
    createdAt?: DateTimeFilter<"UserPassword"> | Date | string
    updatedAt?: DateTimeFilter<"UserPassword"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserPasswordOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    passwordHash?: SortOrder
    passwordHistory?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiresAt?: SortOrderInput | SortOrder
    passwordChangedAt?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPasswordCountOrderByAggregateInput
    _avg?: UserPasswordAvgOrderByAggregateInput
    _max?: UserPasswordMaxOrderByAggregateInput
    _min?: UserPasswordMinOrderByAggregateInput
    _sum?: UserPasswordSumOrderByAggregateInput
  }

  export type UserPasswordScalarWhereWithAggregatesInput = {
    AND?: UserPasswordScalarWhereWithAggregatesInput | UserPasswordScalarWhereWithAggregatesInput[]
    OR?: UserPasswordScalarWhereWithAggregatesInput[]
    NOT?: UserPasswordScalarWhereWithAggregatesInput | UserPasswordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPassword"> | string
    userId?: StringWithAggregatesFilter<"UserPassword"> | string
    passwordHash?: StringWithAggregatesFilter<"UserPassword"> | string
    passwordHistory?: JsonNullableWithAggregatesFilter<"UserPassword">
    resetToken?: StringNullableWithAggregatesFilter<"UserPassword"> | string | null
    resetTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"UserPassword"> | Date | string | null
    passwordChangedAt?: DateTimeWithAggregatesFilter<"UserPassword"> | Date | string
    failedLoginAttempts?: IntWithAggregatesFilter<"UserPassword"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"UserPassword"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserPassword"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPassword"> | Date | string
  }

  export type TwoFactorAuthWhereInput = {
    AND?: TwoFactorAuthWhereInput | TwoFactorAuthWhereInput[]
    OR?: TwoFactorAuthWhereInput[]
    NOT?: TwoFactorAuthWhereInput | TwoFactorAuthWhereInput[]
    id?: StringFilter<"TwoFactorAuth"> | string
    userId?: StringFilter<"TwoFactorAuth"> | string
    method?: StringFilter<"TwoFactorAuth"> | string
    secretKey?: StringNullableFilter<"TwoFactorAuth"> | string | null
    backupCodes?: JsonNullableFilter<"TwoFactorAuth">
    enabled?: BoolFilter<"TwoFactorAuth"> | boolean
    lastVerifiedAt?: DateTimeNullableFilter<"TwoFactorAuth"> | Date | string | null
    recoveryEmail?: StringNullableFilter<"TwoFactorAuth"> | string | null
    recoveryPhone?: StringNullableFilter<"TwoFactorAuth"> | string | null
    createdAt?: DateTimeFilter<"TwoFactorAuth"> | Date | string
    updatedAt?: DateTimeFilter<"TwoFactorAuth"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TwoFactorAuthOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    secretKey?: SortOrderInput | SortOrder
    backupCodes?: SortOrderInput | SortOrder
    enabled?: SortOrder
    lastVerifiedAt?: SortOrderInput | SortOrder
    recoveryEmail?: SortOrderInput | SortOrder
    recoveryPhone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TwoFactorAuthWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: TwoFactorAuthWhereInput | TwoFactorAuthWhereInput[]
    OR?: TwoFactorAuthWhereInput[]
    NOT?: TwoFactorAuthWhereInput | TwoFactorAuthWhereInput[]
    method?: StringFilter<"TwoFactorAuth"> | string
    secretKey?: StringNullableFilter<"TwoFactorAuth"> | string | null
    backupCodes?: JsonNullableFilter<"TwoFactorAuth">
    enabled?: BoolFilter<"TwoFactorAuth"> | boolean
    lastVerifiedAt?: DateTimeNullableFilter<"TwoFactorAuth"> | Date | string | null
    recoveryEmail?: StringNullableFilter<"TwoFactorAuth"> | string | null
    recoveryPhone?: StringNullableFilter<"TwoFactorAuth"> | string | null
    createdAt?: DateTimeFilter<"TwoFactorAuth"> | Date | string
    updatedAt?: DateTimeFilter<"TwoFactorAuth"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type TwoFactorAuthOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    secretKey?: SortOrderInput | SortOrder
    backupCodes?: SortOrderInput | SortOrder
    enabled?: SortOrder
    lastVerifiedAt?: SortOrderInput | SortOrder
    recoveryEmail?: SortOrderInput | SortOrder
    recoveryPhone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwoFactorAuthCountOrderByAggregateInput
    _max?: TwoFactorAuthMaxOrderByAggregateInput
    _min?: TwoFactorAuthMinOrderByAggregateInput
  }

  export type TwoFactorAuthScalarWhereWithAggregatesInput = {
    AND?: TwoFactorAuthScalarWhereWithAggregatesInput | TwoFactorAuthScalarWhereWithAggregatesInput[]
    OR?: TwoFactorAuthScalarWhereWithAggregatesInput[]
    NOT?: TwoFactorAuthScalarWhereWithAggregatesInput | TwoFactorAuthScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TwoFactorAuth"> | string
    userId?: StringWithAggregatesFilter<"TwoFactorAuth"> | string
    method?: StringWithAggregatesFilter<"TwoFactorAuth"> | string
    secretKey?: StringNullableWithAggregatesFilter<"TwoFactorAuth"> | string | null
    backupCodes?: JsonNullableWithAggregatesFilter<"TwoFactorAuth">
    enabled?: BoolWithAggregatesFilter<"TwoFactorAuth"> | boolean
    lastVerifiedAt?: DateTimeNullableWithAggregatesFilter<"TwoFactorAuth"> | Date | string | null
    recoveryEmail?: StringNullableWithAggregatesFilter<"TwoFactorAuth"> | string | null
    recoveryPhone?: StringNullableWithAggregatesFilter<"TwoFactorAuth"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TwoFactorAuth"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TwoFactorAuth"> | Date | string
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    token?: StringFilter<"UserSession"> | string
    deviceFingerprint?: StringFilter<"UserSession"> | string
    ipAddressHash?: StringFilter<"UserSession"> | string
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    lastActivityAt?: DateTimeFilter<"UserSession"> | Date | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    revoked?: BoolFilter<"UserSession"> | boolean
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceFingerprint?: SortOrder
    ipAddressHash?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    lastActivityAt?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    userId?: StringFilter<"UserSession"> | string
    deviceFingerprint?: StringFilter<"UserSession"> | string
    ipAddressHash?: StringFilter<"UserSession"> | string
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    lastActivityAt?: DateTimeFilter<"UserSession"> | Date | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    revoked?: BoolFilter<"UserSession"> | boolean
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceFingerprint?: SortOrder
    ipAddressHash?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    lastActivityAt?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSession"> | string
    userId?: StringWithAggregatesFilter<"UserSession"> | string
    token?: StringWithAggregatesFilter<"UserSession"> | string
    deviceFingerprint?: StringWithAggregatesFilter<"UserSession"> | string
    ipAddressHash?: StringWithAggregatesFilter<"UserSession"> | string
    userAgent?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    lastActivityAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    revoked?: BoolWithAggregatesFilter<"UserSession"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
  }

  export type LoginAttemptWhereInput = {
    AND?: LoginAttemptWhereInput | LoginAttemptWhereInput[]
    OR?: LoginAttemptWhereInput[]
    NOT?: LoginAttemptWhereInput | LoginAttemptWhereInput[]
    id?: StringFilter<"LoginAttempt"> | string
    emailHash?: StringFilter<"LoginAttempt"> | string
    ipAddressHash?: StringFilter<"LoginAttempt"> | string
    success?: BoolFilter<"LoginAttempt"> | boolean
    deviceFingerprint?: StringNullableFilter<"LoginAttempt"> | string | null
    country?: StringNullableFilter<"LoginAttempt"> | string | null
    region?: StringNullableFilter<"LoginAttempt"> | string | null
    city?: StringNullableFilter<"LoginAttempt"> | string | null
    riskScore?: IntNullableFilter<"LoginAttempt"> | number | null
    userId?: StringNullableFilter<"LoginAttempt"> | string | null
    createdAt?: DateTimeFilter<"LoginAttempt"> | Date | string
  }

  export type LoginAttemptOrderByWithRelationInput = {
    id?: SortOrder
    emailHash?: SortOrder
    ipAddressHash?: SortOrder
    success?: SortOrder
    deviceFingerprint?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    riskScore?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type LoginAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LoginAttemptWhereInput | LoginAttemptWhereInput[]
    OR?: LoginAttemptWhereInput[]
    NOT?: LoginAttemptWhereInput | LoginAttemptWhereInput[]
    emailHash?: StringFilter<"LoginAttempt"> | string
    ipAddressHash?: StringFilter<"LoginAttempt"> | string
    success?: BoolFilter<"LoginAttempt"> | boolean
    deviceFingerprint?: StringNullableFilter<"LoginAttempt"> | string | null
    country?: StringNullableFilter<"LoginAttempt"> | string | null
    region?: StringNullableFilter<"LoginAttempt"> | string | null
    city?: StringNullableFilter<"LoginAttempt"> | string | null
    riskScore?: IntNullableFilter<"LoginAttempt"> | number | null
    userId?: StringNullableFilter<"LoginAttempt"> | string | null
    createdAt?: DateTimeFilter<"LoginAttempt"> | Date | string
  }, "id">

  export type LoginAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    emailHash?: SortOrder
    ipAddressHash?: SortOrder
    success?: SortOrder
    deviceFingerprint?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    riskScore?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LoginAttemptCountOrderByAggregateInput
    _avg?: LoginAttemptAvgOrderByAggregateInput
    _max?: LoginAttemptMaxOrderByAggregateInput
    _min?: LoginAttemptMinOrderByAggregateInput
    _sum?: LoginAttemptSumOrderByAggregateInput
  }

  export type LoginAttemptScalarWhereWithAggregatesInput = {
    AND?: LoginAttemptScalarWhereWithAggregatesInput | LoginAttemptScalarWhereWithAggregatesInput[]
    OR?: LoginAttemptScalarWhereWithAggregatesInput[]
    NOT?: LoginAttemptScalarWhereWithAggregatesInput | LoginAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoginAttempt"> | string
    emailHash?: StringWithAggregatesFilter<"LoginAttempt"> | string
    ipAddressHash?: StringWithAggregatesFilter<"LoginAttempt"> | string
    success?: BoolWithAggregatesFilter<"LoginAttempt"> | boolean
    deviceFingerprint?: StringNullableWithAggregatesFilter<"LoginAttempt"> | string | null
    country?: StringNullableWithAggregatesFilter<"LoginAttempt"> | string | null
    region?: StringNullableWithAggregatesFilter<"LoginAttempt"> | string | null
    city?: StringNullableWithAggregatesFilter<"LoginAttempt"> | string | null
    riskScore?: IntNullableWithAggregatesFilter<"LoginAttempt"> | number | null
    userId?: StringNullableWithAggregatesFilter<"LoginAttempt"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LoginAttempt"> | Date | string
  }

  export type SportWhereInput = {
    AND?: SportWhereInput | SportWhereInput[]
    OR?: SportWhereInput[]
    NOT?: SportWhereInput | SportWhereInput[]
    id?: StringFilter<"Sport"> | string
    name?: StringFilter<"Sport"> | string
    code?: StringFilter<"Sport"> | string
    active?: BoolFilter<"Sport"> | boolean
    displayOrder?: IntFilter<"Sport"> | number
    createdAt?: DateTimeFilter<"Sport"> | Date | string
    updatedAt?: DateTimeFilter<"Sport"> | Date | string
    leagues?: LeagueListRelationFilter
    games?: GameListRelationFilter
  }

  export type SportOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    active?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    leagues?: LeagueOrderByRelationAggregateInput
    games?: GameOrderByRelationAggregateInput
  }

  export type SportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: SportWhereInput | SportWhereInput[]
    OR?: SportWhereInput[]
    NOT?: SportWhereInput | SportWhereInput[]
    active?: BoolFilter<"Sport"> | boolean
    displayOrder?: IntFilter<"Sport"> | number
    createdAt?: DateTimeFilter<"Sport"> | Date | string
    updatedAt?: DateTimeFilter<"Sport"> | Date | string
    leagues?: LeagueListRelationFilter
    games?: GameListRelationFilter
  }, "id" | "name" | "code">

  export type SportOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    active?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SportCountOrderByAggregateInput
    _avg?: SportAvgOrderByAggregateInput
    _max?: SportMaxOrderByAggregateInput
    _min?: SportMinOrderByAggregateInput
    _sum?: SportSumOrderByAggregateInput
  }

  export type SportScalarWhereWithAggregatesInput = {
    AND?: SportScalarWhereWithAggregatesInput | SportScalarWhereWithAggregatesInput[]
    OR?: SportScalarWhereWithAggregatesInput[]
    NOT?: SportScalarWhereWithAggregatesInput | SportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sport"> | string
    name?: StringWithAggregatesFilter<"Sport"> | string
    code?: StringWithAggregatesFilter<"Sport"> | string
    active?: BoolWithAggregatesFilter<"Sport"> | boolean
    displayOrder?: IntWithAggregatesFilter<"Sport"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Sport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sport"> | Date | string
  }

  export type LeagueWhereInput = {
    AND?: LeagueWhereInput | LeagueWhereInput[]
    OR?: LeagueWhereInput[]
    NOT?: LeagueWhereInput | LeagueWhereInput[]
    id?: StringFilter<"League"> | string
    sportId?: StringFilter<"League"> | string
    name?: StringFilter<"League"> | string
    code?: StringFilter<"League"> | string
    country?: StringNullableFilter<"League"> | string | null
    region?: StringNullableFilter<"League"> | string | null
    active?: BoolFilter<"League"> | boolean
    createdAt?: DateTimeFilter<"League"> | Date | string
    updatedAt?: DateTimeFilter<"League"> | Date | string
    sport?: XOR<SportScalarRelationFilter, SportWhereInput>
    teams?: TeamListRelationFilter
    games?: GameListRelationFilter
  }

  export type LeagueOrderByWithRelationInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sport?: SportOrderByWithRelationInput
    teams?: TeamOrderByRelationAggregateInput
    games?: GameOrderByRelationAggregateInput
  }

  export type LeagueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sportId_code?: LeagueSportIdCodeCompoundUniqueInput
    AND?: LeagueWhereInput | LeagueWhereInput[]
    OR?: LeagueWhereInput[]
    NOT?: LeagueWhereInput | LeagueWhereInput[]
    sportId?: StringFilter<"League"> | string
    name?: StringFilter<"League"> | string
    code?: StringFilter<"League"> | string
    country?: StringNullableFilter<"League"> | string | null
    region?: StringNullableFilter<"League"> | string | null
    active?: BoolFilter<"League"> | boolean
    createdAt?: DateTimeFilter<"League"> | Date | string
    updatedAt?: DateTimeFilter<"League"> | Date | string
    sport?: XOR<SportScalarRelationFilter, SportWhereInput>
    teams?: TeamListRelationFilter
    games?: GameListRelationFilter
  }, "id" | "sportId_code">

  export type LeagueOrderByWithAggregationInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeagueCountOrderByAggregateInput
    _max?: LeagueMaxOrderByAggregateInput
    _min?: LeagueMinOrderByAggregateInput
  }

  export type LeagueScalarWhereWithAggregatesInput = {
    AND?: LeagueScalarWhereWithAggregatesInput | LeagueScalarWhereWithAggregatesInput[]
    OR?: LeagueScalarWhereWithAggregatesInput[]
    NOT?: LeagueScalarWhereWithAggregatesInput | LeagueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"League"> | string
    sportId?: StringWithAggregatesFilter<"League"> | string
    name?: StringWithAggregatesFilter<"League"> | string
    code?: StringWithAggregatesFilter<"League"> | string
    country?: StringNullableWithAggregatesFilter<"League"> | string | null
    region?: StringNullableWithAggregatesFilter<"League"> | string | null
    active?: BoolWithAggregatesFilter<"League"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"League"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"League"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    leagueId?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    code?: StringFilter<"Team"> | string
    logoUrl?: StringNullableFilter<"Team"> | string | null
    active?: BoolFilter<"Team"> | boolean
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
    homeGames?: GameListRelationFilter
    awayGames?: GameListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    league?: LeagueOrderByWithRelationInput
    homeGames?: GameOrderByRelationAggregateInput
    awayGames?: GameOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    leagueId_code?: TeamLeagueIdCodeCompoundUniqueInput
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    leagueId?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    code?: StringFilter<"Team"> | string
    logoUrl?: StringNullableFilter<"Team"> | string | null
    active?: BoolFilter<"Team"> | boolean
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
    homeGames?: GameListRelationFilter
    awayGames?: GameListRelationFilter
  }, "id" | "leagueId_code">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    leagueId?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    code?: StringWithAggregatesFilter<"Team"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"Team"> | string | null
    active?: BoolWithAggregatesFilter<"Team"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type GameWhereInput = {
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    id?: StringFilter<"Game"> | string
    sportId?: StringFilter<"Game"> | string
    leagueId?: StringFilter<"Game"> | string
    homeTeamId?: StringFilter<"Game"> | string
    awayTeamId?: StringFilter<"Game"> | string
    scheduledStartAt?: DateTimeFilter<"Game"> | Date | string
    actualStartAt?: DateTimeNullableFilter<"Game"> | Date | string | null
    status?: StringFilter<"Game"> | string
    homeScore?: IntNullableFilter<"Game"> | number | null
    awayScore?: IntNullableFilter<"Game"> | number | null
    metadata?: JsonNullableFilter<"Game">
    createdAt?: DateTimeFilter<"Game"> | Date | string
    updatedAt?: DateTimeFilter<"Game"> | Date | string
    sport?: XOR<SportScalarRelationFilter, SportWhereInput>
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
    homeTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    awayTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    markets?: BetMarketListRelationFilter
    syncStatus?: XOR<OddsSyncStatusNullableScalarRelationFilter, OddsSyncStatusWhereInput> | null
  }

  export type GameOrderByWithRelationInput = {
    id?: SortOrder
    sportId?: SortOrder
    leagueId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    scheduledStartAt?: SortOrder
    actualStartAt?: SortOrderInput | SortOrder
    status?: SortOrder
    homeScore?: SortOrderInput | SortOrder
    awayScore?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sport?: SportOrderByWithRelationInput
    league?: LeagueOrderByWithRelationInput
    homeTeam?: TeamOrderByWithRelationInput
    awayTeam?: TeamOrderByWithRelationInput
    markets?: BetMarketOrderByRelationAggregateInput
    syncStatus?: OddsSyncStatusOrderByWithRelationInput
  }

  export type GameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    sportId?: StringFilter<"Game"> | string
    leagueId?: StringFilter<"Game"> | string
    homeTeamId?: StringFilter<"Game"> | string
    awayTeamId?: StringFilter<"Game"> | string
    scheduledStartAt?: DateTimeFilter<"Game"> | Date | string
    actualStartAt?: DateTimeNullableFilter<"Game"> | Date | string | null
    status?: StringFilter<"Game"> | string
    homeScore?: IntNullableFilter<"Game"> | number | null
    awayScore?: IntNullableFilter<"Game"> | number | null
    metadata?: JsonNullableFilter<"Game">
    createdAt?: DateTimeFilter<"Game"> | Date | string
    updatedAt?: DateTimeFilter<"Game"> | Date | string
    sport?: XOR<SportScalarRelationFilter, SportWhereInput>
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
    homeTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    awayTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    markets?: BetMarketListRelationFilter
    syncStatus?: XOR<OddsSyncStatusNullableScalarRelationFilter, OddsSyncStatusWhereInput> | null
  }, "id">

  export type GameOrderByWithAggregationInput = {
    id?: SortOrder
    sportId?: SortOrder
    leagueId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    scheduledStartAt?: SortOrder
    actualStartAt?: SortOrderInput | SortOrder
    status?: SortOrder
    homeScore?: SortOrderInput | SortOrder
    awayScore?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GameCountOrderByAggregateInput
    _avg?: GameAvgOrderByAggregateInput
    _max?: GameMaxOrderByAggregateInput
    _min?: GameMinOrderByAggregateInput
    _sum?: GameSumOrderByAggregateInput
  }

  export type GameScalarWhereWithAggregatesInput = {
    AND?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    OR?: GameScalarWhereWithAggregatesInput[]
    NOT?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Game"> | string
    sportId?: StringWithAggregatesFilter<"Game"> | string
    leagueId?: StringWithAggregatesFilter<"Game"> | string
    homeTeamId?: StringWithAggregatesFilter<"Game"> | string
    awayTeamId?: StringWithAggregatesFilter<"Game"> | string
    scheduledStartAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string
    actualStartAt?: DateTimeNullableWithAggregatesFilter<"Game"> | Date | string | null
    status?: StringWithAggregatesFilter<"Game"> | string
    homeScore?: IntNullableWithAggregatesFilter<"Game"> | number | null
    awayScore?: IntNullableWithAggregatesFilter<"Game"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"Game">
    createdAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string
  }

  export type BetMarketWhereInput = {
    AND?: BetMarketWhereInput | BetMarketWhereInput[]
    OR?: BetMarketWhereInput[]
    NOT?: BetMarketWhereInput | BetMarketWhereInput[]
    id?: StringFilter<"BetMarket"> | string
    gameId?: StringFilter<"BetMarket"> | string
    marketType?: StringFilter<"BetMarket"> | string
    name?: StringFilter<"BetMarket"> | string
    active?: BoolFilter<"BetMarket"> | boolean
    createdAt?: DateTimeFilter<"BetMarket"> | Date | string
    updatedAt?: DateTimeFilter<"BetMarket"> | Date | string
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    selections?: BetSelectionListRelationFilter
  }

  export type BetMarketOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    marketType?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    game?: GameOrderByWithRelationInput
    selections?: BetSelectionOrderByRelationAggregateInput
  }

  export type BetMarketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BetMarketWhereInput | BetMarketWhereInput[]
    OR?: BetMarketWhereInput[]
    NOT?: BetMarketWhereInput | BetMarketWhereInput[]
    gameId?: StringFilter<"BetMarket"> | string
    marketType?: StringFilter<"BetMarket"> | string
    name?: StringFilter<"BetMarket"> | string
    active?: BoolFilter<"BetMarket"> | boolean
    createdAt?: DateTimeFilter<"BetMarket"> | Date | string
    updatedAt?: DateTimeFilter<"BetMarket"> | Date | string
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    selections?: BetSelectionListRelationFilter
  }, "id">

  export type BetMarketOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    marketType?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BetMarketCountOrderByAggregateInput
    _max?: BetMarketMaxOrderByAggregateInput
    _min?: BetMarketMinOrderByAggregateInput
  }

  export type BetMarketScalarWhereWithAggregatesInput = {
    AND?: BetMarketScalarWhereWithAggregatesInput | BetMarketScalarWhereWithAggregatesInput[]
    OR?: BetMarketScalarWhereWithAggregatesInput[]
    NOT?: BetMarketScalarWhereWithAggregatesInput | BetMarketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BetMarket"> | string
    gameId?: StringWithAggregatesFilter<"BetMarket"> | string
    marketType?: StringWithAggregatesFilter<"BetMarket"> | string
    name?: StringWithAggregatesFilter<"BetMarket"> | string
    active?: BoolWithAggregatesFilter<"BetMarket"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BetMarket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BetMarket"> | Date | string
  }

  export type BetSelectionWhereInput = {
    AND?: BetSelectionWhereInput | BetSelectionWhereInput[]
    OR?: BetSelectionWhereInput[]
    NOT?: BetSelectionWhereInput | BetSelectionWhereInput[]
    id?: StringFilter<"BetSelection"> | string
    marketId?: StringFilter<"BetSelection"> | string
    name?: StringFilter<"BetSelection"> | string
    odds?: DecimalFilter<"BetSelection"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"BetSelection"> | string
    result?: StringNullableFilter<"BetSelection"> | string | null
    createdAt?: DateTimeFilter<"BetSelection"> | Date | string
    updatedAt?: DateTimeFilter<"BetSelection"> | Date | string
    market?: XOR<BetMarketScalarRelationFilter, BetMarketWhereInput>
    betSelections?: BetSelectionBetListRelationFilter
    currentOdds?: XOR<CurrentOddsNullableScalarRelationFilter, CurrentOddsWhereInput> | null
    oddsSnapshots?: OddsSnapshotListRelationFilter
  }

  export type BetSelectionOrderByWithRelationInput = {
    id?: SortOrder
    marketId?: SortOrder
    name?: SortOrder
    odds?: SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    market?: BetMarketOrderByWithRelationInput
    betSelections?: BetSelectionBetOrderByRelationAggregateInput
    currentOdds?: CurrentOddsOrderByWithRelationInput
    oddsSnapshots?: OddsSnapshotOrderByRelationAggregateInput
  }

  export type BetSelectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BetSelectionWhereInput | BetSelectionWhereInput[]
    OR?: BetSelectionWhereInput[]
    NOT?: BetSelectionWhereInput | BetSelectionWhereInput[]
    marketId?: StringFilter<"BetSelection"> | string
    name?: StringFilter<"BetSelection"> | string
    odds?: DecimalFilter<"BetSelection"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"BetSelection"> | string
    result?: StringNullableFilter<"BetSelection"> | string | null
    createdAt?: DateTimeFilter<"BetSelection"> | Date | string
    updatedAt?: DateTimeFilter<"BetSelection"> | Date | string
    market?: XOR<BetMarketScalarRelationFilter, BetMarketWhereInput>
    betSelections?: BetSelectionBetListRelationFilter
    currentOdds?: XOR<CurrentOddsNullableScalarRelationFilter, CurrentOddsWhereInput> | null
    oddsSnapshots?: OddsSnapshotListRelationFilter
  }, "id">

  export type BetSelectionOrderByWithAggregationInput = {
    id?: SortOrder
    marketId?: SortOrder
    name?: SortOrder
    odds?: SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BetSelectionCountOrderByAggregateInput
    _avg?: BetSelectionAvgOrderByAggregateInput
    _max?: BetSelectionMaxOrderByAggregateInput
    _min?: BetSelectionMinOrderByAggregateInput
    _sum?: BetSelectionSumOrderByAggregateInput
  }

  export type BetSelectionScalarWhereWithAggregatesInput = {
    AND?: BetSelectionScalarWhereWithAggregatesInput | BetSelectionScalarWhereWithAggregatesInput[]
    OR?: BetSelectionScalarWhereWithAggregatesInput[]
    NOT?: BetSelectionScalarWhereWithAggregatesInput | BetSelectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BetSelection"> | string
    marketId?: StringWithAggregatesFilter<"BetSelection"> | string
    name?: StringWithAggregatesFilter<"BetSelection"> | string
    odds?: DecimalWithAggregatesFilter<"BetSelection"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"BetSelection"> | string
    result?: StringNullableWithAggregatesFilter<"BetSelection"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BetSelection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BetSelection"> | Date | string
  }

  export type BetWhereInput = {
    AND?: BetWhereInput | BetWhereInput[]
    OR?: BetWhereInput[]
    NOT?: BetWhereInput | BetWhereInput[]
    id?: StringFilter<"Bet"> | string
    userId?: StringFilter<"Bet"> | string
    betType?: StringFilter<"Bet"> | string
    totalStake?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    potentialPayout?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    actualPayout?: DecimalNullableFilter<"Bet"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"Bet"> | string
    placedAt?: DateTimeFilter<"Bet"> | Date | string
    settledAt?: DateTimeNullableFilter<"Bet"> | Date | string | null
    cashoutAt?: DateTimeNullableFilter<"Bet"> | Date | string | null
    oddsSnapshot?: JsonNullableFilter<"Bet">
    createdAt?: DateTimeFilter<"Bet"> | Date | string
    updatedAt?: DateTimeFilter<"Bet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    selections?: BetSelectionBetListRelationFilter
  }

  export type BetOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    betType?: SortOrder
    totalStake?: SortOrder
    potentialPayout?: SortOrder
    actualPayout?: SortOrderInput | SortOrder
    status?: SortOrder
    placedAt?: SortOrder
    settledAt?: SortOrderInput | SortOrder
    cashoutAt?: SortOrderInput | SortOrder
    oddsSnapshot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    selections?: BetSelectionBetOrderByRelationAggregateInput
  }

  export type BetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BetWhereInput | BetWhereInput[]
    OR?: BetWhereInput[]
    NOT?: BetWhereInput | BetWhereInput[]
    userId?: StringFilter<"Bet"> | string
    betType?: StringFilter<"Bet"> | string
    totalStake?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    potentialPayout?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    actualPayout?: DecimalNullableFilter<"Bet"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"Bet"> | string
    placedAt?: DateTimeFilter<"Bet"> | Date | string
    settledAt?: DateTimeNullableFilter<"Bet"> | Date | string | null
    cashoutAt?: DateTimeNullableFilter<"Bet"> | Date | string | null
    oddsSnapshot?: JsonNullableFilter<"Bet">
    createdAt?: DateTimeFilter<"Bet"> | Date | string
    updatedAt?: DateTimeFilter<"Bet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    selections?: BetSelectionBetListRelationFilter
  }, "id">

  export type BetOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    betType?: SortOrder
    totalStake?: SortOrder
    potentialPayout?: SortOrder
    actualPayout?: SortOrderInput | SortOrder
    status?: SortOrder
    placedAt?: SortOrder
    settledAt?: SortOrderInput | SortOrder
    cashoutAt?: SortOrderInput | SortOrder
    oddsSnapshot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BetCountOrderByAggregateInput
    _avg?: BetAvgOrderByAggregateInput
    _max?: BetMaxOrderByAggregateInput
    _min?: BetMinOrderByAggregateInput
    _sum?: BetSumOrderByAggregateInput
  }

  export type BetScalarWhereWithAggregatesInput = {
    AND?: BetScalarWhereWithAggregatesInput | BetScalarWhereWithAggregatesInput[]
    OR?: BetScalarWhereWithAggregatesInput[]
    NOT?: BetScalarWhereWithAggregatesInput | BetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bet"> | string
    userId?: StringWithAggregatesFilter<"Bet"> | string
    betType?: StringWithAggregatesFilter<"Bet"> | string
    totalStake?: DecimalWithAggregatesFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    potentialPayout?: DecimalWithAggregatesFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    actualPayout?: DecimalNullableWithAggregatesFilter<"Bet"> | Decimal | DecimalJsLike | number | string | null
    status?: StringWithAggregatesFilter<"Bet"> | string
    placedAt?: DateTimeWithAggregatesFilter<"Bet"> | Date | string
    settledAt?: DateTimeNullableWithAggregatesFilter<"Bet"> | Date | string | null
    cashoutAt?: DateTimeNullableWithAggregatesFilter<"Bet"> | Date | string | null
    oddsSnapshot?: JsonNullableWithAggregatesFilter<"Bet">
    createdAt?: DateTimeWithAggregatesFilter<"Bet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bet"> | Date | string
  }

  export type BetSelectionBetWhereInput = {
    AND?: BetSelectionBetWhereInput | BetSelectionBetWhereInput[]
    OR?: BetSelectionBetWhereInput[]
    NOT?: BetSelectionBetWhereInput | BetSelectionBetWhereInput[]
    id?: StringFilter<"BetSelectionBet"> | string
    betId?: StringFilter<"BetSelectionBet"> | string
    selectionId?: StringFilter<"BetSelectionBet"> | string
    oddsAtBet?: DecimalFilter<"BetSelectionBet"> | Decimal | DecimalJsLike | number | string
    result?: StringNullableFilter<"BetSelectionBet"> | string | null
    createdAt?: DateTimeFilter<"BetSelectionBet"> | Date | string
    bet?: XOR<BetScalarRelationFilter, BetWhereInput>
    selection?: XOR<BetSelectionScalarRelationFilter, BetSelectionWhereInput>
  }

  export type BetSelectionBetOrderByWithRelationInput = {
    id?: SortOrder
    betId?: SortOrder
    selectionId?: SortOrder
    oddsAtBet?: SortOrder
    result?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    bet?: BetOrderByWithRelationInput
    selection?: BetSelectionOrderByWithRelationInput
  }

  export type BetSelectionBetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    betId_selectionId?: BetSelectionBetBetIdSelectionIdCompoundUniqueInput
    AND?: BetSelectionBetWhereInput | BetSelectionBetWhereInput[]
    OR?: BetSelectionBetWhereInput[]
    NOT?: BetSelectionBetWhereInput | BetSelectionBetWhereInput[]
    betId?: StringFilter<"BetSelectionBet"> | string
    selectionId?: StringFilter<"BetSelectionBet"> | string
    oddsAtBet?: DecimalFilter<"BetSelectionBet"> | Decimal | DecimalJsLike | number | string
    result?: StringNullableFilter<"BetSelectionBet"> | string | null
    createdAt?: DateTimeFilter<"BetSelectionBet"> | Date | string
    bet?: XOR<BetScalarRelationFilter, BetWhereInput>
    selection?: XOR<BetSelectionScalarRelationFilter, BetSelectionWhereInput>
  }, "id" | "betId_selectionId">

  export type BetSelectionBetOrderByWithAggregationInput = {
    id?: SortOrder
    betId?: SortOrder
    selectionId?: SortOrder
    oddsAtBet?: SortOrder
    result?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BetSelectionBetCountOrderByAggregateInput
    _avg?: BetSelectionBetAvgOrderByAggregateInput
    _max?: BetSelectionBetMaxOrderByAggregateInput
    _min?: BetSelectionBetMinOrderByAggregateInput
    _sum?: BetSelectionBetSumOrderByAggregateInput
  }

  export type BetSelectionBetScalarWhereWithAggregatesInput = {
    AND?: BetSelectionBetScalarWhereWithAggregatesInput | BetSelectionBetScalarWhereWithAggregatesInput[]
    OR?: BetSelectionBetScalarWhereWithAggregatesInput[]
    NOT?: BetSelectionBetScalarWhereWithAggregatesInput | BetSelectionBetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BetSelectionBet"> | string
    betId?: StringWithAggregatesFilter<"BetSelectionBet"> | string
    selectionId?: StringWithAggregatesFilter<"BetSelectionBet"> | string
    oddsAtBet?: DecimalWithAggregatesFilter<"BetSelectionBet"> | Decimal | DecimalJsLike | number | string
    result?: StringNullableWithAggregatesFilter<"BetSelectionBet"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BetSelectionBet"> | Date | string
  }

  export type FinancialAccountWhereInput = {
    AND?: FinancialAccountWhereInput | FinancialAccountWhereInput[]
    OR?: FinancialAccountWhereInput[]
    NOT?: FinancialAccountWhereInput | FinancialAccountWhereInput[]
    id?: StringFilter<"FinancialAccount"> | string
    userId?: StringFilter<"FinancialAccount"> | string
    accountType?: StringFilter<"FinancialAccount"> | string
    balance?: DecimalFilter<"FinancialAccount"> | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFilter<"FinancialAccount"> | Decimal | DecimalJsLike | number | string
    lockedBalance?: DecimalFilter<"FinancialAccount"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"FinancialAccount"> | string
    lastTransactionAt?: DateTimeNullableFilter<"FinancialAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"FinancialAccount"> | Date | string
    updatedAt?: DateTimeFilter<"FinancialAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    transactions?: TransactionListRelationFilter
  }

  export type FinancialAccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    balance?: SortOrder
    availableBalance?: SortOrder
    lockedBalance?: SortOrder
    currency?: SortOrder
    lastTransactionAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type FinancialAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_accountType?: FinancialAccountUserIdAccountTypeCompoundUniqueInput
    AND?: FinancialAccountWhereInput | FinancialAccountWhereInput[]
    OR?: FinancialAccountWhereInput[]
    NOT?: FinancialAccountWhereInput | FinancialAccountWhereInput[]
    userId?: StringFilter<"FinancialAccount"> | string
    accountType?: StringFilter<"FinancialAccount"> | string
    balance?: DecimalFilter<"FinancialAccount"> | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFilter<"FinancialAccount"> | Decimal | DecimalJsLike | number | string
    lockedBalance?: DecimalFilter<"FinancialAccount"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"FinancialAccount"> | string
    lastTransactionAt?: DateTimeNullableFilter<"FinancialAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"FinancialAccount"> | Date | string
    updatedAt?: DateTimeFilter<"FinancialAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    transactions?: TransactionListRelationFilter
  }, "id" | "userId_accountType">

  export type FinancialAccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    balance?: SortOrder
    availableBalance?: SortOrder
    lockedBalance?: SortOrder
    currency?: SortOrder
    lastTransactionAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FinancialAccountCountOrderByAggregateInput
    _avg?: FinancialAccountAvgOrderByAggregateInput
    _max?: FinancialAccountMaxOrderByAggregateInput
    _min?: FinancialAccountMinOrderByAggregateInput
    _sum?: FinancialAccountSumOrderByAggregateInput
  }

  export type FinancialAccountScalarWhereWithAggregatesInput = {
    AND?: FinancialAccountScalarWhereWithAggregatesInput | FinancialAccountScalarWhereWithAggregatesInput[]
    OR?: FinancialAccountScalarWhereWithAggregatesInput[]
    NOT?: FinancialAccountScalarWhereWithAggregatesInput | FinancialAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FinancialAccount"> | string
    userId?: StringWithAggregatesFilter<"FinancialAccount"> | string
    accountType?: StringWithAggregatesFilter<"FinancialAccount"> | string
    balance?: DecimalWithAggregatesFilter<"FinancialAccount"> | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalWithAggregatesFilter<"FinancialAccount"> | Decimal | DecimalJsLike | number | string
    lockedBalance?: DecimalWithAggregatesFilter<"FinancialAccount"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"FinancialAccount"> | string
    lastTransactionAt?: DateTimeNullableWithAggregatesFilter<"FinancialAccount"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FinancialAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FinancialAccount"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    accountId?: StringFilter<"Transaction"> | string
    transactionType?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Transaction"> | string
    paymentMethodId?: StringNullableFilter<"Transaction"> | string | null
    externalTransactionId?: StringNullableFilter<"Transaction"> | string | null
    description?: StringNullableFilter<"Transaction"> | string | null
    metadata?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    processedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    account?: XOR<FinancialAccountScalarRelationFilter, FinancialAccountWhereInput>
    paymentMethod?: XOR<PaymentMethodNullableScalarRelationFilter, PaymentMethodWhereInput> | null
    deposit?: XOR<DepositNullableScalarRelationFilter, DepositWhereInput> | null
    withdrawal?: XOR<WithdrawalNullableScalarRelationFilter, WithdrawalWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    status?: SortOrder
    paymentMethodId?: SortOrderInput | SortOrder
    externalTransactionId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    account?: FinancialAccountOrderByWithRelationInput
    paymentMethod?: PaymentMethodOrderByWithRelationInput
    deposit?: DepositOrderByWithRelationInput
    withdrawal?: WithdrawalOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    userId?: StringFilter<"Transaction"> | string
    accountId?: StringFilter<"Transaction"> | string
    transactionType?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Transaction"> | string
    paymentMethodId?: StringNullableFilter<"Transaction"> | string | null
    externalTransactionId?: StringNullableFilter<"Transaction"> | string | null
    description?: StringNullableFilter<"Transaction"> | string | null
    metadata?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    processedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    account?: XOR<FinancialAccountScalarRelationFilter, FinancialAccountWhereInput>
    paymentMethod?: XOR<PaymentMethodNullableScalarRelationFilter, PaymentMethodWhereInput> | null
    deposit?: XOR<DepositNullableScalarRelationFilter, DepositWhereInput> | null
    withdrawal?: XOR<WithdrawalNullableScalarRelationFilter, WithdrawalWhereInput> | null
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    status?: SortOrder
    paymentMethodId?: SortOrderInput | SortOrder
    externalTransactionId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    userId?: StringWithAggregatesFilter<"Transaction"> | string
    accountId?: StringWithAggregatesFilter<"Transaction"> | string
    transactionType?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"Transaction"> | string
    paymentMethodId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    externalTransactionId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Transaction">
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
  }

  export type PaymentMethodWhereInput = {
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    id?: StringFilter<"PaymentMethod"> | string
    userId?: StringFilter<"PaymentMethod"> | string
    paymentType?: StringFilter<"PaymentMethod"> | string
    provider?: StringFilter<"PaymentMethod"> | string
    tokenizedId?: StringFilter<"PaymentMethod"> | string
    last4Digits?: StringNullableFilter<"PaymentMethod"> | string | null
    expiryDate?: StringNullableFilter<"PaymentMethod"> | string | null
    billingAddress?: StringNullableFilter<"PaymentMethod"> | string | null
    isDefault?: BoolFilter<"PaymentMethod"> | boolean
    verified?: BoolFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    transactions?: TransactionListRelationFilter
    deposits?: DepositListRelationFilter
    withdrawals?: WithdrawalListRelationFilter
  }

  export type PaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentType?: SortOrder
    provider?: SortOrder
    tokenizedId?: SortOrder
    last4Digits?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    billingAddress?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
    deposits?: DepositOrderByRelationAggregateInput
    withdrawals?: WithdrawalOrderByRelationAggregateInput
  }

  export type PaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    userId?: StringFilter<"PaymentMethod"> | string
    paymentType?: StringFilter<"PaymentMethod"> | string
    provider?: StringFilter<"PaymentMethod"> | string
    tokenizedId?: StringFilter<"PaymentMethod"> | string
    last4Digits?: StringNullableFilter<"PaymentMethod"> | string | null
    expiryDate?: StringNullableFilter<"PaymentMethod"> | string | null
    billingAddress?: StringNullableFilter<"PaymentMethod"> | string | null
    isDefault?: BoolFilter<"PaymentMethod"> | boolean
    verified?: BoolFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    transactions?: TransactionListRelationFilter
    deposits?: DepositListRelationFilter
    withdrawals?: WithdrawalListRelationFilter
  }, "id">

  export type PaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentType?: SortOrder
    provider?: SortOrder
    tokenizedId?: SortOrder
    last4Digits?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    billingAddress?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentMethodCountOrderByAggregateInput
    _max?: PaymentMethodMaxOrderByAggregateInput
    _min?: PaymentMethodMinOrderByAggregateInput
  }

  export type PaymentMethodScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentMethod"> | string
    userId?: StringWithAggregatesFilter<"PaymentMethod"> | string
    paymentType?: StringWithAggregatesFilter<"PaymentMethod"> | string
    provider?: StringWithAggregatesFilter<"PaymentMethod"> | string
    tokenizedId?: StringWithAggregatesFilter<"PaymentMethod"> | string
    last4Digits?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    expiryDate?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    billingAddress?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    isDefault?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    verified?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
  }

  export type DepositWhereInput = {
    AND?: DepositWhereInput | DepositWhereInput[]
    OR?: DepositWhereInput[]
    NOT?: DepositWhereInput | DepositWhereInput[]
    id?: StringFilter<"Deposit"> | string
    transactionId?: StringFilter<"Deposit"> | string
    paymentMethodId?: StringFilter<"Deposit"> | string
    amount?: DecimalFilter<"Deposit"> | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFilter<"Deposit"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Deposit"> | Decimal | DecimalJsLike | number | string
    providerTransactionId?: StringNullableFilter<"Deposit"> | string | null
    status?: StringFilter<"Deposit"> | string
    providerResponse?: JsonNullableFilter<"Deposit">
    processedAt?: DateTimeNullableFilter<"Deposit"> | Date | string | null
    createdAt?: DateTimeFilter<"Deposit"> | Date | string
    updatedAt?: DateTimeFilter<"Deposit"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    paymentMethod?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
  }

  export type DepositOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
    providerTransactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    providerResponse?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
    paymentMethod?: PaymentMethodOrderByWithRelationInput
  }

  export type DepositWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    AND?: DepositWhereInput | DepositWhereInput[]
    OR?: DepositWhereInput[]
    NOT?: DepositWhereInput | DepositWhereInput[]
    paymentMethodId?: StringFilter<"Deposit"> | string
    amount?: DecimalFilter<"Deposit"> | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFilter<"Deposit"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Deposit"> | Decimal | DecimalJsLike | number | string
    providerTransactionId?: StringNullableFilter<"Deposit"> | string | null
    status?: StringFilter<"Deposit"> | string
    providerResponse?: JsonNullableFilter<"Deposit">
    processedAt?: DateTimeNullableFilter<"Deposit"> | Date | string | null
    createdAt?: DateTimeFilter<"Deposit"> | Date | string
    updatedAt?: DateTimeFilter<"Deposit"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    paymentMethod?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
  }, "id" | "transactionId">

  export type DepositOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
    providerTransactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    providerResponse?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepositCountOrderByAggregateInput
    _avg?: DepositAvgOrderByAggregateInput
    _max?: DepositMaxOrderByAggregateInput
    _min?: DepositMinOrderByAggregateInput
    _sum?: DepositSumOrderByAggregateInput
  }

  export type DepositScalarWhereWithAggregatesInput = {
    AND?: DepositScalarWhereWithAggregatesInput | DepositScalarWhereWithAggregatesInput[]
    OR?: DepositScalarWhereWithAggregatesInput[]
    NOT?: DepositScalarWhereWithAggregatesInput | DepositScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Deposit"> | string
    transactionId?: StringWithAggregatesFilter<"Deposit"> | string
    paymentMethodId?: StringWithAggregatesFilter<"Deposit"> | string
    amount?: DecimalWithAggregatesFilter<"Deposit"> | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalWithAggregatesFilter<"Deposit"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalWithAggregatesFilter<"Deposit"> | Decimal | DecimalJsLike | number | string
    providerTransactionId?: StringNullableWithAggregatesFilter<"Deposit"> | string | null
    status?: StringWithAggregatesFilter<"Deposit"> | string
    providerResponse?: JsonNullableWithAggregatesFilter<"Deposit">
    processedAt?: DateTimeNullableWithAggregatesFilter<"Deposit"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Deposit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Deposit"> | Date | string
  }

  export type WithdrawalWhereInput = {
    AND?: WithdrawalWhereInput | WithdrawalWhereInput[]
    OR?: WithdrawalWhereInput[]
    NOT?: WithdrawalWhereInput | WithdrawalWhereInput[]
    id?: StringFilter<"Withdrawal"> | string
    transactionId?: StringFilter<"Withdrawal"> | string
    paymentMethodId?: StringFilter<"Withdrawal"> | string
    amount?: DecimalFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Withdrawal"> | string
    providerTransactionId?: StringNullableFilter<"Withdrawal"> | string | null
    providerResponse?: JsonNullableFilter<"Withdrawal">
    kycVerificationRequired?: BoolFilter<"Withdrawal"> | boolean
    requestedAt?: DateTimeFilter<"Withdrawal"> | Date | string
    processedAt?: DateTimeNullableFilter<"Withdrawal"> | Date | string | null
    createdAt?: DateTimeFilter<"Withdrawal"> | Date | string
    updatedAt?: DateTimeFilter<"Withdrawal"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    paymentMethod?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
  }

  export type WithdrawalOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    providerTransactionId?: SortOrderInput | SortOrder
    providerResponse?: SortOrderInput | SortOrder
    kycVerificationRequired?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
    paymentMethod?: PaymentMethodOrderByWithRelationInput
  }

  export type WithdrawalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    AND?: WithdrawalWhereInput | WithdrawalWhereInput[]
    OR?: WithdrawalWhereInput[]
    NOT?: WithdrawalWhereInput | WithdrawalWhereInput[]
    paymentMethodId?: StringFilter<"Withdrawal"> | string
    amount?: DecimalFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Withdrawal"> | string
    providerTransactionId?: StringNullableFilter<"Withdrawal"> | string | null
    providerResponse?: JsonNullableFilter<"Withdrawal">
    kycVerificationRequired?: BoolFilter<"Withdrawal"> | boolean
    requestedAt?: DateTimeFilter<"Withdrawal"> | Date | string
    processedAt?: DateTimeNullableFilter<"Withdrawal"> | Date | string | null
    createdAt?: DateTimeFilter<"Withdrawal"> | Date | string
    updatedAt?: DateTimeFilter<"Withdrawal"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    paymentMethod?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
  }, "id" | "transactionId">

  export type WithdrawalOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    providerTransactionId?: SortOrderInput | SortOrder
    providerResponse?: SortOrderInput | SortOrder
    kycVerificationRequired?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WithdrawalCountOrderByAggregateInput
    _avg?: WithdrawalAvgOrderByAggregateInput
    _max?: WithdrawalMaxOrderByAggregateInput
    _min?: WithdrawalMinOrderByAggregateInput
    _sum?: WithdrawalSumOrderByAggregateInput
  }

  export type WithdrawalScalarWhereWithAggregatesInput = {
    AND?: WithdrawalScalarWhereWithAggregatesInput | WithdrawalScalarWhereWithAggregatesInput[]
    OR?: WithdrawalScalarWhereWithAggregatesInput[]
    NOT?: WithdrawalScalarWhereWithAggregatesInput | WithdrawalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Withdrawal"> | string
    transactionId?: StringWithAggregatesFilter<"Withdrawal"> | string
    paymentMethodId?: StringWithAggregatesFilter<"Withdrawal"> | string
    amount?: DecimalWithAggregatesFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalWithAggregatesFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalWithAggregatesFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"Withdrawal"> | string
    providerTransactionId?: StringNullableWithAggregatesFilter<"Withdrawal"> | string | null
    providerResponse?: JsonNullableWithAggregatesFilter<"Withdrawal">
    kycVerificationRequired?: BoolWithAggregatesFilter<"Withdrawal"> | boolean
    requestedAt?: DateTimeWithAggregatesFilter<"Withdrawal"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"Withdrawal"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Withdrawal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Withdrawal"> | Date | string
  }

  export type FraudEventWhereInput = {
    AND?: FraudEventWhereInput | FraudEventWhereInput[]
    OR?: FraudEventWhereInput[]
    NOT?: FraudEventWhereInput | FraudEventWhereInput[]
    id?: StringFilter<"FraudEvent"> | string
    userId?: StringNullableFilter<"FraudEvent"> | string | null
    eventType?: StringFilter<"FraudEvent"> | string
    severity?: StringFilter<"FraudEvent"> | string
    riskScore?: IntFilter<"FraudEvent"> | number
    description?: StringNullableFilter<"FraudEvent"> | string | null
    metadata?: JsonNullableFilter<"FraudEvent">
    status?: StringFilter<"FraudEvent"> | string
    reviewedBy?: StringNullableFilter<"FraudEvent"> | string | null
    reviewedAt?: DateTimeNullableFilter<"FraudEvent"> | Date | string | null
    createdAt?: DateTimeFilter<"FraudEvent"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type FraudEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    riskScore?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FraudEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FraudEventWhereInput | FraudEventWhereInput[]
    OR?: FraudEventWhereInput[]
    NOT?: FraudEventWhereInput | FraudEventWhereInput[]
    userId?: StringNullableFilter<"FraudEvent"> | string | null
    eventType?: StringFilter<"FraudEvent"> | string
    severity?: StringFilter<"FraudEvent"> | string
    riskScore?: IntFilter<"FraudEvent"> | number
    description?: StringNullableFilter<"FraudEvent"> | string | null
    metadata?: JsonNullableFilter<"FraudEvent">
    status?: StringFilter<"FraudEvent"> | string
    reviewedBy?: StringNullableFilter<"FraudEvent"> | string | null
    reviewedAt?: DateTimeNullableFilter<"FraudEvent"> | Date | string | null
    createdAt?: DateTimeFilter<"FraudEvent"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type FraudEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    riskScore?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FraudEventCountOrderByAggregateInput
    _avg?: FraudEventAvgOrderByAggregateInput
    _max?: FraudEventMaxOrderByAggregateInput
    _min?: FraudEventMinOrderByAggregateInput
    _sum?: FraudEventSumOrderByAggregateInput
  }

  export type FraudEventScalarWhereWithAggregatesInput = {
    AND?: FraudEventScalarWhereWithAggregatesInput | FraudEventScalarWhereWithAggregatesInput[]
    OR?: FraudEventScalarWhereWithAggregatesInput[]
    NOT?: FraudEventScalarWhereWithAggregatesInput | FraudEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FraudEvent"> | string
    userId?: StringNullableWithAggregatesFilter<"FraudEvent"> | string | null
    eventType?: StringWithAggregatesFilter<"FraudEvent"> | string
    severity?: StringWithAggregatesFilter<"FraudEvent"> | string
    riskScore?: IntWithAggregatesFilter<"FraudEvent"> | number
    description?: StringNullableWithAggregatesFilter<"FraudEvent"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"FraudEvent">
    status?: StringWithAggregatesFilter<"FraudEvent"> | string
    reviewedBy?: StringNullableWithAggregatesFilter<"FraudEvent"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"FraudEvent"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FraudEvent"> | Date | string
  }

  export type BettingPatternWhereInput = {
    AND?: BettingPatternWhereInput | BettingPatternWhereInput[]
    OR?: BettingPatternWhereInput[]
    NOT?: BettingPatternWhereInput | BettingPatternWhereInput[]
    id?: StringFilter<"BettingPattern"> | string
    userId?: StringFilter<"BettingPattern"> | string
    patternType?: StringFilter<"BettingPattern"> | string
    patternDetails?: JsonNullableFilter<"BettingPattern">
    detectedAt?: DateTimeFilter<"BettingPattern"> | Date | string
    riskScore?: IntFilter<"BettingPattern"> | number
    actionTaken?: StringNullableFilter<"BettingPattern"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BettingPatternOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    patternType?: SortOrder
    patternDetails?: SortOrderInput | SortOrder
    detectedAt?: SortOrder
    riskScore?: SortOrder
    actionTaken?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BettingPatternWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BettingPatternWhereInput | BettingPatternWhereInput[]
    OR?: BettingPatternWhereInput[]
    NOT?: BettingPatternWhereInput | BettingPatternWhereInput[]
    userId?: StringFilter<"BettingPattern"> | string
    patternType?: StringFilter<"BettingPattern"> | string
    patternDetails?: JsonNullableFilter<"BettingPattern">
    detectedAt?: DateTimeFilter<"BettingPattern"> | Date | string
    riskScore?: IntFilter<"BettingPattern"> | number
    actionTaken?: StringNullableFilter<"BettingPattern"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type BettingPatternOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    patternType?: SortOrder
    patternDetails?: SortOrderInput | SortOrder
    detectedAt?: SortOrder
    riskScore?: SortOrder
    actionTaken?: SortOrderInput | SortOrder
    _count?: BettingPatternCountOrderByAggregateInput
    _avg?: BettingPatternAvgOrderByAggregateInput
    _max?: BettingPatternMaxOrderByAggregateInput
    _min?: BettingPatternMinOrderByAggregateInput
    _sum?: BettingPatternSumOrderByAggregateInput
  }

  export type BettingPatternScalarWhereWithAggregatesInput = {
    AND?: BettingPatternScalarWhereWithAggregatesInput | BettingPatternScalarWhereWithAggregatesInput[]
    OR?: BettingPatternScalarWhereWithAggregatesInput[]
    NOT?: BettingPatternScalarWhereWithAggregatesInput | BettingPatternScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BettingPattern"> | string
    userId?: StringWithAggregatesFilter<"BettingPattern"> | string
    patternType?: StringWithAggregatesFilter<"BettingPattern"> | string
    patternDetails?: JsonNullableWithAggregatesFilter<"BettingPattern">
    detectedAt?: DateTimeWithAggregatesFilter<"BettingPattern"> | Date | string
    riskScore?: IntWithAggregatesFilter<"BettingPattern"> | number
    actionTaken?: StringNullableWithAggregatesFilter<"BettingPattern"> | string | null
  }

  export type AccountActivityLogWhereInput = {
    AND?: AccountActivityLogWhereInput | AccountActivityLogWhereInput[]
    OR?: AccountActivityLogWhereInput[]
    NOT?: AccountActivityLogWhereInput | AccountActivityLogWhereInput[]
    id?: StringFilter<"AccountActivityLog"> | string
    userId?: StringFilter<"AccountActivityLog"> | string
    activityType?: StringFilter<"AccountActivityLog"> | string
    ipAddressHash?: StringFilter<"AccountActivityLog"> | string
    deviceFingerprint?: StringNullableFilter<"AccountActivityLog"> | string | null
    country?: StringNullableFilter<"AccountActivityLog"> | string | null
    region?: StringNullableFilter<"AccountActivityLog"> | string | null
    city?: StringNullableFilter<"AccountActivityLog"> | string | null
    userAgent?: StringNullableFilter<"AccountActivityLog"> | string | null
    success?: BoolFilter<"AccountActivityLog"> | boolean
    metadata?: JsonNullableFilter<"AccountActivityLog">
    createdAt?: DateTimeFilter<"AccountActivityLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    activityType?: SortOrder
    ipAddressHash?: SortOrder
    deviceFingerprint?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    success?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountActivityLogWhereInput | AccountActivityLogWhereInput[]
    OR?: AccountActivityLogWhereInput[]
    NOT?: AccountActivityLogWhereInput | AccountActivityLogWhereInput[]
    userId?: StringFilter<"AccountActivityLog"> | string
    activityType?: StringFilter<"AccountActivityLog"> | string
    ipAddressHash?: StringFilter<"AccountActivityLog"> | string
    deviceFingerprint?: StringNullableFilter<"AccountActivityLog"> | string | null
    country?: StringNullableFilter<"AccountActivityLog"> | string | null
    region?: StringNullableFilter<"AccountActivityLog"> | string | null
    city?: StringNullableFilter<"AccountActivityLog"> | string | null
    userAgent?: StringNullableFilter<"AccountActivityLog"> | string | null
    success?: BoolFilter<"AccountActivityLog"> | boolean
    metadata?: JsonNullableFilter<"AccountActivityLog">
    createdAt?: DateTimeFilter<"AccountActivityLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    activityType?: SortOrder
    ipAddressHash?: SortOrder
    deviceFingerprint?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    success?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AccountActivityLogCountOrderByAggregateInput
    _max?: AccountActivityLogMaxOrderByAggregateInput
    _min?: AccountActivityLogMinOrderByAggregateInput
  }

  export type AccountActivityLogScalarWhereWithAggregatesInput = {
    AND?: AccountActivityLogScalarWhereWithAggregatesInput | AccountActivityLogScalarWhereWithAggregatesInput[]
    OR?: AccountActivityLogScalarWhereWithAggregatesInput[]
    NOT?: AccountActivityLogScalarWhereWithAggregatesInput | AccountActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccountActivityLog"> | string
    userId?: StringWithAggregatesFilter<"AccountActivityLog"> | string
    activityType?: StringWithAggregatesFilter<"AccountActivityLog"> | string
    ipAddressHash?: StringWithAggregatesFilter<"AccountActivityLog"> | string
    deviceFingerprint?: StringNullableWithAggregatesFilter<"AccountActivityLog"> | string | null
    country?: StringNullableWithAggregatesFilter<"AccountActivityLog"> | string | null
    region?: StringNullableWithAggregatesFilter<"AccountActivityLog"> | string | null
    city?: StringNullableWithAggregatesFilter<"AccountActivityLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AccountActivityLog"> | string | null
    success?: BoolWithAggregatesFilter<"AccountActivityLog"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"AccountActivityLog">
    createdAt?: DateTimeWithAggregatesFilter<"AccountActivityLog"> | Date | string
  }

  export type DeviceRegistryWhereInput = {
    AND?: DeviceRegistryWhereInput | DeviceRegistryWhereInput[]
    OR?: DeviceRegistryWhereInput[]
    NOT?: DeviceRegistryWhereInput | DeviceRegistryWhereInput[]
    id?: StringFilter<"DeviceRegistry"> | string
    userId?: StringFilter<"DeviceRegistry"> | string
    deviceFingerprint?: StringFilter<"DeviceRegistry"> | string
    deviceName?: StringNullableFilter<"DeviceRegistry"> | string | null
    deviceType?: StringNullableFilter<"DeviceRegistry"> | string | null
    os?: StringNullableFilter<"DeviceRegistry"> | string | null
    browser?: StringNullableFilter<"DeviceRegistry"> | string | null
    trusted?: BoolFilter<"DeviceRegistry"> | boolean
    blocked?: BoolFilter<"DeviceRegistry"> | boolean
    firstSeenAt?: DateTimeFilter<"DeviceRegistry"> | Date | string
    lastSeenAt?: DateTimeFilter<"DeviceRegistry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DeviceRegistryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceFingerprint?: SortOrder
    deviceName?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    trusted?: SortOrder
    blocked?: SortOrder
    firstSeenAt?: SortOrder
    lastSeenAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DeviceRegistryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_deviceFingerprint?: DeviceRegistryUserIdDeviceFingerprintCompoundUniqueInput
    AND?: DeviceRegistryWhereInput | DeviceRegistryWhereInput[]
    OR?: DeviceRegistryWhereInput[]
    NOT?: DeviceRegistryWhereInput | DeviceRegistryWhereInput[]
    userId?: StringFilter<"DeviceRegistry"> | string
    deviceFingerprint?: StringFilter<"DeviceRegistry"> | string
    deviceName?: StringNullableFilter<"DeviceRegistry"> | string | null
    deviceType?: StringNullableFilter<"DeviceRegistry"> | string | null
    os?: StringNullableFilter<"DeviceRegistry"> | string | null
    browser?: StringNullableFilter<"DeviceRegistry"> | string | null
    trusted?: BoolFilter<"DeviceRegistry"> | boolean
    blocked?: BoolFilter<"DeviceRegistry"> | boolean
    firstSeenAt?: DateTimeFilter<"DeviceRegistry"> | Date | string
    lastSeenAt?: DateTimeFilter<"DeviceRegistry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_deviceFingerprint">

  export type DeviceRegistryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceFingerprint?: SortOrder
    deviceName?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    trusted?: SortOrder
    blocked?: SortOrder
    firstSeenAt?: SortOrder
    lastSeenAt?: SortOrder
    _count?: DeviceRegistryCountOrderByAggregateInput
    _max?: DeviceRegistryMaxOrderByAggregateInput
    _min?: DeviceRegistryMinOrderByAggregateInput
  }

  export type DeviceRegistryScalarWhereWithAggregatesInput = {
    AND?: DeviceRegistryScalarWhereWithAggregatesInput | DeviceRegistryScalarWhereWithAggregatesInput[]
    OR?: DeviceRegistryScalarWhereWithAggregatesInput[]
    NOT?: DeviceRegistryScalarWhereWithAggregatesInput | DeviceRegistryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeviceRegistry"> | string
    userId?: StringWithAggregatesFilter<"DeviceRegistry"> | string
    deviceFingerprint?: StringWithAggregatesFilter<"DeviceRegistry"> | string
    deviceName?: StringNullableWithAggregatesFilter<"DeviceRegistry"> | string | null
    deviceType?: StringNullableWithAggregatesFilter<"DeviceRegistry"> | string | null
    os?: StringNullableWithAggregatesFilter<"DeviceRegistry"> | string | null
    browser?: StringNullableWithAggregatesFilter<"DeviceRegistry"> | string | null
    trusted?: BoolWithAggregatesFilter<"DeviceRegistry"> | boolean
    blocked?: BoolWithAggregatesFilter<"DeviceRegistry"> | boolean
    firstSeenAt?: DateTimeWithAggregatesFilter<"DeviceRegistry"> | Date | string
    lastSeenAt?: DateTimeWithAggregatesFilter<"DeviceRegistry"> | Date | string
  }

  export type IpAddressWhereInput = {
    AND?: IpAddressWhereInput | IpAddressWhereInput[]
    OR?: IpAddressWhereInput[]
    NOT?: IpAddressWhereInput | IpAddressWhereInput[]
    id?: StringFilter<"IpAddress"> | string
    ipAddressHash?: StringFilter<"IpAddress"> | string
    country?: StringNullableFilter<"IpAddress"> | string | null
    region?: StringNullableFilter<"IpAddress"> | string | null
    city?: StringNullableFilter<"IpAddress"> | string | null
    isp?: StringNullableFilter<"IpAddress"> | string | null
    isVpn?: BoolFilter<"IpAddress"> | boolean
    isProxy?: BoolFilter<"IpAddress"> | boolean
    riskScore?: IntFilter<"IpAddress"> | number
    blocked?: BoolFilter<"IpAddress"> | boolean
    firstSeenAt?: DateTimeFilter<"IpAddress"> | Date | string
    lastSeenAt?: DateTimeFilter<"IpAddress"> | Date | string
  }

  export type IpAddressOrderByWithRelationInput = {
    id?: SortOrder
    ipAddressHash?: SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    isp?: SortOrderInput | SortOrder
    isVpn?: SortOrder
    isProxy?: SortOrder
    riskScore?: SortOrder
    blocked?: SortOrder
    firstSeenAt?: SortOrder
    lastSeenAt?: SortOrder
  }

  export type IpAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ipAddressHash?: string
    AND?: IpAddressWhereInput | IpAddressWhereInput[]
    OR?: IpAddressWhereInput[]
    NOT?: IpAddressWhereInput | IpAddressWhereInput[]
    country?: StringNullableFilter<"IpAddress"> | string | null
    region?: StringNullableFilter<"IpAddress"> | string | null
    city?: StringNullableFilter<"IpAddress"> | string | null
    isp?: StringNullableFilter<"IpAddress"> | string | null
    isVpn?: BoolFilter<"IpAddress"> | boolean
    isProxy?: BoolFilter<"IpAddress"> | boolean
    riskScore?: IntFilter<"IpAddress"> | number
    blocked?: BoolFilter<"IpAddress"> | boolean
    firstSeenAt?: DateTimeFilter<"IpAddress"> | Date | string
    lastSeenAt?: DateTimeFilter<"IpAddress"> | Date | string
  }, "id" | "ipAddressHash">

  export type IpAddressOrderByWithAggregationInput = {
    id?: SortOrder
    ipAddressHash?: SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    isp?: SortOrderInput | SortOrder
    isVpn?: SortOrder
    isProxy?: SortOrder
    riskScore?: SortOrder
    blocked?: SortOrder
    firstSeenAt?: SortOrder
    lastSeenAt?: SortOrder
    _count?: IpAddressCountOrderByAggregateInput
    _avg?: IpAddressAvgOrderByAggregateInput
    _max?: IpAddressMaxOrderByAggregateInput
    _min?: IpAddressMinOrderByAggregateInput
    _sum?: IpAddressSumOrderByAggregateInput
  }

  export type IpAddressScalarWhereWithAggregatesInput = {
    AND?: IpAddressScalarWhereWithAggregatesInput | IpAddressScalarWhereWithAggregatesInput[]
    OR?: IpAddressScalarWhereWithAggregatesInput[]
    NOT?: IpAddressScalarWhereWithAggregatesInput | IpAddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IpAddress"> | string
    ipAddressHash?: StringWithAggregatesFilter<"IpAddress"> | string
    country?: StringNullableWithAggregatesFilter<"IpAddress"> | string | null
    region?: StringNullableWithAggregatesFilter<"IpAddress"> | string | null
    city?: StringNullableWithAggregatesFilter<"IpAddress"> | string | null
    isp?: StringNullableWithAggregatesFilter<"IpAddress"> | string | null
    isVpn?: BoolWithAggregatesFilter<"IpAddress"> | boolean
    isProxy?: BoolWithAggregatesFilter<"IpAddress"> | boolean
    riskScore?: IntWithAggregatesFilter<"IpAddress"> | number
    blocked?: BoolWithAggregatesFilter<"IpAddress"> | boolean
    firstSeenAt?: DateTimeWithAggregatesFilter<"IpAddress"> | Date | string
    lastSeenAt?: DateTimeWithAggregatesFilter<"IpAddress"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    ipAddressHash?: StringNullableFilter<"AuditLog"> | string | null
    changes?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    userId?: SortOrderInput | SortOrder
    ipAddressHash?: SortOrderInput | SortOrder
    changes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    ipAddressHash?: StringNullableFilter<"AuditLog"> | string | null
    changes?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    userId?: SortOrderInput | SortOrder
    ipAddressHash?: SortOrderInput | SortOrder
    changes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddressHash?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    changes?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type GdprConsentWhereInput = {
    AND?: GdprConsentWhereInput | GdprConsentWhereInput[]
    OR?: GdprConsentWhereInput[]
    NOT?: GdprConsentWhereInput | GdprConsentWhereInput[]
    id?: StringFilter<"GdprConsent"> | string
    userId?: StringFilter<"GdprConsent"> | string
    consentType?: StringFilter<"GdprConsent"> | string
    consentStatus?: StringFilter<"GdprConsent"> | string
    consentMethod?: StringFilter<"GdprConsent"> | string
    ipAddressHash?: StringNullableFilter<"GdprConsent"> | string | null
    withdrawnAt?: DateTimeNullableFilter<"GdprConsent"> | Date | string | null
    createdAt?: DateTimeFilter<"GdprConsent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GdprConsentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    consentType?: SortOrder
    consentStatus?: SortOrder
    consentMethod?: SortOrder
    ipAddressHash?: SortOrderInput | SortOrder
    withdrawnAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type GdprConsentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GdprConsentWhereInput | GdprConsentWhereInput[]
    OR?: GdprConsentWhereInput[]
    NOT?: GdprConsentWhereInput | GdprConsentWhereInput[]
    userId?: StringFilter<"GdprConsent"> | string
    consentType?: StringFilter<"GdprConsent"> | string
    consentStatus?: StringFilter<"GdprConsent"> | string
    consentMethod?: StringFilter<"GdprConsent"> | string
    ipAddressHash?: StringNullableFilter<"GdprConsent"> | string | null
    withdrawnAt?: DateTimeNullableFilter<"GdprConsent"> | Date | string | null
    createdAt?: DateTimeFilter<"GdprConsent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type GdprConsentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    consentType?: SortOrder
    consentStatus?: SortOrder
    consentMethod?: SortOrder
    ipAddressHash?: SortOrderInput | SortOrder
    withdrawnAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: GdprConsentCountOrderByAggregateInput
    _max?: GdprConsentMaxOrderByAggregateInput
    _min?: GdprConsentMinOrderByAggregateInput
  }

  export type GdprConsentScalarWhereWithAggregatesInput = {
    AND?: GdprConsentScalarWhereWithAggregatesInput | GdprConsentScalarWhereWithAggregatesInput[]
    OR?: GdprConsentScalarWhereWithAggregatesInput[]
    NOT?: GdprConsentScalarWhereWithAggregatesInput | GdprConsentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GdprConsent"> | string
    userId?: StringWithAggregatesFilter<"GdprConsent"> | string
    consentType?: StringWithAggregatesFilter<"GdprConsent"> | string
    consentStatus?: StringWithAggregatesFilter<"GdprConsent"> | string
    consentMethod?: StringWithAggregatesFilter<"GdprConsent"> | string
    ipAddressHash?: StringNullableWithAggregatesFilter<"GdprConsent"> | string | null
    withdrawnAt?: DateTimeNullableWithAggregatesFilter<"GdprConsent"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GdprConsent"> | Date | string
  }

  export type DataDeletionRequestWhereInput = {
    AND?: DataDeletionRequestWhereInput | DataDeletionRequestWhereInput[]
    OR?: DataDeletionRequestWhereInput[]
    NOT?: DataDeletionRequestWhereInput | DataDeletionRequestWhereInput[]
    id?: StringFilter<"DataDeletionRequest"> | string
    userId?: StringFilter<"DataDeletionRequest"> | string
    status?: StringFilter<"DataDeletionRequest"> | string
    requestedAt?: DateTimeFilter<"DataDeletionRequest"> | Date | string
    processedAt?: DateTimeNullableFilter<"DataDeletionRequest"> | Date | string | null
    rejectionReason?: StringNullableFilter<"DataDeletionRequest"> | string | null
    dataDeleted?: JsonNullableFilter<"DataDeletionRequest">
    createdAt?: DateTimeFilter<"DataDeletionRequest"> | Date | string
    updatedAt?: DateTimeFilter<"DataDeletionRequest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DataDeletionRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    dataDeleted?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DataDeletionRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: DataDeletionRequestWhereInput | DataDeletionRequestWhereInput[]
    OR?: DataDeletionRequestWhereInput[]
    NOT?: DataDeletionRequestWhereInput | DataDeletionRequestWhereInput[]
    status?: StringFilter<"DataDeletionRequest"> | string
    requestedAt?: DateTimeFilter<"DataDeletionRequest"> | Date | string
    processedAt?: DateTimeNullableFilter<"DataDeletionRequest"> | Date | string | null
    rejectionReason?: StringNullableFilter<"DataDeletionRequest"> | string | null
    dataDeleted?: JsonNullableFilter<"DataDeletionRequest">
    createdAt?: DateTimeFilter<"DataDeletionRequest"> | Date | string
    updatedAt?: DateTimeFilter<"DataDeletionRequest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type DataDeletionRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    dataDeleted?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DataDeletionRequestCountOrderByAggregateInput
    _max?: DataDeletionRequestMaxOrderByAggregateInput
    _min?: DataDeletionRequestMinOrderByAggregateInput
  }

  export type DataDeletionRequestScalarWhereWithAggregatesInput = {
    AND?: DataDeletionRequestScalarWhereWithAggregatesInput | DataDeletionRequestScalarWhereWithAggregatesInput[]
    OR?: DataDeletionRequestScalarWhereWithAggregatesInput[]
    NOT?: DataDeletionRequestScalarWhereWithAggregatesInput | DataDeletionRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DataDeletionRequest"> | string
    userId?: StringWithAggregatesFilter<"DataDeletionRequest"> | string
    status?: StringWithAggregatesFilter<"DataDeletionRequest"> | string
    requestedAt?: DateTimeWithAggregatesFilter<"DataDeletionRequest"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"DataDeletionRequest"> | Date | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"DataDeletionRequest"> | string | null
    dataDeleted?: JsonNullableWithAggregatesFilter<"DataDeletionRequest">
    createdAt?: DateTimeWithAggregatesFilter<"DataDeletionRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DataDeletionRequest"> | Date | string
  }

  export type DataExportRequestWhereInput = {
    AND?: DataExportRequestWhereInput | DataExportRequestWhereInput[]
    OR?: DataExportRequestWhereInput[]
    NOT?: DataExportRequestWhereInput | DataExportRequestWhereInput[]
    id?: StringFilter<"DataExportRequest"> | string
    userId?: StringFilter<"DataExportRequest"> | string
    status?: StringFilter<"DataExportRequest"> | string
    exportFormat?: StringFilter<"DataExportRequest"> | string
    filePath?: StringNullableFilter<"DataExportRequest"> | string | null
    expiresAt?: DateTimeNullableFilter<"DataExportRequest"> | Date | string | null
    requestedAt?: DateTimeFilter<"DataExportRequest"> | Date | string
    processedAt?: DateTimeNullableFilter<"DataExportRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"DataExportRequest"> | Date | string
    updatedAt?: DateTimeFilter<"DataExportRequest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DataExportRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    exportFormat?: SortOrder
    filePath?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DataExportRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DataExportRequestWhereInput | DataExportRequestWhereInput[]
    OR?: DataExportRequestWhereInput[]
    NOT?: DataExportRequestWhereInput | DataExportRequestWhereInput[]
    userId?: StringFilter<"DataExportRequest"> | string
    status?: StringFilter<"DataExportRequest"> | string
    exportFormat?: StringFilter<"DataExportRequest"> | string
    filePath?: StringNullableFilter<"DataExportRequest"> | string | null
    expiresAt?: DateTimeNullableFilter<"DataExportRequest"> | Date | string | null
    requestedAt?: DateTimeFilter<"DataExportRequest"> | Date | string
    processedAt?: DateTimeNullableFilter<"DataExportRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"DataExportRequest"> | Date | string
    updatedAt?: DateTimeFilter<"DataExportRequest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DataExportRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    exportFormat?: SortOrder
    filePath?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DataExportRequestCountOrderByAggregateInput
    _max?: DataExportRequestMaxOrderByAggregateInput
    _min?: DataExportRequestMinOrderByAggregateInput
  }

  export type DataExportRequestScalarWhereWithAggregatesInput = {
    AND?: DataExportRequestScalarWhereWithAggregatesInput | DataExportRequestScalarWhereWithAggregatesInput[]
    OR?: DataExportRequestScalarWhereWithAggregatesInput[]
    NOT?: DataExportRequestScalarWhereWithAggregatesInput | DataExportRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DataExportRequest"> | string
    userId?: StringWithAggregatesFilter<"DataExportRequest"> | string
    status?: StringWithAggregatesFilter<"DataExportRequest"> | string
    exportFormat?: StringWithAggregatesFilter<"DataExportRequest"> | string
    filePath?: StringNullableWithAggregatesFilter<"DataExportRequest"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"DataExportRequest"> | Date | string | null
    requestedAt?: DateTimeWithAggregatesFilter<"DataExportRequest"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"DataExportRequest"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DataExportRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DataExportRequest"> | Date | string
  }

  export type SecurityAlertWhereInput = {
    AND?: SecurityAlertWhereInput | SecurityAlertWhereInput[]
    OR?: SecurityAlertWhereInput[]
    NOT?: SecurityAlertWhereInput | SecurityAlertWhereInput[]
    id?: StringFilter<"SecurityAlert"> | string
    userId?: StringNullableFilter<"SecurityAlert"> | string | null
    alertType?: StringFilter<"SecurityAlert"> | string
    severity?: StringFilter<"SecurityAlert"> | string
    description?: StringNullableFilter<"SecurityAlert"> | string | null
    actionRequired?: StringNullableFilter<"SecurityAlert"> | string | null
    acknowledged?: BoolFilter<"SecurityAlert"> | boolean
    createdAt?: DateTimeFilter<"SecurityAlert"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type SecurityAlertOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    description?: SortOrderInput | SortOrder
    actionRequired?: SortOrderInput | SortOrder
    acknowledged?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SecurityAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SecurityAlertWhereInput | SecurityAlertWhereInput[]
    OR?: SecurityAlertWhereInput[]
    NOT?: SecurityAlertWhereInput | SecurityAlertWhereInput[]
    userId?: StringNullableFilter<"SecurityAlert"> | string | null
    alertType?: StringFilter<"SecurityAlert"> | string
    severity?: StringFilter<"SecurityAlert"> | string
    description?: StringNullableFilter<"SecurityAlert"> | string | null
    actionRequired?: StringNullableFilter<"SecurityAlert"> | string | null
    acknowledged?: BoolFilter<"SecurityAlert"> | boolean
    createdAt?: DateTimeFilter<"SecurityAlert"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type SecurityAlertOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    description?: SortOrderInput | SortOrder
    actionRequired?: SortOrderInput | SortOrder
    acknowledged?: SortOrder
    createdAt?: SortOrder
    _count?: SecurityAlertCountOrderByAggregateInput
    _max?: SecurityAlertMaxOrderByAggregateInput
    _min?: SecurityAlertMinOrderByAggregateInput
  }

  export type SecurityAlertScalarWhereWithAggregatesInput = {
    AND?: SecurityAlertScalarWhereWithAggregatesInput | SecurityAlertScalarWhereWithAggregatesInput[]
    OR?: SecurityAlertScalarWhereWithAggregatesInput[]
    NOT?: SecurityAlertScalarWhereWithAggregatesInput | SecurityAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SecurityAlert"> | string
    userId?: StringNullableWithAggregatesFilter<"SecurityAlert"> | string | null
    alertType?: StringWithAggregatesFilter<"SecurityAlert"> | string
    severity?: StringWithAggregatesFilter<"SecurityAlert"> | string
    description?: StringNullableWithAggregatesFilter<"SecurityAlert"> | string | null
    actionRequired?: StringNullableWithAggregatesFilter<"SecurityAlert"> | string | null
    acknowledged?: BoolWithAggregatesFilter<"SecurityAlert"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SecurityAlert"> | Date | string
  }

  export type PromotionWhereInput = {
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    id?: StringFilter<"Promotion"> | string
    name?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    promotionType?: StringFilter<"Promotion"> | string
    termsAndConditions?: StringNullableFilter<"Promotion"> | string | null
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    endDate?: DateTimeFilter<"Promotion"> | Date | string
    active?: BoolFilter<"Promotion"> | boolean
    eligibilityCriteria?: JsonNullableFilter<"Promotion">
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
    userBonuses?: UserBonusListRelationFilter
  }

  export type PromotionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    promotionType?: SortOrder
    termsAndConditions?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    active?: SortOrder
    eligibilityCriteria?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userBonuses?: UserBonusOrderByRelationAggregateInput
  }

  export type PromotionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    name?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    promotionType?: StringFilter<"Promotion"> | string
    termsAndConditions?: StringNullableFilter<"Promotion"> | string | null
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    endDate?: DateTimeFilter<"Promotion"> | Date | string
    active?: BoolFilter<"Promotion"> | boolean
    eligibilityCriteria?: JsonNullableFilter<"Promotion">
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
    userBonuses?: UserBonusListRelationFilter
  }, "id">

  export type PromotionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    promotionType?: SortOrder
    termsAndConditions?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    active?: SortOrder
    eligibilityCriteria?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PromotionCountOrderByAggregateInput
    _max?: PromotionMaxOrderByAggregateInput
    _min?: PromotionMinOrderByAggregateInput
  }

  export type PromotionScalarWhereWithAggregatesInput = {
    AND?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    OR?: PromotionScalarWhereWithAggregatesInput[]
    NOT?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Promotion"> | string
    name?: StringWithAggregatesFilter<"Promotion"> | string
    description?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    promotionType?: StringWithAggregatesFilter<"Promotion"> | string
    termsAndConditions?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    active?: BoolWithAggregatesFilter<"Promotion"> | boolean
    eligibilityCriteria?: JsonNullableWithAggregatesFilter<"Promotion">
    createdAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
  }

  export type UserBonusWhereInput = {
    AND?: UserBonusWhereInput | UserBonusWhereInput[]
    OR?: UserBonusWhereInput[]
    NOT?: UserBonusWhereInput | UserBonusWhereInput[]
    id?: StringFilter<"UserBonus"> | string
    userId?: StringFilter<"UserBonus"> | string
    promotionId?: StringFilter<"UserBonus"> | string
    bonusAmount?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    wageringRequirement?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"UserBonus"> | string
    expiresAt?: DateTimeNullableFilter<"UserBonus"> | Date | string | null
    createdAt?: DateTimeFilter<"UserBonus"> | Date | string
    updatedAt?: DateTimeFilter<"UserBonus"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    promotion?: XOR<PromotionScalarRelationFilter, PromotionWhereInput>
  }

  export type UserBonusOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    promotionId?: SortOrder
    bonusAmount?: SortOrder
    wageringRequirement?: SortOrder
    wageredAmount?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    promotion?: PromotionOrderByWithRelationInput
  }

  export type UserBonusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserBonusWhereInput | UserBonusWhereInput[]
    OR?: UserBonusWhereInput[]
    NOT?: UserBonusWhereInput | UserBonusWhereInput[]
    userId?: StringFilter<"UserBonus"> | string
    promotionId?: StringFilter<"UserBonus"> | string
    bonusAmount?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    wageringRequirement?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"UserBonus"> | string
    expiresAt?: DateTimeNullableFilter<"UserBonus"> | Date | string | null
    createdAt?: DateTimeFilter<"UserBonus"> | Date | string
    updatedAt?: DateTimeFilter<"UserBonus"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    promotion?: XOR<PromotionScalarRelationFilter, PromotionWhereInput>
  }, "id">

  export type UserBonusOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    promotionId?: SortOrder
    bonusAmount?: SortOrder
    wageringRequirement?: SortOrder
    wageredAmount?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserBonusCountOrderByAggregateInput
    _avg?: UserBonusAvgOrderByAggregateInput
    _max?: UserBonusMaxOrderByAggregateInput
    _min?: UserBonusMinOrderByAggregateInput
    _sum?: UserBonusSumOrderByAggregateInput
  }

  export type UserBonusScalarWhereWithAggregatesInput = {
    AND?: UserBonusScalarWhereWithAggregatesInput | UserBonusScalarWhereWithAggregatesInput[]
    OR?: UserBonusScalarWhereWithAggregatesInput[]
    NOT?: UserBonusScalarWhereWithAggregatesInput | UserBonusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserBonus"> | string
    userId?: StringWithAggregatesFilter<"UserBonus"> | string
    promotionId?: StringWithAggregatesFilter<"UserBonus"> | string
    bonusAmount?: DecimalWithAggregatesFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    wageringRequirement?: DecimalWithAggregatesFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalWithAggregatesFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"UserBonus"> | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"UserBonus"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserBonus"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserBonus"> | Date | string
  }

  export type CurrentOddsWhereInput = {
    AND?: CurrentOddsWhereInput | CurrentOddsWhereInput[]
    OR?: CurrentOddsWhereInput[]
    NOT?: CurrentOddsWhereInput | CurrentOddsWhereInput[]
    id?: StringFilter<"CurrentOdds"> | string
    selectionId?: StringFilter<"CurrentOdds"> | string
    currentOdds?: DecimalFilter<"CurrentOdds"> | Decimal | DecimalJsLike | number | string
    previousOdds?: DecimalNullableFilter<"CurrentOdds"> | Decimal | DecimalJsLike | number | string | null
    oddsMovement?: StringNullableFilter<"CurrentOdds"> | string | null
    lastUpdatedAt?: DateTimeFilter<"CurrentOdds"> | Date | string
    syncedAt?: DateTimeFilter<"CurrentOdds"> | Date | string
    externalOddsId?: StringNullableFilter<"CurrentOdds"> | string | null
    suspended?: BoolFilter<"CurrentOdds"> | boolean
    selection?: XOR<BetSelectionScalarRelationFilter, BetSelectionWhereInput>
  }

  export type CurrentOddsOrderByWithRelationInput = {
    id?: SortOrder
    selectionId?: SortOrder
    currentOdds?: SortOrder
    previousOdds?: SortOrderInput | SortOrder
    oddsMovement?: SortOrderInput | SortOrder
    lastUpdatedAt?: SortOrder
    syncedAt?: SortOrder
    externalOddsId?: SortOrderInput | SortOrder
    suspended?: SortOrder
    selection?: BetSelectionOrderByWithRelationInput
  }

  export type CurrentOddsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    selectionId?: string
    AND?: CurrentOddsWhereInput | CurrentOddsWhereInput[]
    OR?: CurrentOddsWhereInput[]
    NOT?: CurrentOddsWhereInput | CurrentOddsWhereInput[]
    currentOdds?: DecimalFilter<"CurrentOdds"> | Decimal | DecimalJsLike | number | string
    previousOdds?: DecimalNullableFilter<"CurrentOdds"> | Decimal | DecimalJsLike | number | string | null
    oddsMovement?: StringNullableFilter<"CurrentOdds"> | string | null
    lastUpdatedAt?: DateTimeFilter<"CurrentOdds"> | Date | string
    syncedAt?: DateTimeFilter<"CurrentOdds"> | Date | string
    externalOddsId?: StringNullableFilter<"CurrentOdds"> | string | null
    suspended?: BoolFilter<"CurrentOdds"> | boolean
    selection?: XOR<BetSelectionScalarRelationFilter, BetSelectionWhereInput>
  }, "id" | "selectionId">

  export type CurrentOddsOrderByWithAggregationInput = {
    id?: SortOrder
    selectionId?: SortOrder
    currentOdds?: SortOrder
    previousOdds?: SortOrderInput | SortOrder
    oddsMovement?: SortOrderInput | SortOrder
    lastUpdatedAt?: SortOrder
    syncedAt?: SortOrder
    externalOddsId?: SortOrderInput | SortOrder
    suspended?: SortOrder
    _count?: CurrentOddsCountOrderByAggregateInput
    _avg?: CurrentOddsAvgOrderByAggregateInput
    _max?: CurrentOddsMaxOrderByAggregateInput
    _min?: CurrentOddsMinOrderByAggregateInput
    _sum?: CurrentOddsSumOrderByAggregateInput
  }

  export type CurrentOddsScalarWhereWithAggregatesInput = {
    AND?: CurrentOddsScalarWhereWithAggregatesInput | CurrentOddsScalarWhereWithAggregatesInput[]
    OR?: CurrentOddsScalarWhereWithAggregatesInput[]
    NOT?: CurrentOddsScalarWhereWithAggregatesInput | CurrentOddsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CurrentOdds"> | string
    selectionId?: StringWithAggregatesFilter<"CurrentOdds"> | string
    currentOdds?: DecimalWithAggregatesFilter<"CurrentOdds"> | Decimal | DecimalJsLike | number | string
    previousOdds?: DecimalNullableWithAggregatesFilter<"CurrentOdds"> | Decimal | DecimalJsLike | number | string | null
    oddsMovement?: StringNullableWithAggregatesFilter<"CurrentOdds"> | string | null
    lastUpdatedAt?: DateTimeWithAggregatesFilter<"CurrentOdds"> | Date | string
    syncedAt?: DateTimeWithAggregatesFilter<"CurrentOdds"> | Date | string
    externalOddsId?: StringNullableWithAggregatesFilter<"CurrentOdds"> | string | null
    suspended?: BoolWithAggregatesFilter<"CurrentOdds"> | boolean
  }

  export type OddsSnapshotWhereInput = {
    AND?: OddsSnapshotWhereInput | OddsSnapshotWhereInput[]
    OR?: OddsSnapshotWhereInput[]
    NOT?: OddsSnapshotWhereInput | OddsSnapshotWhereInput[]
    id?: StringFilter<"OddsSnapshot"> | string
    selectionId?: StringFilter<"OddsSnapshot"> | string
    odds?: DecimalFilter<"OddsSnapshot"> | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeFilter<"OddsSnapshot"> | Date | string
    source?: StringFilter<"OddsSnapshot"> | string
    metadata?: JsonNullableFilter<"OddsSnapshot">
    selection?: XOR<BetSelectionScalarRelationFilter, BetSelectionWhereInput>
  }

  export type OddsSnapshotOrderByWithRelationInput = {
    id?: SortOrder
    selectionId?: SortOrder
    odds?: SortOrder
    timestamp?: SortOrder
    source?: SortOrder
    metadata?: SortOrderInput | SortOrder
    selection?: BetSelectionOrderByWithRelationInput
  }

  export type OddsSnapshotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OddsSnapshotWhereInput | OddsSnapshotWhereInput[]
    OR?: OddsSnapshotWhereInput[]
    NOT?: OddsSnapshotWhereInput | OddsSnapshotWhereInput[]
    selectionId?: StringFilter<"OddsSnapshot"> | string
    odds?: DecimalFilter<"OddsSnapshot"> | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeFilter<"OddsSnapshot"> | Date | string
    source?: StringFilter<"OddsSnapshot"> | string
    metadata?: JsonNullableFilter<"OddsSnapshot">
    selection?: XOR<BetSelectionScalarRelationFilter, BetSelectionWhereInput>
  }, "id">

  export type OddsSnapshotOrderByWithAggregationInput = {
    id?: SortOrder
    selectionId?: SortOrder
    odds?: SortOrder
    timestamp?: SortOrder
    source?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: OddsSnapshotCountOrderByAggregateInput
    _avg?: OddsSnapshotAvgOrderByAggregateInput
    _max?: OddsSnapshotMaxOrderByAggregateInput
    _min?: OddsSnapshotMinOrderByAggregateInput
    _sum?: OddsSnapshotSumOrderByAggregateInput
  }

  export type OddsSnapshotScalarWhereWithAggregatesInput = {
    AND?: OddsSnapshotScalarWhereWithAggregatesInput | OddsSnapshotScalarWhereWithAggregatesInput[]
    OR?: OddsSnapshotScalarWhereWithAggregatesInput[]
    NOT?: OddsSnapshotScalarWhereWithAggregatesInput | OddsSnapshotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OddsSnapshot"> | string
    selectionId?: StringWithAggregatesFilter<"OddsSnapshot"> | string
    odds?: DecimalWithAggregatesFilter<"OddsSnapshot"> | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeWithAggregatesFilter<"OddsSnapshot"> | Date | string
    source?: StringWithAggregatesFilter<"OddsSnapshot"> | string
    metadata?: JsonNullableWithAggregatesFilter<"OddsSnapshot">
  }

  export type OddsSyncStatusWhereInput = {
    AND?: OddsSyncStatusWhereInput | OddsSyncStatusWhereInput[]
    OR?: OddsSyncStatusWhereInput[]
    NOT?: OddsSyncStatusWhereInput | OddsSyncStatusWhereInput[]
    id?: StringFilter<"OddsSyncStatus"> | string
    gameId?: StringFilter<"OddsSyncStatus"> | string
    lastSyncAt?: DateTimeFilter<"OddsSyncStatus"> | Date | string
    nextSyncAt?: DateTimeNullableFilter<"OddsSyncStatus"> | Date | string | null
    syncStatus?: StringFilter<"OddsSyncStatus"> | string
    failureCount?: IntFilter<"OddsSyncStatus"> | number
    lastError?: StringNullableFilter<"OddsSyncStatus"> | string | null
    syncInterval?: IntFilter<"OddsSyncStatus"> | number
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
  }

  export type OddsSyncStatusOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    lastSyncAt?: SortOrder
    nextSyncAt?: SortOrderInput | SortOrder
    syncStatus?: SortOrder
    failureCount?: SortOrder
    lastError?: SortOrderInput | SortOrder
    syncInterval?: SortOrder
    game?: GameOrderByWithRelationInput
  }

  export type OddsSyncStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gameId?: string
    AND?: OddsSyncStatusWhereInput | OddsSyncStatusWhereInput[]
    OR?: OddsSyncStatusWhereInput[]
    NOT?: OddsSyncStatusWhereInput | OddsSyncStatusWhereInput[]
    lastSyncAt?: DateTimeFilter<"OddsSyncStatus"> | Date | string
    nextSyncAt?: DateTimeNullableFilter<"OddsSyncStatus"> | Date | string | null
    syncStatus?: StringFilter<"OddsSyncStatus"> | string
    failureCount?: IntFilter<"OddsSyncStatus"> | number
    lastError?: StringNullableFilter<"OddsSyncStatus"> | string | null
    syncInterval?: IntFilter<"OddsSyncStatus"> | number
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
  }, "id" | "gameId">

  export type OddsSyncStatusOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    lastSyncAt?: SortOrder
    nextSyncAt?: SortOrderInput | SortOrder
    syncStatus?: SortOrder
    failureCount?: SortOrder
    lastError?: SortOrderInput | SortOrder
    syncInterval?: SortOrder
    _count?: OddsSyncStatusCountOrderByAggregateInput
    _avg?: OddsSyncStatusAvgOrderByAggregateInput
    _max?: OddsSyncStatusMaxOrderByAggregateInput
    _min?: OddsSyncStatusMinOrderByAggregateInput
    _sum?: OddsSyncStatusSumOrderByAggregateInput
  }

  export type OddsSyncStatusScalarWhereWithAggregatesInput = {
    AND?: OddsSyncStatusScalarWhereWithAggregatesInput | OddsSyncStatusScalarWhereWithAggregatesInput[]
    OR?: OddsSyncStatusScalarWhereWithAggregatesInput[]
    NOT?: OddsSyncStatusScalarWhereWithAggregatesInput | OddsSyncStatusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OddsSyncStatus"> | string
    gameId?: StringWithAggregatesFilter<"OddsSyncStatus"> | string
    lastSyncAt?: DateTimeWithAggregatesFilter<"OddsSyncStatus"> | Date | string
    nextSyncAt?: DateTimeNullableWithAggregatesFilter<"OddsSyncStatus"> | Date | string | null
    syncStatus?: StringWithAggregatesFilter<"OddsSyncStatus"> | string
    failureCount?: IntWithAggregatesFilter<"OddsSyncStatus"> | number
    lastError?: StringNullableWithAggregatesFilter<"OddsSyncStatus"> | string | null
    syncInterval?: IntWithAggregatesFilter<"OddsSyncStatus"> | number
  }

  export type OddsChangeEventWhereInput = {
    AND?: OddsChangeEventWhereInput | OddsChangeEventWhereInput[]
    OR?: OddsChangeEventWhereInput[]
    NOT?: OddsChangeEventWhereInput | OddsChangeEventWhereInput[]
    id?: StringFilter<"OddsChangeEvent"> | string
    selectionId?: StringFilter<"OddsChangeEvent"> | string
    gameId?: StringFilter<"OddsChangeEvent"> | string
    oldOdds?: DecimalFilter<"OddsChangeEvent"> | Decimal | DecimalJsLike | number | string
    newOdds?: DecimalFilter<"OddsChangeEvent"> | Decimal | DecimalJsLike | number | string
    changePercentage?: DecimalFilter<"OddsChangeEvent"> | Decimal | DecimalJsLike | number | string
    changeType?: StringFilter<"OddsChangeEvent"> | string
    broadcasted?: BoolFilter<"OddsChangeEvent"> | boolean
    createdAt?: DateTimeFilter<"OddsChangeEvent"> | Date | string
  }

  export type OddsChangeEventOrderByWithRelationInput = {
    id?: SortOrder
    selectionId?: SortOrder
    gameId?: SortOrder
    oldOdds?: SortOrder
    newOdds?: SortOrder
    changePercentage?: SortOrder
    changeType?: SortOrder
    broadcasted?: SortOrder
    createdAt?: SortOrder
  }

  export type OddsChangeEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OddsChangeEventWhereInput | OddsChangeEventWhereInput[]
    OR?: OddsChangeEventWhereInput[]
    NOT?: OddsChangeEventWhereInput | OddsChangeEventWhereInput[]
    selectionId?: StringFilter<"OddsChangeEvent"> | string
    gameId?: StringFilter<"OddsChangeEvent"> | string
    oldOdds?: DecimalFilter<"OddsChangeEvent"> | Decimal | DecimalJsLike | number | string
    newOdds?: DecimalFilter<"OddsChangeEvent"> | Decimal | DecimalJsLike | number | string
    changePercentage?: DecimalFilter<"OddsChangeEvent"> | Decimal | DecimalJsLike | number | string
    changeType?: StringFilter<"OddsChangeEvent"> | string
    broadcasted?: BoolFilter<"OddsChangeEvent"> | boolean
    createdAt?: DateTimeFilter<"OddsChangeEvent"> | Date | string
  }, "id">

  export type OddsChangeEventOrderByWithAggregationInput = {
    id?: SortOrder
    selectionId?: SortOrder
    gameId?: SortOrder
    oldOdds?: SortOrder
    newOdds?: SortOrder
    changePercentage?: SortOrder
    changeType?: SortOrder
    broadcasted?: SortOrder
    createdAt?: SortOrder
    _count?: OddsChangeEventCountOrderByAggregateInput
    _avg?: OddsChangeEventAvgOrderByAggregateInput
    _max?: OddsChangeEventMaxOrderByAggregateInput
    _min?: OddsChangeEventMinOrderByAggregateInput
    _sum?: OddsChangeEventSumOrderByAggregateInput
  }

  export type OddsChangeEventScalarWhereWithAggregatesInput = {
    AND?: OddsChangeEventScalarWhereWithAggregatesInput | OddsChangeEventScalarWhereWithAggregatesInput[]
    OR?: OddsChangeEventScalarWhereWithAggregatesInput[]
    NOT?: OddsChangeEventScalarWhereWithAggregatesInput | OddsChangeEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OddsChangeEvent"> | string
    selectionId?: StringWithAggregatesFilter<"OddsChangeEvent"> | string
    gameId?: StringWithAggregatesFilter<"OddsChangeEvent"> | string
    oldOdds?: DecimalWithAggregatesFilter<"OddsChangeEvent"> | Decimal | DecimalJsLike | number | string
    newOdds?: DecimalWithAggregatesFilter<"OddsChangeEvent"> | Decimal | DecimalJsLike | number | string
    changePercentage?: DecimalWithAggregatesFilter<"OddsChangeEvent"> | Decimal | DecimalJsLike | number | string
    changeType?: StringWithAggregatesFilter<"OddsChangeEvent"> | string
    broadcasted?: BoolWithAggregatesFilter<"OddsChangeEvent"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OddsChangeEvent"> | Date | string
  }

  export type ApiOddsSnapshotWhereInput = {
    AND?: ApiOddsSnapshotWhereInput | ApiOddsSnapshotWhereInput[]
    OR?: ApiOddsSnapshotWhereInput[]
    NOT?: ApiOddsSnapshotWhereInput | ApiOddsSnapshotWhereInput[]
    id?: StringFilter<"ApiOddsSnapshot"> | string
    externalGameId?: StringFilter<"ApiOddsSnapshot"> | string
    sportKey?: StringFilter<"ApiOddsSnapshot"> | string
    homeTeam?: StringFilter<"ApiOddsSnapshot"> | string
    awayTeam?: StringFilter<"ApiOddsSnapshot"> | string
    commenceTime?: DateTimeFilter<"ApiOddsSnapshot"> | Date | string
    bookmaker?: StringFilter<"ApiOddsSnapshot"> | string
    rawData?: JsonFilter<"ApiOddsSnapshot">
    timestamp?: DateTimeFilter<"ApiOddsSnapshot"> | Date | string
  }

  export type ApiOddsSnapshotOrderByWithRelationInput = {
    id?: SortOrder
    externalGameId?: SortOrder
    sportKey?: SortOrder
    homeTeam?: SortOrder
    awayTeam?: SortOrder
    commenceTime?: SortOrder
    bookmaker?: SortOrder
    rawData?: SortOrder
    timestamp?: SortOrder
  }

  export type ApiOddsSnapshotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    externalGameId_bookmaker_timestamp?: ApiOddsSnapshotExternalGameIdBookmakerTimestampCompoundUniqueInput
    AND?: ApiOddsSnapshotWhereInput | ApiOddsSnapshotWhereInput[]
    OR?: ApiOddsSnapshotWhereInput[]
    NOT?: ApiOddsSnapshotWhereInput | ApiOddsSnapshotWhereInput[]
    externalGameId?: StringFilter<"ApiOddsSnapshot"> | string
    sportKey?: StringFilter<"ApiOddsSnapshot"> | string
    homeTeam?: StringFilter<"ApiOddsSnapshot"> | string
    awayTeam?: StringFilter<"ApiOddsSnapshot"> | string
    commenceTime?: DateTimeFilter<"ApiOddsSnapshot"> | Date | string
    bookmaker?: StringFilter<"ApiOddsSnapshot"> | string
    rawData?: JsonFilter<"ApiOddsSnapshot">
    timestamp?: DateTimeFilter<"ApiOddsSnapshot"> | Date | string
  }, "id" | "externalGameId_bookmaker_timestamp">

  export type ApiOddsSnapshotOrderByWithAggregationInput = {
    id?: SortOrder
    externalGameId?: SortOrder
    sportKey?: SortOrder
    homeTeam?: SortOrder
    awayTeam?: SortOrder
    commenceTime?: SortOrder
    bookmaker?: SortOrder
    rawData?: SortOrder
    timestamp?: SortOrder
    _count?: ApiOddsSnapshotCountOrderByAggregateInput
    _max?: ApiOddsSnapshotMaxOrderByAggregateInput
    _min?: ApiOddsSnapshotMinOrderByAggregateInput
  }

  export type ApiOddsSnapshotScalarWhereWithAggregatesInput = {
    AND?: ApiOddsSnapshotScalarWhereWithAggregatesInput | ApiOddsSnapshotScalarWhereWithAggregatesInput[]
    OR?: ApiOddsSnapshotScalarWhereWithAggregatesInput[]
    NOT?: ApiOddsSnapshotScalarWhereWithAggregatesInput | ApiOddsSnapshotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiOddsSnapshot"> | string
    externalGameId?: StringWithAggregatesFilter<"ApiOddsSnapshot"> | string
    sportKey?: StringWithAggregatesFilter<"ApiOddsSnapshot"> | string
    homeTeam?: StringWithAggregatesFilter<"ApiOddsSnapshot"> | string
    awayTeam?: StringWithAggregatesFilter<"ApiOddsSnapshot"> | string
    commenceTime?: DateTimeWithAggregatesFilter<"ApiOddsSnapshot"> | Date | string
    bookmaker?: StringWithAggregatesFilter<"ApiOddsSnapshot"> | string
    rawData?: JsonWithAggregatesFilter<"ApiOddsSnapshot">
    timestamp?: DateTimeWithAggregatesFilter<"ApiOddsSnapshot"> | Date | string
  }

  export type OddsAuditLogWhereInput = {
    AND?: OddsAuditLogWhereInput | OddsAuditLogWhereInput[]
    OR?: OddsAuditLogWhereInput[]
    NOT?: OddsAuditLogWhereInput | OddsAuditLogWhereInput[]
    id?: StringFilter<"OddsAuditLog"> | string
    externalGameId?: StringFilter<"OddsAuditLog"> | string
    sportKey?: StringFilter<"OddsAuditLog"> | string
    marketKey?: StringFilter<"OddsAuditLog"> | string
    selectionName?: StringFilter<"OddsAuditLog"> | string
    bookmaker?: StringFilter<"OddsAuditLog"> | string
    oldOdds?: DecimalFilter<"OddsAuditLog"> | Decimal | DecimalJsLike | number | string
    newOdds?: DecimalFilter<"OddsAuditLog"> | Decimal | DecimalJsLike | number | string
    changePercent?: DecimalFilter<"OddsAuditLog"> | Decimal | DecimalJsLike | number | string
    changeType?: StringFilter<"OddsAuditLog"> | string
    createdAt?: DateTimeFilter<"OddsAuditLog"> | Date | string
  }

  export type OddsAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    externalGameId?: SortOrder
    sportKey?: SortOrder
    marketKey?: SortOrder
    selectionName?: SortOrder
    bookmaker?: SortOrder
    oldOdds?: SortOrder
    newOdds?: SortOrder
    changePercent?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
  }

  export type OddsAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OddsAuditLogWhereInput | OddsAuditLogWhereInput[]
    OR?: OddsAuditLogWhereInput[]
    NOT?: OddsAuditLogWhereInput | OddsAuditLogWhereInput[]
    externalGameId?: StringFilter<"OddsAuditLog"> | string
    sportKey?: StringFilter<"OddsAuditLog"> | string
    marketKey?: StringFilter<"OddsAuditLog"> | string
    selectionName?: StringFilter<"OddsAuditLog"> | string
    bookmaker?: StringFilter<"OddsAuditLog"> | string
    oldOdds?: DecimalFilter<"OddsAuditLog"> | Decimal | DecimalJsLike | number | string
    newOdds?: DecimalFilter<"OddsAuditLog"> | Decimal | DecimalJsLike | number | string
    changePercent?: DecimalFilter<"OddsAuditLog"> | Decimal | DecimalJsLike | number | string
    changeType?: StringFilter<"OddsAuditLog"> | string
    createdAt?: DateTimeFilter<"OddsAuditLog"> | Date | string
  }, "id">

  export type OddsAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    externalGameId?: SortOrder
    sportKey?: SortOrder
    marketKey?: SortOrder
    selectionName?: SortOrder
    bookmaker?: SortOrder
    oldOdds?: SortOrder
    newOdds?: SortOrder
    changePercent?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
    _count?: OddsAuditLogCountOrderByAggregateInput
    _avg?: OddsAuditLogAvgOrderByAggregateInput
    _max?: OddsAuditLogMaxOrderByAggregateInput
    _min?: OddsAuditLogMinOrderByAggregateInput
    _sum?: OddsAuditLogSumOrderByAggregateInput
  }

  export type OddsAuditLogScalarWhereWithAggregatesInput = {
    AND?: OddsAuditLogScalarWhereWithAggregatesInput | OddsAuditLogScalarWhereWithAggregatesInput[]
    OR?: OddsAuditLogScalarWhereWithAggregatesInput[]
    NOT?: OddsAuditLogScalarWhereWithAggregatesInput | OddsAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OddsAuditLog"> | string
    externalGameId?: StringWithAggregatesFilter<"OddsAuditLog"> | string
    sportKey?: StringWithAggregatesFilter<"OddsAuditLog"> | string
    marketKey?: StringWithAggregatesFilter<"OddsAuditLog"> | string
    selectionName?: StringWithAggregatesFilter<"OddsAuditLog"> | string
    bookmaker?: StringWithAggregatesFilter<"OddsAuditLog"> | string
    oldOdds?: DecimalWithAggregatesFilter<"OddsAuditLog"> | Decimal | DecimalJsLike | number | string
    newOdds?: DecimalWithAggregatesFilter<"OddsAuditLog"> | Decimal | DecimalJsLike | number | string
    changePercent?: DecimalWithAggregatesFilter<"OddsAuditLog"> | Decimal | DecimalJsLike | number | string
    changeType?: StringWithAggregatesFilter<"OddsAuditLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OddsAuditLog"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    priority?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    dismissed?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    actionLabel?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    dismissed?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    actionLabel?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    priority?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    dismissed?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    actionLabel?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    dismissed?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    actionLabel?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    priority?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    dismissed?: BoolWithAggregatesFilter<"Notification"> | boolean
    actionUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    actionLabel?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    password?: UserPasswordCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: GdprConsentCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventUncheckedCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: GdprConsentUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    password?: UserPasswordUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUncheckedUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    phoneNumber?: string | null
    country?: string | null
    timezone?: string | null
    language?: string | null
    marketingOptIn?: boolean
    responsibleGamingSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type UserProfileUncheckedCreateInput = {
    id?: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    phoneNumber?: string | null
    country?: string | null
    timezone?: string | null
    language?: string | null
    marketingOptIn?: boolean
    responsibleGamingSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    marketingOptIn?: BoolFieldUpdateOperationsInput | boolean
    responsibleGamingSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    marketingOptIn?: BoolFieldUpdateOperationsInput | boolean
    responsibleGamingSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileCreateManyInput = {
    id?: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    phoneNumber?: string | null
    country?: string | null
    timezone?: string | null
    language?: string | null
    marketingOptIn?: boolean
    responsibleGamingSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    marketingOptIn?: BoolFieldUpdateOperationsInput | boolean
    responsibleGamingSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    marketingOptIn?: BoolFieldUpdateOperationsInput | boolean
    responsibleGamingSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPasswordCreateInput = {
    id?: string
    passwordHash: string
    passwordHistory?: NullableJsonNullValueInput | InputJsonValue
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    passwordChangedAt?: Date | string
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordInput
  }

  export type UserPasswordUncheckedCreateInput = {
    id?: string
    userId: string
    passwordHash: string
    passwordHistory?: NullableJsonNullValueInput | InputJsonValue
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    passwordChangedAt?: Date | string
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPasswordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    passwordHistory?: NullableJsonNullValueInput | InputJsonValue
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordNestedInput
  }

  export type UserPasswordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    passwordHistory?: NullableJsonNullValueInput | InputJsonValue
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPasswordCreateManyInput = {
    id?: string
    userId: string
    passwordHash: string
    passwordHistory?: NullableJsonNullValueInput | InputJsonValue
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    passwordChangedAt?: Date | string
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPasswordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    passwordHistory?: NullableJsonNullValueInput | InputJsonValue
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPasswordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    passwordHistory?: NullableJsonNullValueInput | InputJsonValue
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorAuthCreateInput = {
    id?: string
    method: string
    secretKey?: string | null
    backupCodes?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean
    lastVerifiedAt?: Date | string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTwoFactorAuthInput
  }

  export type TwoFactorAuthUncheckedCreateInput = {
    id?: string
    userId: string
    method: string
    secretKey?: string | null
    backupCodes?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean
    lastVerifiedAt?: Date | string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorAuthUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    secretKey?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    lastVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTwoFactorAuthNestedInput
  }

  export type TwoFactorAuthUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    secretKey?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    lastVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorAuthCreateManyInput = {
    id?: string
    userId: string
    method: string
    secretKey?: string | null
    backupCodes?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean
    lastVerifiedAt?: Date | string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorAuthUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    secretKey?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    lastVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorAuthUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    secretKey?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    lastVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateInput = {
    id?: string
    token: string
    deviceFingerprint: string
    ipAddressHash: string
    userAgent?: string | null
    lastActivityAt?: Date | string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    deviceFingerprint: string
    ipAddressHash: string
    userAgent?: string | null
    lastActivityAt?: Date | string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
  }

  export type UserSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    deviceFingerprint: string
    ipAddressHash: string
    userAgent?: string | null
    lastActivityAt?: Date | string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
  }

  export type UserSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginAttemptCreateInput = {
    id?: string
    emailHash: string
    ipAddressHash: string
    success: boolean
    deviceFingerprint?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    riskScore?: number | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type LoginAttemptUncheckedCreateInput = {
    id?: string
    emailHash: string
    ipAddressHash: string
    success: boolean
    deviceFingerprint?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    riskScore?: number | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type LoginAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailHash?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailHash?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginAttemptCreateManyInput = {
    id?: string
    emailHash: string
    ipAddressHash: string
    success: boolean
    deviceFingerprint?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    riskScore?: number | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type LoginAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailHash?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailHash?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    riskScore?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SportCreateInput = {
    id?: string
    name: string
    code: string
    active?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    leagues?: LeagueCreateNestedManyWithoutSportInput
    games?: GameCreateNestedManyWithoutSportInput
  }

  export type SportUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    active?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    leagues?: LeagueUncheckedCreateNestedManyWithoutSportInput
    games?: GameUncheckedCreateNestedManyWithoutSportInput
  }

  export type SportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leagues?: LeagueUpdateManyWithoutSportNestedInput
    games?: GameUpdateManyWithoutSportNestedInput
  }

  export type SportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leagues?: LeagueUncheckedUpdateManyWithoutSportNestedInput
    games?: GameUncheckedUpdateManyWithoutSportNestedInput
  }

  export type SportCreateManyInput = {
    id?: string
    name: string
    code: string
    active?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeagueCreateInput = {
    id?: string
    name: string
    code: string
    country?: string | null
    region?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sport: SportCreateNestedOneWithoutLeaguesInput
    teams?: TeamCreateNestedManyWithoutLeagueInput
    games?: GameCreateNestedManyWithoutLeagueInput
  }

  export type LeagueUncheckedCreateInput = {
    id?: string
    sportId: string
    name: string
    code: string
    country?: string | null
    region?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutLeagueInput
    games?: GameUncheckedCreateNestedManyWithoutLeagueInput
  }

  export type LeagueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: SportUpdateOneRequiredWithoutLeaguesNestedInput
    teams?: TeamUpdateManyWithoutLeagueNestedInput
    games?: GameUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sportId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutLeagueNestedInput
    games?: GameUncheckedUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueCreateManyInput = {
    id?: string
    sportId: string
    name: string
    code: string
    country?: string | null
    region?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeagueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeagueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sportId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    code: string
    logoUrl?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutTeamsInput
    homeGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayGames?: GameCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    leagueId: string
    name: string
    code: string
    logoUrl?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    homeGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTeamsNestedInput
    homeGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayGames?: GameUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    homeGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    leagueId: string
    name: string
    code: string
    logoUrl?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCreateInput = {
    id?: string
    scheduledStartAt: Date | string
    actualStartAt?: Date | string | null
    status?: string
    homeScore?: number | null
    awayScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sport: SportCreateNestedOneWithoutGamesInput
    league: LeagueCreateNestedOneWithoutGamesInput
    homeTeam: TeamCreateNestedOneWithoutHomeGamesInput
    awayTeam: TeamCreateNestedOneWithoutAwayGamesInput
    markets?: BetMarketCreateNestedManyWithoutGameInput
    syncStatus?: OddsSyncStatusCreateNestedOneWithoutGameInput
  }

  export type GameUncheckedCreateInput = {
    id?: string
    sportId: string
    leagueId: string
    homeTeamId: string
    awayTeamId: string
    scheduledStartAt: Date | string
    actualStartAt?: Date | string | null
    status?: string
    homeScore?: number | null
    awayScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    markets?: BetMarketUncheckedCreateNestedManyWithoutGameInput
    syncStatus?: OddsSyncStatusUncheckedCreateNestedOneWithoutGameInput
  }

  export type GameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: SportUpdateOneRequiredWithoutGamesNestedInput
    league?: LeagueUpdateOneRequiredWithoutGamesNestedInput
    homeTeam?: TeamUpdateOneRequiredWithoutHomeGamesNestedInput
    awayTeam?: TeamUpdateOneRequiredWithoutAwayGamesNestedInput
    markets?: BetMarketUpdateManyWithoutGameNestedInput
    syncStatus?: OddsSyncStatusUpdateOneWithoutGameNestedInput
  }

  export type GameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sportId?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    homeTeamId?: StringFieldUpdateOperationsInput | string
    awayTeamId?: StringFieldUpdateOperationsInput | string
    scheduledStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    markets?: BetMarketUncheckedUpdateManyWithoutGameNestedInput
    syncStatus?: OddsSyncStatusUncheckedUpdateOneWithoutGameNestedInput
  }

  export type GameCreateManyInput = {
    id?: string
    sportId: string
    leagueId: string
    homeTeamId: string
    awayTeamId: string
    scheduledStartAt: Date | string
    actualStartAt?: Date | string | null
    status?: string
    homeScore?: number | null
    awayScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sportId?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    homeTeamId?: StringFieldUpdateOperationsInput | string
    awayTeamId?: StringFieldUpdateOperationsInput | string
    scheduledStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetMarketCreateInput = {
    id?: string
    marketType: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    game: GameCreateNestedOneWithoutMarketsInput
    selections?: BetSelectionCreateNestedManyWithoutMarketInput
  }

  export type BetMarketUncheckedCreateInput = {
    id?: string
    gameId: string
    marketType: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    selections?: BetSelectionUncheckedCreateNestedManyWithoutMarketInput
  }

  export type BetMarketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutMarketsNestedInput
    selections?: BetSelectionUpdateManyWithoutMarketNestedInput
  }

  export type BetMarketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    marketType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    selections?: BetSelectionUncheckedUpdateManyWithoutMarketNestedInput
  }

  export type BetMarketCreateManyInput = {
    id?: string
    gameId: string
    marketType: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetMarketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetMarketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    marketType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetSelectionCreateInput = {
    id?: string
    name: string
    odds: Decimal | DecimalJsLike | number | string
    status?: string
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    market: BetMarketCreateNestedOneWithoutSelectionsInput
    betSelections?: BetSelectionBetCreateNestedManyWithoutSelectionInput
    currentOdds?: CurrentOddsCreateNestedOneWithoutSelectionInput
    oddsSnapshots?: OddsSnapshotCreateNestedManyWithoutSelectionInput
  }

  export type BetSelectionUncheckedCreateInput = {
    id?: string
    marketId: string
    name: string
    odds: Decimal | DecimalJsLike | number | string
    status?: string
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    betSelections?: BetSelectionBetUncheckedCreateNestedManyWithoutSelectionInput
    currentOdds?: CurrentOddsUncheckedCreateNestedOneWithoutSelectionInput
    oddsSnapshots?: OddsSnapshotUncheckedCreateNestedManyWithoutSelectionInput
  }

  export type BetSelectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    market?: BetMarketUpdateOneRequiredWithoutSelectionsNestedInput
    betSelections?: BetSelectionBetUpdateManyWithoutSelectionNestedInput
    currentOdds?: CurrentOddsUpdateOneWithoutSelectionNestedInput
    oddsSnapshots?: OddsSnapshotUpdateManyWithoutSelectionNestedInput
  }

  export type BetSelectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    betSelections?: BetSelectionBetUncheckedUpdateManyWithoutSelectionNestedInput
    currentOdds?: CurrentOddsUncheckedUpdateOneWithoutSelectionNestedInput
    oddsSnapshots?: OddsSnapshotUncheckedUpdateManyWithoutSelectionNestedInput
  }

  export type BetSelectionCreateManyInput = {
    id?: string
    marketId: string
    name: string
    odds: Decimal | DecimalJsLike | number | string
    status?: string
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetSelectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetSelectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetCreateInput = {
    id?: string
    betType: string
    totalStake: Decimal | DecimalJsLike | number | string
    potentialPayout: Decimal | DecimalJsLike | number | string
    actualPayout?: Decimal | DecimalJsLike | number | string | null
    status?: string
    placedAt?: Date | string
    settledAt?: Date | string | null
    cashoutAt?: Date | string | null
    oddsSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBetsInput
    selections?: BetSelectionBetCreateNestedManyWithoutBetInput
  }

  export type BetUncheckedCreateInput = {
    id?: string
    userId: string
    betType: string
    totalStake: Decimal | DecimalJsLike | number | string
    potentialPayout: Decimal | DecimalJsLike | number | string
    actualPayout?: Decimal | DecimalJsLike | number | string | null
    status?: string
    placedAt?: Date | string
    settledAt?: Date | string | null
    cashoutAt?: Date | string | null
    oddsSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    selections?: BetSelectionBetUncheckedCreateNestedManyWithoutBetInput
  }

  export type BetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    betType?: StringFieldUpdateOperationsInput | string
    totalStake?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    potentialPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualPayout?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    placedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oddsSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBetsNestedInput
    selections?: BetSelectionBetUpdateManyWithoutBetNestedInput
  }

  export type BetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    betType?: StringFieldUpdateOperationsInput | string
    totalStake?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    potentialPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualPayout?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    placedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oddsSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    selections?: BetSelectionBetUncheckedUpdateManyWithoutBetNestedInput
  }

  export type BetCreateManyInput = {
    id?: string
    userId: string
    betType: string
    totalStake: Decimal | DecimalJsLike | number | string
    potentialPayout: Decimal | DecimalJsLike | number | string
    actualPayout?: Decimal | DecimalJsLike | number | string | null
    status?: string
    placedAt?: Date | string
    settledAt?: Date | string | null
    cashoutAt?: Date | string | null
    oddsSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    betType?: StringFieldUpdateOperationsInput | string
    totalStake?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    potentialPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualPayout?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    placedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oddsSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    betType?: StringFieldUpdateOperationsInput | string
    totalStake?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    potentialPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualPayout?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    placedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oddsSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetSelectionBetCreateInput = {
    id?: string
    oddsAtBet: Decimal | DecimalJsLike | number | string
    result?: string | null
    createdAt?: Date | string
    bet: BetCreateNestedOneWithoutSelectionsInput
    selection: BetSelectionCreateNestedOneWithoutBetSelectionsInput
  }

  export type BetSelectionBetUncheckedCreateInput = {
    id?: string
    betId: string
    selectionId: string
    oddsAtBet: Decimal | DecimalJsLike | number | string
    result?: string | null
    createdAt?: Date | string
  }

  export type BetSelectionBetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    oddsAtBet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bet?: BetUpdateOneRequiredWithoutSelectionsNestedInput
    selection?: BetSelectionUpdateOneRequiredWithoutBetSelectionsNestedInput
  }

  export type BetSelectionBetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    betId?: StringFieldUpdateOperationsInput | string
    selectionId?: StringFieldUpdateOperationsInput | string
    oddsAtBet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetSelectionBetCreateManyInput = {
    id?: string
    betId: string
    selectionId: string
    oddsAtBet: Decimal | DecimalJsLike | number | string
    result?: string | null
    createdAt?: Date | string
  }

  export type BetSelectionBetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    oddsAtBet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetSelectionBetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    betId?: StringFieldUpdateOperationsInput | string
    selectionId?: StringFieldUpdateOperationsInput | string
    oddsAtBet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialAccountCreateInput = {
    id?: string
    accountType?: string
    balance?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    lockedBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    lastTransactionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFinancialAccountsInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
  }

  export type FinancialAccountUncheckedCreateInput = {
    id?: string
    userId: string
    accountType?: string
    balance?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    lockedBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    lastTransactionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
  }

  export type FinancialAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    lastTransactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFinancialAccountsNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
  }

  export type FinancialAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    lastTransactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type FinancialAccountCreateManyInput = {
    id?: string
    userId: string
    accountType?: string
    balance?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    lockedBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    lastTransactionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    lastTransactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    lastTransactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    status?: string
    externalTransactionId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    user: UserCreateNestedOneWithoutTransactionsInput
    account: FinancialAccountCreateNestedOneWithoutTransactionsInput
    paymentMethod?: PaymentMethodCreateNestedOneWithoutTransactionsInput
    deposit?: DepositCreateNestedOneWithoutTransactionInput
    withdrawal?: WithdrawalCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    userId: string
    accountId: string
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    status?: string
    paymentMethodId?: string | null
    externalTransactionId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    deposit?: DepositUncheckedCreateNestedOneWithoutTransactionInput
    withdrawal?: WithdrawalUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    account?: FinancialAccountUpdateOneRequiredWithoutTransactionsNestedInput
    paymentMethod?: PaymentMethodUpdateOneWithoutTransactionsNestedInput
    deposit?: DepositUpdateOneWithoutTransactionNestedInput
    withdrawal?: WithdrawalUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposit?: DepositUncheckedUpdateOneWithoutTransactionNestedInput
    withdrawal?: WithdrawalUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: string
    userId: string
    accountId: string
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    status?: string
    paymentMethodId?: string | null
    externalTransactionId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentMethodCreateInput = {
    id?: string
    paymentType: string
    provider: string
    tokenizedId: string
    last4Digits?: string | null
    expiryDate?: string | null
    billingAddress?: string | null
    isDefault?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentMethodsInput
    transactions?: TransactionCreateNestedManyWithoutPaymentMethodInput
    deposits?: DepositCreateNestedManyWithoutPaymentMethodInput
    withdrawals?: WithdrawalCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUncheckedCreateInput = {
    id?: string
    userId: string
    paymentType: string
    provider: string
    tokenizedId: string
    last4Digits?: string | null
    expiryDate?: string | null
    billingAddress?: string | null
    isDefault?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutPaymentMethodInput
    deposits?: DepositUncheckedCreateNestedManyWithoutPaymentMethodInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    tokenizedId?: StringFieldUpdateOperationsInput | string
    last4Digits?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentMethodsNestedInput
    transactions?: TransactionUpdateManyWithoutPaymentMethodNestedInput
    deposits?: DepositUpdateManyWithoutPaymentMethodNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    tokenizedId?: StringFieldUpdateOperationsInput | string
    last4Digits?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutPaymentMethodNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutPaymentMethodNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodCreateManyInput = {
    id?: string
    userId: string
    paymentType: string
    provider: string
    tokenizedId: string
    last4Digits?: string | null
    expiryDate?: string | null
    billingAddress?: string | null
    isDefault?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    tokenizedId?: StringFieldUpdateOperationsInput | string
    last4Digits?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    tokenizedId?: StringFieldUpdateOperationsInput | string
    last4Digits?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    providerTransactionId?: string | null
    status?: string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutDepositInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutDepositsInput
  }

  export type DepositUncheckedCreateInput = {
    id?: string
    transactionId: string
    paymentMethodId: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    providerTransactionId?: string | null
    status?: string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepositUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutDepositNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutDepositsNestedInput
  }

  export type DepositUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositCreateManyInput = {
    id?: string
    transactionId: string
    paymentMethodId: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    providerTransactionId?: string | null
    status?: string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepositUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WithdrawalCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status?: string
    providerTransactionId?: string | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    kycVerificationRequired?: boolean
    requestedAt?: Date | string
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutWithdrawalInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutWithdrawalsInput
  }

  export type WithdrawalUncheckedCreateInput = {
    id?: string
    transactionId: string
    paymentMethodId: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status?: string
    providerTransactionId?: string | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    kycVerificationRequired?: boolean
    requestedAt?: Date | string
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WithdrawalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    kycVerificationRequired?: BoolFieldUpdateOperationsInput | boolean
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutWithdrawalNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutWithdrawalsNestedInput
  }

  export type WithdrawalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    kycVerificationRequired?: BoolFieldUpdateOperationsInput | boolean
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WithdrawalCreateManyInput = {
    id?: string
    transactionId: string
    paymentMethodId: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status?: string
    providerTransactionId?: string | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    kycVerificationRequired?: boolean
    requestedAt?: Date | string
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WithdrawalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    kycVerificationRequired?: BoolFieldUpdateOperationsInput | boolean
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WithdrawalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    kycVerificationRequired?: BoolFieldUpdateOperationsInput | boolean
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FraudEventCreateInput = {
    id?: string
    eventType: string
    severity: string
    riskScore: number
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutFraudEventsInput
  }

  export type FraudEventUncheckedCreateInput = {
    id?: string
    userId?: string | null
    eventType: string
    severity: string
    riskScore: number
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type FraudEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutFraudEventsNestedInput
  }

  export type FraudEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FraudEventCreateManyInput = {
    id?: string
    userId?: string | null
    eventType: string
    severity: string
    riskScore: number
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type FraudEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FraudEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BettingPatternCreateInput = {
    id?: string
    patternType: string
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    detectedAt?: Date | string
    riskScore: number
    actionTaken?: string | null
    user: UserCreateNestedOneWithoutBettingPatternsInput
  }

  export type BettingPatternUncheckedCreateInput = {
    id?: string
    userId: string
    patternType: string
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    detectedAt?: Date | string
    riskScore: number
    actionTaken?: string | null
  }

  export type BettingPatternUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternType?: StringFieldUpdateOperationsInput | string
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskScore?: IntFieldUpdateOperationsInput | number
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBettingPatternsNestedInput
  }

  export type BettingPatternUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    patternType?: StringFieldUpdateOperationsInput | string
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskScore?: IntFieldUpdateOperationsInput | number
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BettingPatternCreateManyInput = {
    id?: string
    userId: string
    patternType: string
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    detectedAt?: Date | string
    riskScore: number
    actionTaken?: string | null
  }

  export type BettingPatternUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternType?: StringFieldUpdateOperationsInput | string
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskScore?: IntFieldUpdateOperationsInput | number
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BettingPatternUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    patternType?: StringFieldUpdateOperationsInput | string
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskScore?: IntFieldUpdateOperationsInput | number
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountActivityLogCreateInput = {
    id?: string
    activityType: string
    ipAddressHash: string
    deviceFingerprint?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    userAgent?: string | null
    success: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutActivityLogsInput
  }

  export type AccountActivityLogUncheckedCreateInput = {
    id?: string
    userId: string
    activityType: string
    ipAddressHash: string
    deviceFingerprint?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    userAgent?: string | null
    success: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AccountActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivityLogsNestedInput
  }

  export type AccountActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountActivityLogCreateManyInput = {
    id?: string
    userId: string
    activityType: string
    ipAddressHash: string
    deviceFingerprint?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    userAgent?: string | null
    success: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AccountActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceRegistryCreateInput = {
    id?: string
    deviceFingerprint: string
    deviceName?: string | null
    deviceType?: string | null
    os?: string | null
    browser?: string | null
    trusted?: boolean
    blocked?: boolean
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
    user: UserCreateNestedOneWithoutDevicesInput
  }

  export type DeviceRegistryUncheckedCreateInput = {
    id?: string
    userId: string
    deviceFingerprint: string
    deviceName?: string | null
    deviceType?: string | null
    os?: string | null
    browser?: string | null
    trusted?: boolean
    blocked?: boolean
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
  }

  export type DeviceRegistryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    trusted?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDevicesNestedInput
  }

  export type DeviceRegistryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    trusted?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceRegistryCreateManyInput = {
    id?: string
    userId: string
    deviceFingerprint: string
    deviceName?: string | null
    deviceType?: string | null
    os?: string | null
    browser?: string | null
    trusted?: boolean
    blocked?: boolean
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
  }

  export type DeviceRegistryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    trusted?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceRegistryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    trusted?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IpAddressCreateInput = {
    id?: string
    ipAddressHash: string
    country?: string | null
    region?: string | null
    city?: string | null
    isp?: string | null
    isVpn?: boolean
    isProxy?: boolean
    riskScore?: number
    blocked?: boolean
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
  }

  export type IpAddressUncheckedCreateInput = {
    id?: string
    ipAddressHash: string
    country?: string | null
    region?: string | null
    city?: string | null
    isp?: string | null
    isVpn?: boolean
    isProxy?: boolean
    riskScore?: number
    blocked?: boolean
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
  }

  export type IpAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isp?: NullableStringFieldUpdateOperationsInput | string | null
    isVpn?: BoolFieldUpdateOperationsInput | boolean
    isProxy?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    blocked?: BoolFieldUpdateOperationsInput | boolean
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IpAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isp?: NullableStringFieldUpdateOperationsInput | string | null
    isVpn?: BoolFieldUpdateOperationsInput | boolean
    isProxy?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    blocked?: BoolFieldUpdateOperationsInput | boolean
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IpAddressCreateManyInput = {
    id?: string
    ipAddressHash: string
    country?: string | null
    region?: string | null
    city?: string | null
    isp?: string | null
    isVpn?: boolean
    isProxy?: boolean
    riskScore?: number
    blocked?: boolean
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
  }

  export type IpAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isp?: NullableStringFieldUpdateOperationsInput | string | null
    isVpn?: BoolFieldUpdateOperationsInput | boolean
    isProxy?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    blocked?: BoolFieldUpdateOperationsInput | boolean
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IpAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isp?: NullableStringFieldUpdateOperationsInput | string | null
    isVpn?: BoolFieldUpdateOperationsInput | boolean
    isProxy?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    blocked?: BoolFieldUpdateOperationsInput | boolean
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    ipAddressHash?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    userId?: string | null
    ipAddressHash?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddressHash?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    userId?: string | null
    ipAddressHash?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddressHash?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GdprConsentCreateInput = {
    id?: string
    consentType: string
    consentStatus: string
    consentMethod: string
    ipAddressHash?: string | null
    withdrawnAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutConsentsInput
  }

  export type GdprConsentUncheckedCreateInput = {
    id?: string
    userId: string
    consentType: string
    consentStatus: string
    consentMethod: string
    ipAddressHash?: string | null
    withdrawnAt?: Date | string | null
    createdAt?: Date | string
  }

  export type GdprConsentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentType?: StringFieldUpdateOperationsInput | string
    consentStatus?: StringFieldUpdateOperationsInput | string
    consentMethod?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConsentsNestedInput
  }

  export type GdprConsentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    consentType?: StringFieldUpdateOperationsInput | string
    consentStatus?: StringFieldUpdateOperationsInput | string
    consentMethod?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GdprConsentCreateManyInput = {
    id?: string
    userId: string
    consentType: string
    consentStatus: string
    consentMethod: string
    ipAddressHash?: string | null
    withdrawnAt?: Date | string | null
    createdAt?: Date | string
  }

  export type GdprConsentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentType?: StringFieldUpdateOperationsInput | string
    consentStatus?: StringFieldUpdateOperationsInput | string
    consentMethod?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GdprConsentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    consentType?: StringFieldUpdateOperationsInput | string
    consentStatus?: StringFieldUpdateOperationsInput | string
    consentMethod?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataDeletionRequestCreateInput = {
    id?: string
    status?: string
    requestedAt?: Date | string
    processedAt?: Date | string | null
    rejectionReason?: string | null
    dataDeleted?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDeletionRequestsInput
  }

  export type DataDeletionRequestUncheckedCreateInput = {
    id?: string
    userId: string
    status?: string
    requestedAt?: Date | string
    processedAt?: Date | string | null
    rejectionReason?: string | null
    dataDeleted?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataDeletionRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    dataDeleted?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDeletionRequestsNestedInput
  }

  export type DataDeletionRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    dataDeleted?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataDeletionRequestCreateManyInput = {
    id?: string
    userId: string
    status?: string
    requestedAt?: Date | string
    processedAt?: Date | string | null
    rejectionReason?: string | null
    dataDeleted?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataDeletionRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    dataDeleted?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataDeletionRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    dataDeleted?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataExportRequestCreateInput = {
    id?: string
    status?: string
    exportFormat?: string
    filePath?: string | null
    expiresAt?: Date | string | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutExportRequestsInput
  }

  export type DataExportRequestUncheckedCreateInput = {
    id?: string
    userId: string
    status?: string
    exportFormat?: string
    filePath?: string | null
    expiresAt?: Date | string | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataExportRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    exportFormat?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExportRequestsNestedInput
  }

  export type DataExportRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    exportFormat?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataExportRequestCreateManyInput = {
    id?: string
    userId: string
    status?: string
    exportFormat?: string
    filePath?: string | null
    expiresAt?: Date | string | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataExportRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    exportFormat?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataExportRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    exportFormat?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityAlertCreateInput = {
    id?: string
    alertType: string
    severity: string
    description?: string | null
    actionRequired?: string | null
    acknowledged?: boolean
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutSecurityAlertsInput
  }

  export type SecurityAlertUncheckedCreateInput = {
    id?: string
    userId?: string | null
    alertType: string
    severity: string
    description?: string | null
    actionRequired?: string | null
    acknowledged?: boolean
    createdAt?: Date | string
  }

  export type SecurityAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    actionRequired?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSecurityAlertsNestedInput
  }

  export type SecurityAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    actionRequired?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityAlertCreateManyInput = {
    id?: string
    userId?: string | null
    alertType: string
    severity: string
    description?: string | null
    actionRequired?: string | null
    acknowledged?: boolean
    createdAt?: Date | string
  }

  export type SecurityAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    actionRequired?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    actionRequired?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionCreateInput = {
    id?: string
    name: string
    description?: string | null
    promotionType: string
    termsAndConditions?: string | null
    startDate: Date | string
    endDate: Date | string
    active?: boolean
    eligibilityCriteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userBonuses?: UserBonusCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    promotionType: string
    termsAndConditions?: string | null
    startDate: Date | string
    endDate: Date | string
    active?: boolean
    eligibilityCriteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userBonuses?: UserBonusUncheckedCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    promotionType?: StringFieldUpdateOperationsInput | string
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    eligibilityCriteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userBonuses?: UserBonusUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    promotionType?: StringFieldUpdateOperationsInput | string
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    eligibilityCriteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userBonuses?: UserBonusUncheckedUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    promotionType: string
    termsAndConditions?: string | null
    startDate: Date | string
    endDate: Date | string
    active?: boolean
    eligibilityCriteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    promotionType?: StringFieldUpdateOperationsInput | string
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    eligibilityCriteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    promotionType?: StringFieldUpdateOperationsInput | string
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    eligibilityCriteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBonusCreateInput = {
    id?: string
    bonusAmount: Decimal | DecimalJsLike | number | string
    wageringRequirement: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBonusesInput
    promotion: PromotionCreateNestedOneWithoutUserBonusesInput
  }

  export type UserBonusUncheckedCreateInput = {
    id?: string
    userId: string
    promotionId: string
    bonusAmount: Decimal | DecimalJsLike | number | string
    wageringRequirement: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBonusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageringRequirement?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBonusesNestedInput
    promotion?: PromotionUpdateOneRequiredWithoutUserBonusesNestedInput
  }

  export type UserBonusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    bonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageringRequirement?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBonusCreateManyInput = {
    id?: string
    userId: string
    promotionId: string
    bonusAmount: Decimal | DecimalJsLike | number | string
    wageringRequirement: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBonusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageringRequirement?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBonusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    bonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageringRequirement?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrentOddsCreateInput = {
    id?: string
    currentOdds: Decimal | DecimalJsLike | number | string
    previousOdds?: Decimal | DecimalJsLike | number | string | null
    oddsMovement?: string | null
    lastUpdatedAt?: Date | string
    syncedAt?: Date | string
    externalOddsId?: string | null
    suspended?: boolean
    selection: BetSelectionCreateNestedOneWithoutCurrentOddsInput
  }

  export type CurrentOddsUncheckedCreateInput = {
    id?: string
    selectionId: string
    currentOdds: Decimal | DecimalJsLike | number | string
    previousOdds?: Decimal | DecimalJsLike | number | string | null
    oddsMovement?: string | null
    lastUpdatedAt?: Date | string
    syncedAt?: Date | string
    externalOddsId?: string | null
    suspended?: boolean
  }

  export type CurrentOddsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    previousOdds?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    oddsMovement?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalOddsId?: NullableStringFieldUpdateOperationsInput | string | null
    suspended?: BoolFieldUpdateOperationsInput | boolean
    selection?: BetSelectionUpdateOneRequiredWithoutCurrentOddsNestedInput
  }

  export type CurrentOddsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    selectionId?: StringFieldUpdateOperationsInput | string
    currentOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    previousOdds?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    oddsMovement?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalOddsId?: NullableStringFieldUpdateOperationsInput | string | null
    suspended?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CurrentOddsCreateManyInput = {
    id?: string
    selectionId: string
    currentOdds: Decimal | DecimalJsLike | number | string
    previousOdds?: Decimal | DecimalJsLike | number | string | null
    oddsMovement?: string | null
    lastUpdatedAt?: Date | string
    syncedAt?: Date | string
    externalOddsId?: string | null
    suspended?: boolean
  }

  export type CurrentOddsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    previousOdds?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    oddsMovement?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalOddsId?: NullableStringFieldUpdateOperationsInput | string | null
    suspended?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CurrentOddsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    selectionId?: StringFieldUpdateOperationsInput | string
    currentOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    previousOdds?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    oddsMovement?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalOddsId?: NullableStringFieldUpdateOperationsInput | string | null
    suspended?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OddsSnapshotCreateInput = {
    id?: string
    odds: Decimal | DecimalJsLike | number | string
    timestamp?: Date | string
    source?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    selection: BetSelectionCreateNestedOneWithoutOddsSnapshotsInput
  }

  export type OddsSnapshotUncheckedCreateInput = {
    id?: string
    selectionId: string
    odds: Decimal | DecimalJsLike | number | string
    timestamp?: Date | string
    source?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OddsSnapshotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    selection?: BetSelectionUpdateOneRequiredWithoutOddsSnapshotsNestedInput
  }

  export type OddsSnapshotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    selectionId?: StringFieldUpdateOperationsInput | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OddsSnapshotCreateManyInput = {
    id?: string
    selectionId: string
    odds: Decimal | DecimalJsLike | number | string
    timestamp?: Date | string
    source?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OddsSnapshotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OddsSnapshotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    selectionId?: StringFieldUpdateOperationsInput | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OddsSyncStatusCreateInput = {
    id?: string
    lastSyncAt?: Date | string
    nextSyncAt?: Date | string | null
    syncStatus?: string
    failureCount?: number
    lastError?: string | null
    syncInterval?: number
    game: GameCreateNestedOneWithoutSyncStatusInput
  }

  export type OddsSyncStatusUncheckedCreateInput = {
    id?: string
    gameId: string
    lastSyncAt?: Date | string
    nextSyncAt?: Date | string | null
    syncStatus?: string
    failureCount?: number
    lastError?: string | null
    syncInterval?: number
  }

  export type OddsSyncStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    failureCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    syncInterval?: IntFieldUpdateOperationsInput | number
    game?: GameUpdateOneRequiredWithoutSyncStatusNestedInput
  }

  export type OddsSyncStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    failureCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    syncInterval?: IntFieldUpdateOperationsInput | number
  }

  export type OddsSyncStatusCreateManyInput = {
    id?: string
    gameId: string
    lastSyncAt?: Date | string
    nextSyncAt?: Date | string | null
    syncStatus?: string
    failureCount?: number
    lastError?: string | null
    syncInterval?: number
  }

  export type OddsSyncStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    failureCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    syncInterval?: IntFieldUpdateOperationsInput | number
  }

  export type OddsSyncStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    failureCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    syncInterval?: IntFieldUpdateOperationsInput | number
  }

  export type OddsChangeEventCreateInput = {
    id?: string
    selectionId: string
    gameId: string
    oldOdds: Decimal | DecimalJsLike | number | string
    newOdds: Decimal | DecimalJsLike | number | string
    changePercentage: Decimal | DecimalJsLike | number | string
    changeType: string
    broadcasted?: boolean
    createdAt?: Date | string
  }

  export type OddsChangeEventUncheckedCreateInput = {
    id?: string
    selectionId: string
    gameId: string
    oldOdds: Decimal | DecimalJsLike | number | string
    newOdds: Decimal | DecimalJsLike | number | string
    changePercentage: Decimal | DecimalJsLike | number | string
    changeType: string
    broadcasted?: boolean
    createdAt?: Date | string
  }

  export type OddsChangeEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    selectionId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    oldOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changePercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeType?: StringFieldUpdateOperationsInput | string
    broadcasted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OddsChangeEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    selectionId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    oldOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changePercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeType?: StringFieldUpdateOperationsInput | string
    broadcasted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OddsChangeEventCreateManyInput = {
    id?: string
    selectionId: string
    gameId: string
    oldOdds: Decimal | DecimalJsLike | number | string
    newOdds: Decimal | DecimalJsLike | number | string
    changePercentage: Decimal | DecimalJsLike | number | string
    changeType: string
    broadcasted?: boolean
    createdAt?: Date | string
  }

  export type OddsChangeEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    selectionId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    oldOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changePercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeType?: StringFieldUpdateOperationsInput | string
    broadcasted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OddsChangeEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    selectionId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    oldOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changePercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeType?: StringFieldUpdateOperationsInput | string
    broadcasted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiOddsSnapshotCreateInput = {
    id?: string
    externalGameId: string
    sportKey: string
    homeTeam: string
    awayTeam: string
    commenceTime: Date | string
    bookmaker: string
    rawData: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type ApiOddsSnapshotUncheckedCreateInput = {
    id?: string
    externalGameId: string
    sportKey: string
    homeTeam: string
    awayTeam: string
    commenceTime: Date | string
    bookmaker: string
    rawData: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type ApiOddsSnapshotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalGameId?: StringFieldUpdateOperationsInput | string
    sportKey?: StringFieldUpdateOperationsInput | string
    homeTeam?: StringFieldUpdateOperationsInput | string
    awayTeam?: StringFieldUpdateOperationsInput | string
    commenceTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmaker?: StringFieldUpdateOperationsInput | string
    rawData?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiOddsSnapshotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalGameId?: StringFieldUpdateOperationsInput | string
    sportKey?: StringFieldUpdateOperationsInput | string
    homeTeam?: StringFieldUpdateOperationsInput | string
    awayTeam?: StringFieldUpdateOperationsInput | string
    commenceTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmaker?: StringFieldUpdateOperationsInput | string
    rawData?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiOddsSnapshotCreateManyInput = {
    id?: string
    externalGameId: string
    sportKey: string
    homeTeam: string
    awayTeam: string
    commenceTime: Date | string
    bookmaker: string
    rawData: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type ApiOddsSnapshotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalGameId?: StringFieldUpdateOperationsInput | string
    sportKey?: StringFieldUpdateOperationsInput | string
    homeTeam?: StringFieldUpdateOperationsInput | string
    awayTeam?: StringFieldUpdateOperationsInput | string
    commenceTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmaker?: StringFieldUpdateOperationsInput | string
    rawData?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiOddsSnapshotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalGameId?: StringFieldUpdateOperationsInput | string
    sportKey?: StringFieldUpdateOperationsInput | string
    homeTeam?: StringFieldUpdateOperationsInput | string
    awayTeam?: StringFieldUpdateOperationsInput | string
    commenceTime?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmaker?: StringFieldUpdateOperationsInput | string
    rawData?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OddsAuditLogCreateInput = {
    id?: string
    externalGameId: string
    sportKey: string
    marketKey: string
    selectionName: string
    bookmaker: string
    oldOdds: Decimal | DecimalJsLike | number | string
    newOdds: Decimal | DecimalJsLike | number | string
    changePercent: Decimal | DecimalJsLike | number | string
    changeType: string
    createdAt?: Date | string
  }

  export type OddsAuditLogUncheckedCreateInput = {
    id?: string
    externalGameId: string
    sportKey: string
    marketKey: string
    selectionName: string
    bookmaker: string
    oldOdds: Decimal | DecimalJsLike | number | string
    newOdds: Decimal | DecimalJsLike | number | string
    changePercent: Decimal | DecimalJsLike | number | string
    changeType: string
    createdAt?: Date | string
  }

  export type OddsAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalGameId?: StringFieldUpdateOperationsInput | string
    sportKey?: StringFieldUpdateOperationsInput | string
    marketKey?: StringFieldUpdateOperationsInput | string
    selectionName?: StringFieldUpdateOperationsInput | string
    bookmaker?: StringFieldUpdateOperationsInput | string
    oldOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changePercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OddsAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalGameId?: StringFieldUpdateOperationsInput | string
    sportKey?: StringFieldUpdateOperationsInput | string
    marketKey?: StringFieldUpdateOperationsInput | string
    selectionName?: StringFieldUpdateOperationsInput | string
    bookmaker?: StringFieldUpdateOperationsInput | string
    oldOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changePercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OddsAuditLogCreateManyInput = {
    id?: string
    externalGameId: string
    sportKey: string
    marketKey: string
    selectionName: string
    bookmaker: string
    oldOdds: Decimal | DecimalJsLike | number | string
    newOdds: Decimal | DecimalJsLike | number | string
    changePercent: Decimal | DecimalJsLike | number | string
    changeType: string
    createdAt?: Date | string
  }

  export type OddsAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalGameId?: StringFieldUpdateOperationsInput | string
    sportKey?: StringFieldUpdateOperationsInput | string
    marketKey?: StringFieldUpdateOperationsInput | string
    selectionName?: StringFieldUpdateOperationsInput | string
    bookmaker?: StringFieldUpdateOperationsInput | string
    oldOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changePercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OddsAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalGameId?: StringFieldUpdateOperationsInput | string
    sportKey?: StringFieldUpdateOperationsInput | string
    marketKey?: StringFieldUpdateOperationsInput | string
    selectionName?: StringFieldUpdateOperationsInput | string
    bookmaker?: StringFieldUpdateOperationsInput | string
    oldOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changePercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    priority?: string
    title: string
    message: string
    read?: boolean
    dismissed?: boolean
    actionUrl?: string | null
    actionLabel?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    priority?: string
    title: string
    message: string
    read?: boolean
    dismissed?: boolean
    actionUrl?: string | null
    actionLabel?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    dismissed?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    dismissed?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    priority?: string
    title: string
    message: string
    read?: boolean
    dismissed?: boolean
    actionUrl?: string | null
    actionLabel?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    dismissed?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    dismissed?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type UserProfileNullableScalarRelationFilter = {
    is?: UserProfileWhereInput | null
    isNot?: UserProfileWhereInput | null
  }

  export type UserPasswordNullableScalarRelationFilter = {
    is?: UserPasswordWhereInput | null
    isNot?: UserPasswordWhereInput | null
  }

  export type TwoFactorAuthNullableScalarRelationFilter = {
    is?: TwoFactorAuthWhereInput | null
    isNot?: TwoFactorAuthWhereInput | null
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type FinancialAccountListRelationFilter = {
    every?: FinancialAccountWhereInput
    some?: FinancialAccountWhereInput
    none?: FinancialAccountWhereInput
  }

  export type BetListRelationFilter = {
    every?: BetWhereInput
    some?: BetWhereInput
    none?: BetWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type PaymentMethodListRelationFilter = {
    every?: PaymentMethodWhereInput
    some?: PaymentMethodWhereInput
    none?: PaymentMethodWhereInput
  }

  export type FraudEventListRelationFilter = {
    every?: FraudEventWhereInput
    some?: FraudEventWhereInput
    none?: FraudEventWhereInput
  }

  export type BettingPatternListRelationFilter = {
    every?: BettingPatternWhereInput
    some?: BettingPatternWhereInput
    none?: BettingPatternWhereInput
  }

  export type AccountActivityLogListRelationFilter = {
    every?: AccountActivityLogWhereInput
    some?: AccountActivityLogWhereInput
    none?: AccountActivityLogWhereInput
  }

  export type DeviceRegistryListRelationFilter = {
    every?: DeviceRegistryWhereInput
    some?: DeviceRegistryWhereInput
    none?: DeviceRegistryWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type GdprConsentListRelationFilter = {
    every?: GdprConsentWhereInput
    some?: GdprConsentWhereInput
    none?: GdprConsentWhereInput
  }

  export type DataDeletionRequestListRelationFilter = {
    every?: DataDeletionRequestWhereInput
    some?: DataDeletionRequestWhereInput
    none?: DataDeletionRequestWhereInput
  }

  export type DataExportRequestListRelationFilter = {
    every?: DataExportRequestWhereInput
    some?: DataExportRequestWhereInput
    none?: DataExportRequestWhereInput
  }

  export type SecurityAlertListRelationFilter = {
    every?: SecurityAlertWhereInput
    some?: SecurityAlertWhereInput
    none?: SecurityAlertWhereInput
  }

  export type UserBonusListRelationFilter = {
    every?: UserBonusWhereInput
    some?: UserBonusWhereInput
    none?: UserBonusWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinancialAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentMethodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FraudEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BettingPatternOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceRegistryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GdprConsentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DataDeletionRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DataExportRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SecurityAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBonusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    accountStatus?: SortOrder
    kycVerified?: SortOrder
    kycLevel?: SortOrder
    gdprConsentGiven?: SortOrder
    marketingConsent?: SortOrder
    riskScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    accountStatus?: SortOrder
    kycVerified?: SortOrder
    kycLevel?: SortOrder
    gdprConsentGiven?: SortOrder
    marketingConsent?: SortOrder
    riskScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    accountStatus?: SortOrder
    kycVerified?: SortOrder
    kycLevel?: SortOrder
    gdprConsentGiven?: SortOrder
    marketingConsent?: SortOrder
    riskScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    country?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    marketingOptIn?: SortOrder
    responsibleGamingSettings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    country?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    marketingOptIn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    country?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    marketingOptIn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type UserPasswordCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    passwordHash?: SortOrder
    passwordHistory?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiresAt?: SortOrder
    passwordChangedAt?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPasswordAvgOrderByAggregateInput = {
    failedLoginAttempts?: SortOrder
  }

  export type UserPasswordMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    passwordHash?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiresAt?: SortOrder
    passwordChangedAt?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPasswordMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    passwordHash?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiresAt?: SortOrder
    passwordChangedAt?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPasswordSumOrderByAggregateInput = {
    failedLoginAttempts?: SortOrder
  }

  export type TwoFactorAuthCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    secretKey?: SortOrder
    backupCodes?: SortOrder
    enabled?: SortOrder
    lastVerifiedAt?: SortOrder
    recoveryEmail?: SortOrder
    recoveryPhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwoFactorAuthMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    secretKey?: SortOrder
    enabled?: SortOrder
    lastVerifiedAt?: SortOrder
    recoveryEmail?: SortOrder
    recoveryPhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwoFactorAuthMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    secretKey?: SortOrder
    enabled?: SortOrder
    lastVerifiedAt?: SortOrder
    recoveryEmail?: SortOrder
    recoveryPhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceFingerprint?: SortOrder
    ipAddressHash?: SortOrder
    userAgent?: SortOrder
    lastActivityAt?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceFingerprint?: SortOrder
    ipAddressHash?: SortOrder
    userAgent?: SortOrder
    lastActivityAt?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceFingerprint?: SortOrder
    ipAddressHash?: SortOrder
    userAgent?: SortOrder
    lastActivityAt?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
  }

  export type LoginAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    emailHash?: SortOrder
    ipAddressHash?: SortOrder
    success?: SortOrder
    deviceFingerprint?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    riskScore?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type LoginAttemptAvgOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type LoginAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    emailHash?: SortOrder
    ipAddressHash?: SortOrder
    success?: SortOrder
    deviceFingerprint?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    riskScore?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type LoginAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    emailHash?: SortOrder
    ipAddressHash?: SortOrder
    success?: SortOrder
    deviceFingerprint?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    riskScore?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type LoginAttemptSumOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type LeagueListRelationFilter = {
    every?: LeagueWhereInput
    some?: LeagueWhereInput
    none?: LeagueWhereInput
  }

  export type GameListRelationFilter = {
    every?: GameWhereInput
    some?: GameWhereInput
    none?: GameWhereInput
  }

  export type LeagueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SportCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    active?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SportAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type SportMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    active?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SportMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    active?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SportSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type SportScalarRelationFilter = {
    is?: SportWhereInput
    isNot?: SportWhereInput
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeagueSportIdCodeCompoundUniqueInput = {
    sportId: string
    code: string
  }

  export type LeagueCountOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    country?: SortOrder
    region?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeagueMaxOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    country?: SortOrder
    region?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeagueMinOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    country?: SortOrder
    region?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeagueScalarRelationFilter = {
    is?: LeagueWhereInput
    isNot?: LeagueWhereInput
  }

  export type TeamLeagueIdCodeCompoundUniqueInput = {
    leagueId: string
    code: string
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    logoUrl?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    logoUrl?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    logoUrl?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type BetMarketListRelationFilter = {
    every?: BetMarketWhereInput
    some?: BetMarketWhereInput
    none?: BetMarketWhereInput
  }

  export type OddsSyncStatusNullableScalarRelationFilter = {
    is?: OddsSyncStatusWhereInput | null
    isNot?: OddsSyncStatusWhereInput | null
  }

  export type BetMarketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameCountOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    leagueId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    scheduledStartAt?: SortOrder
    actualStartAt?: SortOrder
    status?: SortOrder
    homeScore?: SortOrder
    awayScore?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameAvgOrderByAggregateInput = {
    homeScore?: SortOrder
    awayScore?: SortOrder
  }

  export type GameMaxOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    leagueId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    scheduledStartAt?: SortOrder
    actualStartAt?: SortOrder
    status?: SortOrder
    homeScore?: SortOrder
    awayScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameMinOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    leagueId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    scheduledStartAt?: SortOrder
    actualStartAt?: SortOrder
    status?: SortOrder
    homeScore?: SortOrder
    awayScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameSumOrderByAggregateInput = {
    homeScore?: SortOrder
    awayScore?: SortOrder
  }

  export type GameScalarRelationFilter = {
    is?: GameWhereInput
    isNot?: GameWhereInput
  }

  export type BetSelectionListRelationFilter = {
    every?: BetSelectionWhereInput
    some?: BetSelectionWhereInput
    none?: BetSelectionWhereInput
  }

  export type BetSelectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BetMarketCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    marketType?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BetMarketMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    marketType?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BetMarketMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    marketType?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BetMarketScalarRelationFilter = {
    is?: BetMarketWhereInput
    isNot?: BetMarketWhereInput
  }

  export type BetSelectionBetListRelationFilter = {
    every?: BetSelectionBetWhereInput
    some?: BetSelectionBetWhereInput
    none?: BetSelectionBetWhereInput
  }

  export type CurrentOddsNullableScalarRelationFilter = {
    is?: CurrentOddsWhereInput | null
    isNot?: CurrentOddsWhereInput | null
  }

  export type OddsSnapshotListRelationFilter = {
    every?: OddsSnapshotWhereInput
    some?: OddsSnapshotWhereInput
    none?: OddsSnapshotWhereInput
  }

  export type BetSelectionBetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OddsSnapshotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BetSelectionCountOrderByAggregateInput = {
    id?: SortOrder
    marketId?: SortOrder
    name?: SortOrder
    odds?: SortOrder
    status?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BetSelectionAvgOrderByAggregateInput = {
    odds?: SortOrder
  }

  export type BetSelectionMaxOrderByAggregateInput = {
    id?: SortOrder
    marketId?: SortOrder
    name?: SortOrder
    odds?: SortOrder
    status?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BetSelectionMinOrderByAggregateInput = {
    id?: SortOrder
    marketId?: SortOrder
    name?: SortOrder
    odds?: SortOrder
    status?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BetSelectionSumOrderByAggregateInput = {
    odds?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BetCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    betType?: SortOrder
    totalStake?: SortOrder
    potentialPayout?: SortOrder
    actualPayout?: SortOrder
    status?: SortOrder
    placedAt?: SortOrder
    settledAt?: SortOrder
    cashoutAt?: SortOrder
    oddsSnapshot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BetAvgOrderByAggregateInput = {
    totalStake?: SortOrder
    potentialPayout?: SortOrder
    actualPayout?: SortOrder
  }

  export type BetMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    betType?: SortOrder
    totalStake?: SortOrder
    potentialPayout?: SortOrder
    actualPayout?: SortOrder
    status?: SortOrder
    placedAt?: SortOrder
    settledAt?: SortOrder
    cashoutAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BetMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    betType?: SortOrder
    totalStake?: SortOrder
    potentialPayout?: SortOrder
    actualPayout?: SortOrder
    status?: SortOrder
    placedAt?: SortOrder
    settledAt?: SortOrder
    cashoutAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BetSumOrderByAggregateInput = {
    totalStake?: SortOrder
    potentialPayout?: SortOrder
    actualPayout?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BetScalarRelationFilter = {
    is?: BetWhereInput
    isNot?: BetWhereInput
  }

  export type BetSelectionScalarRelationFilter = {
    is?: BetSelectionWhereInput
    isNot?: BetSelectionWhereInput
  }

  export type BetSelectionBetBetIdSelectionIdCompoundUniqueInput = {
    betId: string
    selectionId: string
  }

  export type BetSelectionBetCountOrderByAggregateInput = {
    id?: SortOrder
    betId?: SortOrder
    selectionId?: SortOrder
    oddsAtBet?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
  }

  export type BetSelectionBetAvgOrderByAggregateInput = {
    oddsAtBet?: SortOrder
  }

  export type BetSelectionBetMaxOrderByAggregateInput = {
    id?: SortOrder
    betId?: SortOrder
    selectionId?: SortOrder
    oddsAtBet?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
  }

  export type BetSelectionBetMinOrderByAggregateInput = {
    id?: SortOrder
    betId?: SortOrder
    selectionId?: SortOrder
    oddsAtBet?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
  }

  export type BetSelectionBetSumOrderByAggregateInput = {
    oddsAtBet?: SortOrder
  }

  export type FinancialAccountUserIdAccountTypeCompoundUniqueInput = {
    userId: string
    accountType: string
  }

  export type FinancialAccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    balance?: SortOrder
    availableBalance?: SortOrder
    lockedBalance?: SortOrder
    currency?: SortOrder
    lastTransactionAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancialAccountAvgOrderByAggregateInput = {
    balance?: SortOrder
    availableBalance?: SortOrder
    lockedBalance?: SortOrder
  }

  export type FinancialAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    balance?: SortOrder
    availableBalance?: SortOrder
    lockedBalance?: SortOrder
    currency?: SortOrder
    lastTransactionAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancialAccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    balance?: SortOrder
    availableBalance?: SortOrder
    lockedBalance?: SortOrder
    currency?: SortOrder
    lastTransactionAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancialAccountSumOrderByAggregateInput = {
    balance?: SortOrder
    availableBalance?: SortOrder
    lockedBalance?: SortOrder
  }

  export type FinancialAccountScalarRelationFilter = {
    is?: FinancialAccountWhereInput
    isNot?: FinancialAccountWhereInput
  }

  export type PaymentMethodNullableScalarRelationFilter = {
    is?: PaymentMethodWhereInput | null
    isNot?: PaymentMethodWhereInput | null
  }

  export type DepositNullableScalarRelationFilter = {
    is?: DepositWhereInput | null
    isNot?: DepositWhereInput | null
  }

  export type WithdrawalNullableScalarRelationFilter = {
    is?: WithdrawalWhereInput | null
    isNot?: WithdrawalWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    status?: SortOrder
    paymentMethodId?: SortOrder
    externalTransactionId?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    status?: SortOrder
    paymentMethodId?: SortOrder
    externalTransactionId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    status?: SortOrder
    paymentMethodId?: SortOrder
    externalTransactionId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
  }

  export type DepositListRelationFilter = {
    every?: DepositWhereInput
    some?: DepositWhereInput
    none?: DepositWhereInput
  }

  export type WithdrawalListRelationFilter = {
    every?: WithdrawalWhereInput
    some?: WithdrawalWhereInput
    none?: WithdrawalWhereInput
  }

  export type DepositOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WithdrawalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentType?: SortOrder
    provider?: SortOrder
    tokenizedId?: SortOrder
    last4Digits?: SortOrder
    expiryDate?: SortOrder
    billingAddress?: SortOrder
    isDefault?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentType?: SortOrder
    provider?: SortOrder
    tokenizedId?: SortOrder
    last4Digits?: SortOrder
    expiryDate?: SortOrder
    billingAddress?: SortOrder
    isDefault?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentType?: SortOrder
    provider?: SortOrder
    tokenizedId?: SortOrder
    last4Digits?: SortOrder
    expiryDate?: SortOrder
    billingAddress?: SortOrder
    isDefault?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionScalarRelationFilter = {
    is?: TransactionWhereInput
    isNot?: TransactionWhereInput
  }

  export type PaymentMethodScalarRelationFilter = {
    is?: PaymentMethodWhereInput
    isNot?: PaymentMethodWhereInput
  }

  export type DepositCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
    providerTransactionId?: SortOrder
    status?: SortOrder
    providerResponse?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepositAvgOrderByAggregateInput = {
    amount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
  }

  export type DepositMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
    providerTransactionId?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepositMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
    providerTransactionId?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepositSumOrderByAggregateInput = {
    amount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
  }

  export type WithdrawalCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    providerTransactionId?: SortOrder
    providerResponse?: SortOrder
    kycVerificationRequired?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WithdrawalAvgOrderByAggregateInput = {
    amount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
  }

  export type WithdrawalMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    providerTransactionId?: SortOrder
    kycVerificationRequired?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WithdrawalMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    paymentMethodId?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    providerTransactionId?: SortOrder
    kycVerificationRequired?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WithdrawalSumOrderByAggregateInput = {
    amount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type FraudEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    riskScore?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type FraudEventAvgOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type FraudEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    riskScore?: SortOrder
    description?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type FraudEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    riskScore?: SortOrder
    description?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type FraudEventSumOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type BettingPatternCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    patternType?: SortOrder
    patternDetails?: SortOrder
    detectedAt?: SortOrder
    riskScore?: SortOrder
    actionTaken?: SortOrder
  }

  export type BettingPatternAvgOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type BettingPatternMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    patternType?: SortOrder
    detectedAt?: SortOrder
    riskScore?: SortOrder
    actionTaken?: SortOrder
  }

  export type BettingPatternMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    patternType?: SortOrder
    detectedAt?: SortOrder
    riskScore?: SortOrder
    actionTaken?: SortOrder
  }

  export type BettingPatternSumOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type AccountActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activityType?: SortOrder
    ipAddressHash?: SortOrder
    deviceFingerprint?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activityType?: SortOrder
    ipAddressHash?: SortOrder
    deviceFingerprint?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activityType?: SortOrder
    ipAddressHash?: SortOrder
    deviceFingerprint?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    createdAt?: SortOrder
  }

  export type DeviceRegistryUserIdDeviceFingerprintCompoundUniqueInput = {
    userId: string
    deviceFingerprint: string
  }

  export type DeviceRegistryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceFingerprint?: SortOrder
    deviceName?: SortOrder
    deviceType?: SortOrder
    os?: SortOrder
    browser?: SortOrder
    trusted?: SortOrder
    blocked?: SortOrder
    firstSeenAt?: SortOrder
    lastSeenAt?: SortOrder
  }

  export type DeviceRegistryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceFingerprint?: SortOrder
    deviceName?: SortOrder
    deviceType?: SortOrder
    os?: SortOrder
    browser?: SortOrder
    trusted?: SortOrder
    blocked?: SortOrder
    firstSeenAt?: SortOrder
    lastSeenAt?: SortOrder
  }

  export type DeviceRegistryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceFingerprint?: SortOrder
    deviceName?: SortOrder
    deviceType?: SortOrder
    os?: SortOrder
    browser?: SortOrder
    trusted?: SortOrder
    blocked?: SortOrder
    firstSeenAt?: SortOrder
    lastSeenAt?: SortOrder
  }

  export type IpAddressCountOrderByAggregateInput = {
    id?: SortOrder
    ipAddressHash?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    isp?: SortOrder
    isVpn?: SortOrder
    isProxy?: SortOrder
    riskScore?: SortOrder
    blocked?: SortOrder
    firstSeenAt?: SortOrder
    lastSeenAt?: SortOrder
  }

  export type IpAddressAvgOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type IpAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    ipAddressHash?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    isp?: SortOrder
    isVpn?: SortOrder
    isProxy?: SortOrder
    riskScore?: SortOrder
    blocked?: SortOrder
    firstSeenAt?: SortOrder
    lastSeenAt?: SortOrder
  }

  export type IpAddressMinOrderByAggregateInput = {
    id?: SortOrder
    ipAddressHash?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    isp?: SortOrder
    isVpn?: SortOrder
    isProxy?: SortOrder
    riskScore?: SortOrder
    blocked?: SortOrder
    firstSeenAt?: SortOrder
    lastSeenAt?: SortOrder
  }

  export type IpAddressSumOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    ipAddressHash?: SortOrder
    changes?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    ipAddressHash?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    ipAddressHash?: SortOrder
    createdAt?: SortOrder
  }

  export type GdprConsentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    consentType?: SortOrder
    consentStatus?: SortOrder
    consentMethod?: SortOrder
    ipAddressHash?: SortOrder
    withdrawnAt?: SortOrder
    createdAt?: SortOrder
  }

  export type GdprConsentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    consentType?: SortOrder
    consentStatus?: SortOrder
    consentMethod?: SortOrder
    ipAddressHash?: SortOrder
    withdrawnAt?: SortOrder
    createdAt?: SortOrder
  }

  export type GdprConsentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    consentType?: SortOrder
    consentStatus?: SortOrder
    consentMethod?: SortOrder
    ipAddressHash?: SortOrder
    withdrawnAt?: SortOrder
    createdAt?: SortOrder
  }

  export type DataDeletionRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrder
    rejectionReason?: SortOrder
    dataDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataDeletionRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataDeletionRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataExportRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    exportFormat?: SortOrder
    filePath?: SortOrder
    expiresAt?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataExportRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    exportFormat?: SortOrder
    filePath?: SortOrder
    expiresAt?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataExportRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    exportFormat?: SortOrder
    filePath?: SortOrder
    expiresAt?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityAlertCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    description?: SortOrder
    actionRequired?: SortOrder
    acknowledged?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    description?: SortOrder
    actionRequired?: SortOrder
    acknowledged?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityAlertMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    description?: SortOrder
    actionRequired?: SortOrder
    acknowledged?: SortOrder
    createdAt?: SortOrder
  }

  export type PromotionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    promotionType?: SortOrder
    termsAndConditions?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    active?: SortOrder
    eligibilityCriteria?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    promotionType?: SortOrder
    termsAndConditions?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    promotionType?: SortOrder
    termsAndConditions?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionScalarRelationFilter = {
    is?: PromotionWhereInput
    isNot?: PromotionWhereInput
  }

  export type UserBonusCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    promotionId?: SortOrder
    bonusAmount?: SortOrder
    wageringRequirement?: SortOrder
    wageredAmount?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBonusAvgOrderByAggregateInput = {
    bonusAmount?: SortOrder
    wageringRequirement?: SortOrder
    wageredAmount?: SortOrder
  }

  export type UserBonusMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    promotionId?: SortOrder
    bonusAmount?: SortOrder
    wageringRequirement?: SortOrder
    wageredAmount?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBonusMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    promotionId?: SortOrder
    bonusAmount?: SortOrder
    wageringRequirement?: SortOrder
    wageredAmount?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBonusSumOrderByAggregateInput = {
    bonusAmount?: SortOrder
    wageringRequirement?: SortOrder
    wageredAmount?: SortOrder
  }

  export type CurrentOddsCountOrderByAggregateInput = {
    id?: SortOrder
    selectionId?: SortOrder
    currentOdds?: SortOrder
    previousOdds?: SortOrder
    oddsMovement?: SortOrder
    lastUpdatedAt?: SortOrder
    syncedAt?: SortOrder
    externalOddsId?: SortOrder
    suspended?: SortOrder
  }

  export type CurrentOddsAvgOrderByAggregateInput = {
    currentOdds?: SortOrder
    previousOdds?: SortOrder
  }

  export type CurrentOddsMaxOrderByAggregateInput = {
    id?: SortOrder
    selectionId?: SortOrder
    currentOdds?: SortOrder
    previousOdds?: SortOrder
    oddsMovement?: SortOrder
    lastUpdatedAt?: SortOrder
    syncedAt?: SortOrder
    externalOddsId?: SortOrder
    suspended?: SortOrder
  }

  export type CurrentOddsMinOrderByAggregateInput = {
    id?: SortOrder
    selectionId?: SortOrder
    currentOdds?: SortOrder
    previousOdds?: SortOrder
    oddsMovement?: SortOrder
    lastUpdatedAt?: SortOrder
    syncedAt?: SortOrder
    externalOddsId?: SortOrder
    suspended?: SortOrder
  }

  export type CurrentOddsSumOrderByAggregateInput = {
    currentOdds?: SortOrder
    previousOdds?: SortOrder
  }

  export type OddsSnapshotCountOrderByAggregateInput = {
    id?: SortOrder
    selectionId?: SortOrder
    odds?: SortOrder
    timestamp?: SortOrder
    source?: SortOrder
    metadata?: SortOrder
  }

  export type OddsSnapshotAvgOrderByAggregateInput = {
    odds?: SortOrder
  }

  export type OddsSnapshotMaxOrderByAggregateInput = {
    id?: SortOrder
    selectionId?: SortOrder
    odds?: SortOrder
    timestamp?: SortOrder
    source?: SortOrder
  }

  export type OddsSnapshotMinOrderByAggregateInput = {
    id?: SortOrder
    selectionId?: SortOrder
    odds?: SortOrder
    timestamp?: SortOrder
    source?: SortOrder
  }

  export type OddsSnapshotSumOrderByAggregateInput = {
    odds?: SortOrder
  }

  export type OddsSyncStatusCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    lastSyncAt?: SortOrder
    nextSyncAt?: SortOrder
    syncStatus?: SortOrder
    failureCount?: SortOrder
    lastError?: SortOrder
    syncInterval?: SortOrder
  }

  export type OddsSyncStatusAvgOrderByAggregateInput = {
    failureCount?: SortOrder
    syncInterval?: SortOrder
  }

  export type OddsSyncStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    lastSyncAt?: SortOrder
    nextSyncAt?: SortOrder
    syncStatus?: SortOrder
    failureCount?: SortOrder
    lastError?: SortOrder
    syncInterval?: SortOrder
  }

  export type OddsSyncStatusMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    lastSyncAt?: SortOrder
    nextSyncAt?: SortOrder
    syncStatus?: SortOrder
    failureCount?: SortOrder
    lastError?: SortOrder
    syncInterval?: SortOrder
  }

  export type OddsSyncStatusSumOrderByAggregateInput = {
    failureCount?: SortOrder
    syncInterval?: SortOrder
  }

  export type OddsChangeEventCountOrderByAggregateInput = {
    id?: SortOrder
    selectionId?: SortOrder
    gameId?: SortOrder
    oldOdds?: SortOrder
    newOdds?: SortOrder
    changePercentage?: SortOrder
    changeType?: SortOrder
    broadcasted?: SortOrder
    createdAt?: SortOrder
  }

  export type OddsChangeEventAvgOrderByAggregateInput = {
    oldOdds?: SortOrder
    newOdds?: SortOrder
    changePercentage?: SortOrder
  }

  export type OddsChangeEventMaxOrderByAggregateInput = {
    id?: SortOrder
    selectionId?: SortOrder
    gameId?: SortOrder
    oldOdds?: SortOrder
    newOdds?: SortOrder
    changePercentage?: SortOrder
    changeType?: SortOrder
    broadcasted?: SortOrder
    createdAt?: SortOrder
  }

  export type OddsChangeEventMinOrderByAggregateInput = {
    id?: SortOrder
    selectionId?: SortOrder
    gameId?: SortOrder
    oldOdds?: SortOrder
    newOdds?: SortOrder
    changePercentage?: SortOrder
    changeType?: SortOrder
    broadcasted?: SortOrder
    createdAt?: SortOrder
  }

  export type OddsChangeEventSumOrderByAggregateInput = {
    oldOdds?: SortOrder
    newOdds?: SortOrder
    changePercentage?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ApiOddsSnapshotExternalGameIdBookmakerTimestampCompoundUniqueInput = {
    externalGameId: string
    bookmaker: string
    timestamp: Date | string
  }

  export type ApiOddsSnapshotCountOrderByAggregateInput = {
    id?: SortOrder
    externalGameId?: SortOrder
    sportKey?: SortOrder
    homeTeam?: SortOrder
    awayTeam?: SortOrder
    commenceTime?: SortOrder
    bookmaker?: SortOrder
    rawData?: SortOrder
    timestamp?: SortOrder
  }

  export type ApiOddsSnapshotMaxOrderByAggregateInput = {
    id?: SortOrder
    externalGameId?: SortOrder
    sportKey?: SortOrder
    homeTeam?: SortOrder
    awayTeam?: SortOrder
    commenceTime?: SortOrder
    bookmaker?: SortOrder
    timestamp?: SortOrder
  }

  export type ApiOddsSnapshotMinOrderByAggregateInput = {
    id?: SortOrder
    externalGameId?: SortOrder
    sportKey?: SortOrder
    homeTeam?: SortOrder
    awayTeam?: SortOrder
    commenceTime?: SortOrder
    bookmaker?: SortOrder
    timestamp?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type OddsAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    externalGameId?: SortOrder
    sportKey?: SortOrder
    marketKey?: SortOrder
    selectionName?: SortOrder
    bookmaker?: SortOrder
    oldOdds?: SortOrder
    newOdds?: SortOrder
    changePercent?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
  }

  export type OddsAuditLogAvgOrderByAggregateInput = {
    oldOdds?: SortOrder
    newOdds?: SortOrder
    changePercent?: SortOrder
  }

  export type OddsAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    externalGameId?: SortOrder
    sportKey?: SortOrder
    marketKey?: SortOrder
    selectionName?: SortOrder
    bookmaker?: SortOrder
    oldOdds?: SortOrder
    newOdds?: SortOrder
    changePercent?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
  }

  export type OddsAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    externalGameId?: SortOrder
    sportKey?: SortOrder
    marketKey?: SortOrder
    selectionName?: SortOrder
    bookmaker?: SortOrder
    oldOdds?: SortOrder
    newOdds?: SortOrder
    changePercent?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
  }

  export type OddsAuditLogSumOrderByAggregateInput = {
    oldOdds?: SortOrder
    newOdds?: SortOrder
    changePercent?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    dismissed?: SortOrder
    actionUrl?: SortOrder
    actionLabel?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    dismissed?: SortOrder
    actionUrl?: SortOrder
    actionLabel?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    dismissed?: SortOrder
    actionUrl?: SortOrder
    actionLabel?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserPasswordCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPasswordCreateWithoutUserInput, UserPasswordUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPasswordCreateOrConnectWithoutUserInput
    connect?: UserPasswordWhereUniqueInput
  }

  export type TwoFactorAuthCreateNestedOneWithoutUserInput = {
    create?: XOR<TwoFactorAuthCreateWithoutUserInput, TwoFactorAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: TwoFactorAuthCreateOrConnectWithoutUserInput
    connect?: TwoFactorAuthWhereUniqueInput
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type FinancialAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<FinancialAccountCreateWithoutUserInput, FinancialAccountUncheckedCreateWithoutUserInput> | FinancialAccountCreateWithoutUserInput[] | FinancialAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FinancialAccountCreateOrConnectWithoutUserInput | FinancialAccountCreateOrConnectWithoutUserInput[]
    createMany?: FinancialAccountCreateManyUserInputEnvelope
    connect?: FinancialAccountWhereUniqueInput | FinancialAccountWhereUniqueInput[]
  }

  export type BetCreateNestedManyWithoutUserInput = {
    create?: XOR<BetCreateWithoutUserInput, BetUncheckedCreateWithoutUserInput> | BetCreateWithoutUserInput[] | BetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetCreateOrConnectWithoutUserInput | BetCreateOrConnectWithoutUserInput[]
    createMany?: BetCreateManyUserInputEnvelope
    connect?: BetWhereUniqueInput | BetWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type PaymentMethodCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentMethodCreateWithoutUserInput, PaymentMethodUncheckedCreateWithoutUserInput> | PaymentMethodCreateWithoutUserInput[] | PaymentMethodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutUserInput | PaymentMethodCreateOrConnectWithoutUserInput[]
    createMany?: PaymentMethodCreateManyUserInputEnvelope
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
  }

  export type FraudEventCreateNestedManyWithoutUserInput = {
    create?: XOR<FraudEventCreateWithoutUserInput, FraudEventUncheckedCreateWithoutUserInput> | FraudEventCreateWithoutUserInput[] | FraudEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FraudEventCreateOrConnectWithoutUserInput | FraudEventCreateOrConnectWithoutUserInput[]
    createMany?: FraudEventCreateManyUserInputEnvelope
    connect?: FraudEventWhereUniqueInput | FraudEventWhereUniqueInput[]
  }

  export type BettingPatternCreateNestedManyWithoutUserInput = {
    create?: XOR<BettingPatternCreateWithoutUserInput, BettingPatternUncheckedCreateWithoutUserInput> | BettingPatternCreateWithoutUserInput[] | BettingPatternUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BettingPatternCreateOrConnectWithoutUserInput | BettingPatternCreateOrConnectWithoutUserInput[]
    createMany?: BettingPatternCreateManyUserInputEnvelope
    connect?: BettingPatternWhereUniqueInput | BettingPatternWhereUniqueInput[]
  }

  export type AccountActivityLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountActivityLogCreateWithoutUserInput, AccountActivityLogUncheckedCreateWithoutUserInput> | AccountActivityLogCreateWithoutUserInput[] | AccountActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountActivityLogCreateOrConnectWithoutUserInput | AccountActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: AccountActivityLogCreateManyUserInputEnvelope
    connect?: AccountActivityLogWhereUniqueInput | AccountActivityLogWhereUniqueInput[]
  }

  export type DeviceRegistryCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceRegistryCreateWithoutUserInput, DeviceRegistryUncheckedCreateWithoutUserInput> | DeviceRegistryCreateWithoutUserInput[] | DeviceRegistryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceRegistryCreateOrConnectWithoutUserInput | DeviceRegistryCreateOrConnectWithoutUserInput[]
    createMany?: DeviceRegistryCreateManyUserInputEnvelope
    connect?: DeviceRegistryWhereUniqueInput | DeviceRegistryWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type GdprConsentCreateNestedManyWithoutUserInput = {
    create?: XOR<GdprConsentCreateWithoutUserInput, GdprConsentUncheckedCreateWithoutUserInput> | GdprConsentCreateWithoutUserInput[] | GdprConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GdprConsentCreateOrConnectWithoutUserInput | GdprConsentCreateOrConnectWithoutUserInput[]
    createMany?: GdprConsentCreateManyUserInputEnvelope
    connect?: GdprConsentWhereUniqueInput | GdprConsentWhereUniqueInput[]
  }

  export type DataDeletionRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<DataDeletionRequestCreateWithoutUserInput, DataDeletionRequestUncheckedCreateWithoutUserInput> | DataDeletionRequestCreateWithoutUserInput[] | DataDeletionRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataDeletionRequestCreateOrConnectWithoutUserInput | DataDeletionRequestCreateOrConnectWithoutUserInput[]
    createMany?: DataDeletionRequestCreateManyUserInputEnvelope
    connect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
  }

  export type DataExportRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<DataExportRequestCreateWithoutUserInput, DataExportRequestUncheckedCreateWithoutUserInput> | DataExportRequestCreateWithoutUserInput[] | DataExportRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataExportRequestCreateOrConnectWithoutUserInput | DataExportRequestCreateOrConnectWithoutUserInput[]
    createMany?: DataExportRequestCreateManyUserInputEnvelope
    connect?: DataExportRequestWhereUniqueInput | DataExportRequestWhereUniqueInput[]
  }

  export type SecurityAlertCreateNestedManyWithoutUserInput = {
    create?: XOR<SecurityAlertCreateWithoutUserInput, SecurityAlertUncheckedCreateWithoutUserInput> | SecurityAlertCreateWithoutUserInput[] | SecurityAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityAlertCreateOrConnectWithoutUserInput | SecurityAlertCreateOrConnectWithoutUserInput[]
    createMany?: SecurityAlertCreateManyUserInputEnvelope
    connect?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
  }

  export type UserBonusCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBonusCreateWithoutUserInput, UserBonusUncheckedCreateWithoutUserInput> | UserBonusCreateWithoutUserInput[] | UserBonusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutUserInput | UserBonusCreateOrConnectWithoutUserInput[]
    createMany?: UserBonusCreateManyUserInputEnvelope
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserPasswordUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPasswordCreateWithoutUserInput, UserPasswordUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPasswordCreateOrConnectWithoutUserInput
    connect?: UserPasswordWhereUniqueInput
  }

  export type TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TwoFactorAuthCreateWithoutUserInput, TwoFactorAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: TwoFactorAuthCreateOrConnectWithoutUserInput
    connect?: TwoFactorAuthWhereUniqueInput
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type FinancialAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FinancialAccountCreateWithoutUserInput, FinancialAccountUncheckedCreateWithoutUserInput> | FinancialAccountCreateWithoutUserInput[] | FinancialAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FinancialAccountCreateOrConnectWithoutUserInput | FinancialAccountCreateOrConnectWithoutUserInput[]
    createMany?: FinancialAccountCreateManyUserInputEnvelope
    connect?: FinancialAccountWhereUniqueInput | FinancialAccountWhereUniqueInput[]
  }

  export type BetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BetCreateWithoutUserInput, BetUncheckedCreateWithoutUserInput> | BetCreateWithoutUserInput[] | BetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetCreateOrConnectWithoutUserInput | BetCreateOrConnectWithoutUserInput[]
    createMany?: BetCreateManyUserInputEnvelope
    connect?: BetWhereUniqueInput | BetWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type PaymentMethodUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentMethodCreateWithoutUserInput, PaymentMethodUncheckedCreateWithoutUserInput> | PaymentMethodCreateWithoutUserInput[] | PaymentMethodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutUserInput | PaymentMethodCreateOrConnectWithoutUserInput[]
    createMany?: PaymentMethodCreateManyUserInputEnvelope
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
  }

  export type FraudEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FraudEventCreateWithoutUserInput, FraudEventUncheckedCreateWithoutUserInput> | FraudEventCreateWithoutUserInput[] | FraudEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FraudEventCreateOrConnectWithoutUserInput | FraudEventCreateOrConnectWithoutUserInput[]
    createMany?: FraudEventCreateManyUserInputEnvelope
    connect?: FraudEventWhereUniqueInput | FraudEventWhereUniqueInput[]
  }

  export type BettingPatternUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BettingPatternCreateWithoutUserInput, BettingPatternUncheckedCreateWithoutUserInput> | BettingPatternCreateWithoutUserInput[] | BettingPatternUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BettingPatternCreateOrConnectWithoutUserInput | BettingPatternCreateOrConnectWithoutUserInput[]
    createMany?: BettingPatternCreateManyUserInputEnvelope
    connect?: BettingPatternWhereUniqueInput | BettingPatternWhereUniqueInput[]
  }

  export type AccountActivityLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountActivityLogCreateWithoutUserInput, AccountActivityLogUncheckedCreateWithoutUserInput> | AccountActivityLogCreateWithoutUserInput[] | AccountActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountActivityLogCreateOrConnectWithoutUserInput | AccountActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: AccountActivityLogCreateManyUserInputEnvelope
    connect?: AccountActivityLogWhereUniqueInput | AccountActivityLogWhereUniqueInput[]
  }

  export type DeviceRegistryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceRegistryCreateWithoutUserInput, DeviceRegistryUncheckedCreateWithoutUserInput> | DeviceRegistryCreateWithoutUserInput[] | DeviceRegistryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceRegistryCreateOrConnectWithoutUserInput | DeviceRegistryCreateOrConnectWithoutUserInput[]
    createMany?: DeviceRegistryCreateManyUserInputEnvelope
    connect?: DeviceRegistryWhereUniqueInput | DeviceRegistryWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type GdprConsentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GdprConsentCreateWithoutUserInput, GdprConsentUncheckedCreateWithoutUserInput> | GdprConsentCreateWithoutUserInput[] | GdprConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GdprConsentCreateOrConnectWithoutUserInput | GdprConsentCreateOrConnectWithoutUserInput[]
    createMany?: GdprConsentCreateManyUserInputEnvelope
    connect?: GdprConsentWhereUniqueInput | GdprConsentWhereUniqueInput[]
  }

  export type DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DataDeletionRequestCreateWithoutUserInput, DataDeletionRequestUncheckedCreateWithoutUserInput> | DataDeletionRequestCreateWithoutUserInput[] | DataDeletionRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataDeletionRequestCreateOrConnectWithoutUserInput | DataDeletionRequestCreateOrConnectWithoutUserInput[]
    createMany?: DataDeletionRequestCreateManyUserInputEnvelope
    connect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
  }

  export type DataExportRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DataExportRequestCreateWithoutUserInput, DataExportRequestUncheckedCreateWithoutUserInput> | DataExportRequestCreateWithoutUserInput[] | DataExportRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataExportRequestCreateOrConnectWithoutUserInput | DataExportRequestCreateOrConnectWithoutUserInput[]
    createMany?: DataExportRequestCreateManyUserInputEnvelope
    connect?: DataExportRequestWhereUniqueInput | DataExportRequestWhereUniqueInput[]
  }

  export type SecurityAlertUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SecurityAlertCreateWithoutUserInput, SecurityAlertUncheckedCreateWithoutUserInput> | SecurityAlertCreateWithoutUserInput[] | SecurityAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityAlertCreateOrConnectWithoutUserInput | SecurityAlertCreateOrConnectWithoutUserInput[]
    createMany?: SecurityAlertCreateManyUserInputEnvelope
    connect?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
  }

  export type UserBonusUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBonusCreateWithoutUserInput, UserBonusUncheckedCreateWithoutUserInput> | UserBonusCreateWithoutUserInput[] | UserBonusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutUserInput | UserBonusCreateOrConnectWithoutUserInput[]
    createMany?: UserBonusCreateManyUserInputEnvelope
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserPasswordUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPasswordCreateWithoutUserInput, UserPasswordUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPasswordCreateOrConnectWithoutUserInput
    upsert?: UserPasswordUpsertWithoutUserInput
    disconnect?: UserPasswordWhereInput | boolean
    delete?: UserPasswordWhereInput | boolean
    connect?: UserPasswordWhereUniqueInput
    update?: XOR<XOR<UserPasswordUpdateToOneWithWhereWithoutUserInput, UserPasswordUpdateWithoutUserInput>, UserPasswordUncheckedUpdateWithoutUserInput>
  }

  export type TwoFactorAuthUpdateOneWithoutUserNestedInput = {
    create?: XOR<TwoFactorAuthCreateWithoutUserInput, TwoFactorAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: TwoFactorAuthCreateOrConnectWithoutUserInput
    upsert?: TwoFactorAuthUpsertWithoutUserInput
    disconnect?: TwoFactorAuthWhereInput | boolean
    delete?: TwoFactorAuthWhereInput | boolean
    connect?: TwoFactorAuthWhereUniqueInput
    update?: XOR<XOR<TwoFactorAuthUpdateToOneWithWhereWithoutUserInput, TwoFactorAuthUpdateWithoutUserInput>, TwoFactorAuthUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type FinancialAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<FinancialAccountCreateWithoutUserInput, FinancialAccountUncheckedCreateWithoutUserInput> | FinancialAccountCreateWithoutUserInput[] | FinancialAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FinancialAccountCreateOrConnectWithoutUserInput | FinancialAccountCreateOrConnectWithoutUserInput[]
    upsert?: FinancialAccountUpsertWithWhereUniqueWithoutUserInput | FinancialAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FinancialAccountCreateManyUserInputEnvelope
    set?: FinancialAccountWhereUniqueInput | FinancialAccountWhereUniqueInput[]
    disconnect?: FinancialAccountWhereUniqueInput | FinancialAccountWhereUniqueInput[]
    delete?: FinancialAccountWhereUniqueInput | FinancialAccountWhereUniqueInput[]
    connect?: FinancialAccountWhereUniqueInput | FinancialAccountWhereUniqueInput[]
    update?: FinancialAccountUpdateWithWhereUniqueWithoutUserInput | FinancialAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FinancialAccountUpdateManyWithWhereWithoutUserInput | FinancialAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FinancialAccountScalarWhereInput | FinancialAccountScalarWhereInput[]
  }

  export type BetUpdateManyWithoutUserNestedInput = {
    create?: XOR<BetCreateWithoutUserInput, BetUncheckedCreateWithoutUserInput> | BetCreateWithoutUserInput[] | BetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetCreateOrConnectWithoutUserInput | BetCreateOrConnectWithoutUserInput[]
    upsert?: BetUpsertWithWhereUniqueWithoutUserInput | BetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BetCreateManyUserInputEnvelope
    set?: BetWhereUniqueInput | BetWhereUniqueInput[]
    disconnect?: BetWhereUniqueInput | BetWhereUniqueInput[]
    delete?: BetWhereUniqueInput | BetWhereUniqueInput[]
    connect?: BetWhereUniqueInput | BetWhereUniqueInput[]
    update?: BetUpdateWithWhereUniqueWithoutUserInput | BetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BetUpdateManyWithWhereWithoutUserInput | BetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BetScalarWhereInput | BetScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type PaymentMethodUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutUserInput, PaymentMethodUncheckedCreateWithoutUserInput> | PaymentMethodCreateWithoutUserInput[] | PaymentMethodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutUserInput | PaymentMethodCreateOrConnectWithoutUserInput[]
    upsert?: PaymentMethodUpsertWithWhereUniqueWithoutUserInput | PaymentMethodUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentMethodCreateManyUserInputEnvelope
    set?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    disconnect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    delete?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    update?: PaymentMethodUpdateWithWhereUniqueWithoutUserInput | PaymentMethodUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentMethodUpdateManyWithWhereWithoutUserInput | PaymentMethodUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
  }

  export type FraudEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<FraudEventCreateWithoutUserInput, FraudEventUncheckedCreateWithoutUserInput> | FraudEventCreateWithoutUserInput[] | FraudEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FraudEventCreateOrConnectWithoutUserInput | FraudEventCreateOrConnectWithoutUserInput[]
    upsert?: FraudEventUpsertWithWhereUniqueWithoutUserInput | FraudEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FraudEventCreateManyUserInputEnvelope
    set?: FraudEventWhereUniqueInput | FraudEventWhereUniqueInput[]
    disconnect?: FraudEventWhereUniqueInput | FraudEventWhereUniqueInput[]
    delete?: FraudEventWhereUniqueInput | FraudEventWhereUniqueInput[]
    connect?: FraudEventWhereUniqueInput | FraudEventWhereUniqueInput[]
    update?: FraudEventUpdateWithWhereUniqueWithoutUserInput | FraudEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FraudEventUpdateManyWithWhereWithoutUserInput | FraudEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FraudEventScalarWhereInput | FraudEventScalarWhereInput[]
  }

  export type BettingPatternUpdateManyWithoutUserNestedInput = {
    create?: XOR<BettingPatternCreateWithoutUserInput, BettingPatternUncheckedCreateWithoutUserInput> | BettingPatternCreateWithoutUserInput[] | BettingPatternUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BettingPatternCreateOrConnectWithoutUserInput | BettingPatternCreateOrConnectWithoutUserInput[]
    upsert?: BettingPatternUpsertWithWhereUniqueWithoutUserInput | BettingPatternUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BettingPatternCreateManyUserInputEnvelope
    set?: BettingPatternWhereUniqueInput | BettingPatternWhereUniqueInput[]
    disconnect?: BettingPatternWhereUniqueInput | BettingPatternWhereUniqueInput[]
    delete?: BettingPatternWhereUniqueInput | BettingPatternWhereUniqueInput[]
    connect?: BettingPatternWhereUniqueInput | BettingPatternWhereUniqueInput[]
    update?: BettingPatternUpdateWithWhereUniqueWithoutUserInput | BettingPatternUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BettingPatternUpdateManyWithWhereWithoutUserInput | BettingPatternUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BettingPatternScalarWhereInput | BettingPatternScalarWhereInput[]
  }

  export type AccountActivityLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountActivityLogCreateWithoutUserInput, AccountActivityLogUncheckedCreateWithoutUserInput> | AccountActivityLogCreateWithoutUserInput[] | AccountActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountActivityLogCreateOrConnectWithoutUserInput | AccountActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: AccountActivityLogUpsertWithWhereUniqueWithoutUserInput | AccountActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountActivityLogCreateManyUserInputEnvelope
    set?: AccountActivityLogWhereUniqueInput | AccountActivityLogWhereUniqueInput[]
    disconnect?: AccountActivityLogWhereUniqueInput | AccountActivityLogWhereUniqueInput[]
    delete?: AccountActivityLogWhereUniqueInput | AccountActivityLogWhereUniqueInput[]
    connect?: AccountActivityLogWhereUniqueInput | AccountActivityLogWhereUniqueInput[]
    update?: AccountActivityLogUpdateWithWhereUniqueWithoutUserInput | AccountActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountActivityLogUpdateManyWithWhereWithoutUserInput | AccountActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountActivityLogScalarWhereInput | AccountActivityLogScalarWhereInput[]
  }

  export type DeviceRegistryUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceRegistryCreateWithoutUserInput, DeviceRegistryUncheckedCreateWithoutUserInput> | DeviceRegistryCreateWithoutUserInput[] | DeviceRegistryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceRegistryCreateOrConnectWithoutUserInput | DeviceRegistryCreateOrConnectWithoutUserInput[]
    upsert?: DeviceRegistryUpsertWithWhereUniqueWithoutUserInput | DeviceRegistryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceRegistryCreateManyUserInputEnvelope
    set?: DeviceRegistryWhereUniqueInput | DeviceRegistryWhereUniqueInput[]
    disconnect?: DeviceRegistryWhereUniqueInput | DeviceRegistryWhereUniqueInput[]
    delete?: DeviceRegistryWhereUniqueInput | DeviceRegistryWhereUniqueInput[]
    connect?: DeviceRegistryWhereUniqueInput | DeviceRegistryWhereUniqueInput[]
    update?: DeviceRegistryUpdateWithWhereUniqueWithoutUserInput | DeviceRegistryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceRegistryUpdateManyWithWhereWithoutUserInput | DeviceRegistryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceRegistryScalarWhereInput | DeviceRegistryScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type GdprConsentUpdateManyWithoutUserNestedInput = {
    create?: XOR<GdprConsentCreateWithoutUserInput, GdprConsentUncheckedCreateWithoutUserInput> | GdprConsentCreateWithoutUserInput[] | GdprConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GdprConsentCreateOrConnectWithoutUserInput | GdprConsentCreateOrConnectWithoutUserInput[]
    upsert?: GdprConsentUpsertWithWhereUniqueWithoutUserInput | GdprConsentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GdprConsentCreateManyUserInputEnvelope
    set?: GdprConsentWhereUniqueInput | GdprConsentWhereUniqueInput[]
    disconnect?: GdprConsentWhereUniqueInput | GdprConsentWhereUniqueInput[]
    delete?: GdprConsentWhereUniqueInput | GdprConsentWhereUniqueInput[]
    connect?: GdprConsentWhereUniqueInput | GdprConsentWhereUniqueInput[]
    update?: GdprConsentUpdateWithWhereUniqueWithoutUserInput | GdprConsentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GdprConsentUpdateManyWithWhereWithoutUserInput | GdprConsentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GdprConsentScalarWhereInput | GdprConsentScalarWhereInput[]
  }

  export type DataDeletionRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<DataDeletionRequestCreateWithoutUserInput, DataDeletionRequestUncheckedCreateWithoutUserInput> | DataDeletionRequestCreateWithoutUserInput[] | DataDeletionRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataDeletionRequestCreateOrConnectWithoutUserInput | DataDeletionRequestCreateOrConnectWithoutUserInput[]
    upsert?: DataDeletionRequestUpsertWithWhereUniqueWithoutUserInput | DataDeletionRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DataDeletionRequestCreateManyUserInputEnvelope
    set?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    disconnect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    delete?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    connect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    update?: DataDeletionRequestUpdateWithWhereUniqueWithoutUserInput | DataDeletionRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DataDeletionRequestUpdateManyWithWhereWithoutUserInput | DataDeletionRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DataDeletionRequestScalarWhereInput | DataDeletionRequestScalarWhereInput[]
  }

  export type DataExportRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<DataExportRequestCreateWithoutUserInput, DataExportRequestUncheckedCreateWithoutUserInput> | DataExportRequestCreateWithoutUserInput[] | DataExportRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataExportRequestCreateOrConnectWithoutUserInput | DataExportRequestCreateOrConnectWithoutUserInput[]
    upsert?: DataExportRequestUpsertWithWhereUniqueWithoutUserInput | DataExportRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DataExportRequestCreateManyUserInputEnvelope
    set?: DataExportRequestWhereUniqueInput | DataExportRequestWhereUniqueInput[]
    disconnect?: DataExportRequestWhereUniqueInput | DataExportRequestWhereUniqueInput[]
    delete?: DataExportRequestWhereUniqueInput | DataExportRequestWhereUniqueInput[]
    connect?: DataExportRequestWhereUniqueInput | DataExportRequestWhereUniqueInput[]
    update?: DataExportRequestUpdateWithWhereUniqueWithoutUserInput | DataExportRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DataExportRequestUpdateManyWithWhereWithoutUserInput | DataExportRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DataExportRequestScalarWhereInput | DataExportRequestScalarWhereInput[]
  }

  export type SecurityAlertUpdateManyWithoutUserNestedInput = {
    create?: XOR<SecurityAlertCreateWithoutUserInput, SecurityAlertUncheckedCreateWithoutUserInput> | SecurityAlertCreateWithoutUserInput[] | SecurityAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityAlertCreateOrConnectWithoutUserInput | SecurityAlertCreateOrConnectWithoutUserInput[]
    upsert?: SecurityAlertUpsertWithWhereUniqueWithoutUserInput | SecurityAlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SecurityAlertCreateManyUserInputEnvelope
    set?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    disconnect?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    delete?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    connect?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    update?: SecurityAlertUpdateWithWhereUniqueWithoutUserInput | SecurityAlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SecurityAlertUpdateManyWithWhereWithoutUserInput | SecurityAlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SecurityAlertScalarWhereInput | SecurityAlertScalarWhereInput[]
  }

  export type UserBonusUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBonusCreateWithoutUserInput, UserBonusUncheckedCreateWithoutUserInput> | UserBonusCreateWithoutUserInput[] | UserBonusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutUserInput | UserBonusCreateOrConnectWithoutUserInput[]
    upsert?: UserBonusUpsertWithWhereUniqueWithoutUserInput | UserBonusUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBonusCreateManyUserInputEnvelope
    set?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    disconnect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    delete?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    update?: UserBonusUpdateWithWhereUniqueWithoutUserInput | UserBonusUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBonusUpdateManyWithWhereWithoutUserInput | UserBonusUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserPasswordUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPasswordCreateWithoutUserInput, UserPasswordUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPasswordCreateOrConnectWithoutUserInput
    upsert?: UserPasswordUpsertWithoutUserInput
    disconnect?: UserPasswordWhereInput | boolean
    delete?: UserPasswordWhereInput | boolean
    connect?: UserPasswordWhereUniqueInput
    update?: XOR<XOR<UserPasswordUpdateToOneWithWhereWithoutUserInput, UserPasswordUpdateWithoutUserInput>, UserPasswordUncheckedUpdateWithoutUserInput>
  }

  export type TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TwoFactorAuthCreateWithoutUserInput, TwoFactorAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: TwoFactorAuthCreateOrConnectWithoutUserInput
    upsert?: TwoFactorAuthUpsertWithoutUserInput
    disconnect?: TwoFactorAuthWhereInput | boolean
    delete?: TwoFactorAuthWhereInput | boolean
    connect?: TwoFactorAuthWhereUniqueInput
    update?: XOR<XOR<TwoFactorAuthUpdateToOneWithWhereWithoutUserInput, TwoFactorAuthUpdateWithoutUserInput>, TwoFactorAuthUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type FinancialAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FinancialAccountCreateWithoutUserInput, FinancialAccountUncheckedCreateWithoutUserInput> | FinancialAccountCreateWithoutUserInput[] | FinancialAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FinancialAccountCreateOrConnectWithoutUserInput | FinancialAccountCreateOrConnectWithoutUserInput[]
    upsert?: FinancialAccountUpsertWithWhereUniqueWithoutUserInput | FinancialAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FinancialAccountCreateManyUserInputEnvelope
    set?: FinancialAccountWhereUniqueInput | FinancialAccountWhereUniqueInput[]
    disconnect?: FinancialAccountWhereUniqueInput | FinancialAccountWhereUniqueInput[]
    delete?: FinancialAccountWhereUniqueInput | FinancialAccountWhereUniqueInput[]
    connect?: FinancialAccountWhereUniqueInput | FinancialAccountWhereUniqueInput[]
    update?: FinancialAccountUpdateWithWhereUniqueWithoutUserInput | FinancialAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FinancialAccountUpdateManyWithWhereWithoutUserInput | FinancialAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FinancialAccountScalarWhereInput | FinancialAccountScalarWhereInput[]
  }

  export type BetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BetCreateWithoutUserInput, BetUncheckedCreateWithoutUserInput> | BetCreateWithoutUserInput[] | BetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetCreateOrConnectWithoutUserInput | BetCreateOrConnectWithoutUserInput[]
    upsert?: BetUpsertWithWhereUniqueWithoutUserInput | BetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BetCreateManyUserInputEnvelope
    set?: BetWhereUniqueInput | BetWhereUniqueInput[]
    disconnect?: BetWhereUniqueInput | BetWhereUniqueInput[]
    delete?: BetWhereUniqueInput | BetWhereUniqueInput[]
    connect?: BetWhereUniqueInput | BetWhereUniqueInput[]
    update?: BetUpdateWithWhereUniqueWithoutUserInput | BetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BetUpdateManyWithWhereWithoutUserInput | BetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BetScalarWhereInput | BetScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type PaymentMethodUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutUserInput, PaymentMethodUncheckedCreateWithoutUserInput> | PaymentMethodCreateWithoutUserInput[] | PaymentMethodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutUserInput | PaymentMethodCreateOrConnectWithoutUserInput[]
    upsert?: PaymentMethodUpsertWithWhereUniqueWithoutUserInput | PaymentMethodUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentMethodCreateManyUserInputEnvelope
    set?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    disconnect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    delete?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    update?: PaymentMethodUpdateWithWhereUniqueWithoutUserInput | PaymentMethodUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentMethodUpdateManyWithWhereWithoutUserInput | PaymentMethodUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
  }

  export type FraudEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FraudEventCreateWithoutUserInput, FraudEventUncheckedCreateWithoutUserInput> | FraudEventCreateWithoutUserInput[] | FraudEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FraudEventCreateOrConnectWithoutUserInput | FraudEventCreateOrConnectWithoutUserInput[]
    upsert?: FraudEventUpsertWithWhereUniqueWithoutUserInput | FraudEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FraudEventCreateManyUserInputEnvelope
    set?: FraudEventWhereUniqueInput | FraudEventWhereUniqueInput[]
    disconnect?: FraudEventWhereUniqueInput | FraudEventWhereUniqueInput[]
    delete?: FraudEventWhereUniqueInput | FraudEventWhereUniqueInput[]
    connect?: FraudEventWhereUniqueInput | FraudEventWhereUniqueInput[]
    update?: FraudEventUpdateWithWhereUniqueWithoutUserInput | FraudEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FraudEventUpdateManyWithWhereWithoutUserInput | FraudEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FraudEventScalarWhereInput | FraudEventScalarWhereInput[]
  }

  export type BettingPatternUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BettingPatternCreateWithoutUserInput, BettingPatternUncheckedCreateWithoutUserInput> | BettingPatternCreateWithoutUserInput[] | BettingPatternUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BettingPatternCreateOrConnectWithoutUserInput | BettingPatternCreateOrConnectWithoutUserInput[]
    upsert?: BettingPatternUpsertWithWhereUniqueWithoutUserInput | BettingPatternUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BettingPatternCreateManyUserInputEnvelope
    set?: BettingPatternWhereUniqueInput | BettingPatternWhereUniqueInput[]
    disconnect?: BettingPatternWhereUniqueInput | BettingPatternWhereUniqueInput[]
    delete?: BettingPatternWhereUniqueInput | BettingPatternWhereUniqueInput[]
    connect?: BettingPatternWhereUniqueInput | BettingPatternWhereUniqueInput[]
    update?: BettingPatternUpdateWithWhereUniqueWithoutUserInput | BettingPatternUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BettingPatternUpdateManyWithWhereWithoutUserInput | BettingPatternUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BettingPatternScalarWhereInput | BettingPatternScalarWhereInput[]
  }

  export type AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountActivityLogCreateWithoutUserInput, AccountActivityLogUncheckedCreateWithoutUserInput> | AccountActivityLogCreateWithoutUserInput[] | AccountActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountActivityLogCreateOrConnectWithoutUserInput | AccountActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: AccountActivityLogUpsertWithWhereUniqueWithoutUserInput | AccountActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountActivityLogCreateManyUserInputEnvelope
    set?: AccountActivityLogWhereUniqueInput | AccountActivityLogWhereUniqueInput[]
    disconnect?: AccountActivityLogWhereUniqueInput | AccountActivityLogWhereUniqueInput[]
    delete?: AccountActivityLogWhereUniqueInput | AccountActivityLogWhereUniqueInput[]
    connect?: AccountActivityLogWhereUniqueInput | AccountActivityLogWhereUniqueInput[]
    update?: AccountActivityLogUpdateWithWhereUniqueWithoutUserInput | AccountActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountActivityLogUpdateManyWithWhereWithoutUserInput | AccountActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountActivityLogScalarWhereInput | AccountActivityLogScalarWhereInput[]
  }

  export type DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceRegistryCreateWithoutUserInput, DeviceRegistryUncheckedCreateWithoutUserInput> | DeviceRegistryCreateWithoutUserInput[] | DeviceRegistryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceRegistryCreateOrConnectWithoutUserInput | DeviceRegistryCreateOrConnectWithoutUserInput[]
    upsert?: DeviceRegistryUpsertWithWhereUniqueWithoutUserInput | DeviceRegistryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceRegistryCreateManyUserInputEnvelope
    set?: DeviceRegistryWhereUniqueInput | DeviceRegistryWhereUniqueInput[]
    disconnect?: DeviceRegistryWhereUniqueInput | DeviceRegistryWhereUniqueInput[]
    delete?: DeviceRegistryWhereUniqueInput | DeviceRegistryWhereUniqueInput[]
    connect?: DeviceRegistryWhereUniqueInput | DeviceRegistryWhereUniqueInput[]
    update?: DeviceRegistryUpdateWithWhereUniqueWithoutUserInput | DeviceRegistryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceRegistryUpdateManyWithWhereWithoutUserInput | DeviceRegistryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceRegistryScalarWhereInput | DeviceRegistryScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type GdprConsentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GdprConsentCreateWithoutUserInput, GdprConsentUncheckedCreateWithoutUserInput> | GdprConsentCreateWithoutUserInput[] | GdprConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GdprConsentCreateOrConnectWithoutUserInput | GdprConsentCreateOrConnectWithoutUserInput[]
    upsert?: GdprConsentUpsertWithWhereUniqueWithoutUserInput | GdprConsentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GdprConsentCreateManyUserInputEnvelope
    set?: GdprConsentWhereUniqueInput | GdprConsentWhereUniqueInput[]
    disconnect?: GdprConsentWhereUniqueInput | GdprConsentWhereUniqueInput[]
    delete?: GdprConsentWhereUniqueInput | GdprConsentWhereUniqueInput[]
    connect?: GdprConsentWhereUniqueInput | GdprConsentWhereUniqueInput[]
    update?: GdprConsentUpdateWithWhereUniqueWithoutUserInput | GdprConsentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GdprConsentUpdateManyWithWhereWithoutUserInput | GdprConsentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GdprConsentScalarWhereInput | GdprConsentScalarWhereInput[]
  }

  export type DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DataDeletionRequestCreateWithoutUserInput, DataDeletionRequestUncheckedCreateWithoutUserInput> | DataDeletionRequestCreateWithoutUserInput[] | DataDeletionRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataDeletionRequestCreateOrConnectWithoutUserInput | DataDeletionRequestCreateOrConnectWithoutUserInput[]
    upsert?: DataDeletionRequestUpsertWithWhereUniqueWithoutUserInput | DataDeletionRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DataDeletionRequestCreateManyUserInputEnvelope
    set?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    disconnect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    delete?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    connect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    update?: DataDeletionRequestUpdateWithWhereUniqueWithoutUserInput | DataDeletionRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DataDeletionRequestUpdateManyWithWhereWithoutUserInput | DataDeletionRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DataDeletionRequestScalarWhereInput | DataDeletionRequestScalarWhereInput[]
  }

  export type DataExportRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DataExportRequestCreateWithoutUserInput, DataExportRequestUncheckedCreateWithoutUserInput> | DataExportRequestCreateWithoutUserInput[] | DataExportRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataExportRequestCreateOrConnectWithoutUserInput | DataExportRequestCreateOrConnectWithoutUserInput[]
    upsert?: DataExportRequestUpsertWithWhereUniqueWithoutUserInput | DataExportRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DataExportRequestCreateManyUserInputEnvelope
    set?: DataExportRequestWhereUniqueInput | DataExportRequestWhereUniqueInput[]
    disconnect?: DataExportRequestWhereUniqueInput | DataExportRequestWhereUniqueInput[]
    delete?: DataExportRequestWhereUniqueInput | DataExportRequestWhereUniqueInput[]
    connect?: DataExportRequestWhereUniqueInput | DataExportRequestWhereUniqueInput[]
    update?: DataExportRequestUpdateWithWhereUniqueWithoutUserInput | DataExportRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DataExportRequestUpdateManyWithWhereWithoutUserInput | DataExportRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DataExportRequestScalarWhereInput | DataExportRequestScalarWhereInput[]
  }

  export type SecurityAlertUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SecurityAlertCreateWithoutUserInput, SecurityAlertUncheckedCreateWithoutUserInput> | SecurityAlertCreateWithoutUserInput[] | SecurityAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityAlertCreateOrConnectWithoutUserInput | SecurityAlertCreateOrConnectWithoutUserInput[]
    upsert?: SecurityAlertUpsertWithWhereUniqueWithoutUserInput | SecurityAlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SecurityAlertCreateManyUserInputEnvelope
    set?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    disconnect?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    delete?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    connect?: SecurityAlertWhereUniqueInput | SecurityAlertWhereUniqueInput[]
    update?: SecurityAlertUpdateWithWhereUniqueWithoutUserInput | SecurityAlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SecurityAlertUpdateManyWithWhereWithoutUserInput | SecurityAlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SecurityAlertScalarWhereInput | SecurityAlertScalarWhereInput[]
  }

  export type UserBonusUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBonusCreateWithoutUserInput, UserBonusUncheckedCreateWithoutUserInput> | UserBonusCreateWithoutUserInput[] | UserBonusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutUserInput | UserBonusCreateOrConnectWithoutUserInput[]
    upsert?: UserBonusUpsertWithWhereUniqueWithoutUserInput | UserBonusUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBonusCreateManyUserInputEnvelope
    set?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    disconnect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    delete?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    update?: UserBonusUpdateWithWhereUniqueWithoutUserInput | UserBonusUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBonusUpdateManyWithWhereWithoutUserInput | UserBonusUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserCreateNestedOneWithoutPasswordInput = {
    create?: XOR<UserCreateWithoutPasswordInput, UserUncheckedCreateWithoutPasswordInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordNestedInput = {
    create?: XOR<UserCreateWithoutPasswordInput, UserUncheckedCreateWithoutPasswordInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordInput
    upsert?: UserUpsertWithoutPasswordInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordInput, UserUpdateWithoutPasswordInput>, UserUncheckedUpdateWithoutPasswordInput>
  }

  export type UserCreateNestedOneWithoutTwoFactorAuthInput = {
    create?: XOR<UserCreateWithoutTwoFactorAuthInput, UserUncheckedCreateWithoutTwoFactorAuthInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwoFactorAuthInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTwoFactorAuthNestedInput = {
    create?: XOR<UserCreateWithoutTwoFactorAuthInput, UserUncheckedCreateWithoutTwoFactorAuthInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwoFactorAuthInput
    upsert?: UserUpsertWithoutTwoFactorAuthInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTwoFactorAuthInput, UserUpdateWithoutTwoFactorAuthInput>, UserUncheckedUpdateWithoutTwoFactorAuthInput>
  }

  export type UserCreateNestedOneWithoutUserSessionsInput = {
    create?: XOR<UserCreateWithoutUserSessionsInput, UserUncheckedCreateWithoutUserSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserSessionsNestedInput = {
    create?: XOR<UserCreateWithoutUserSessionsInput, UserUncheckedCreateWithoutUserSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSessionsInput
    upsert?: UserUpsertWithoutUserSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserSessionsInput, UserUpdateWithoutUserSessionsInput>, UserUncheckedUpdateWithoutUserSessionsInput>
  }

  export type LeagueCreateNestedManyWithoutSportInput = {
    create?: XOR<LeagueCreateWithoutSportInput, LeagueUncheckedCreateWithoutSportInput> | LeagueCreateWithoutSportInput[] | LeagueUncheckedCreateWithoutSportInput[]
    connectOrCreate?: LeagueCreateOrConnectWithoutSportInput | LeagueCreateOrConnectWithoutSportInput[]
    createMany?: LeagueCreateManySportInputEnvelope
    connect?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
  }

  export type GameCreateNestedManyWithoutSportInput = {
    create?: XOR<GameCreateWithoutSportInput, GameUncheckedCreateWithoutSportInput> | GameCreateWithoutSportInput[] | GameUncheckedCreateWithoutSportInput[]
    connectOrCreate?: GameCreateOrConnectWithoutSportInput | GameCreateOrConnectWithoutSportInput[]
    createMany?: GameCreateManySportInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type LeagueUncheckedCreateNestedManyWithoutSportInput = {
    create?: XOR<LeagueCreateWithoutSportInput, LeagueUncheckedCreateWithoutSportInput> | LeagueCreateWithoutSportInput[] | LeagueUncheckedCreateWithoutSportInput[]
    connectOrCreate?: LeagueCreateOrConnectWithoutSportInput | LeagueCreateOrConnectWithoutSportInput[]
    createMany?: LeagueCreateManySportInputEnvelope
    connect?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutSportInput = {
    create?: XOR<GameCreateWithoutSportInput, GameUncheckedCreateWithoutSportInput> | GameCreateWithoutSportInput[] | GameUncheckedCreateWithoutSportInput[]
    connectOrCreate?: GameCreateOrConnectWithoutSportInput | GameCreateOrConnectWithoutSportInput[]
    createMany?: GameCreateManySportInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type LeagueUpdateManyWithoutSportNestedInput = {
    create?: XOR<LeagueCreateWithoutSportInput, LeagueUncheckedCreateWithoutSportInput> | LeagueCreateWithoutSportInput[] | LeagueUncheckedCreateWithoutSportInput[]
    connectOrCreate?: LeagueCreateOrConnectWithoutSportInput | LeagueCreateOrConnectWithoutSportInput[]
    upsert?: LeagueUpsertWithWhereUniqueWithoutSportInput | LeagueUpsertWithWhereUniqueWithoutSportInput[]
    createMany?: LeagueCreateManySportInputEnvelope
    set?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    disconnect?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    delete?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    connect?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    update?: LeagueUpdateWithWhereUniqueWithoutSportInput | LeagueUpdateWithWhereUniqueWithoutSportInput[]
    updateMany?: LeagueUpdateManyWithWhereWithoutSportInput | LeagueUpdateManyWithWhereWithoutSportInput[]
    deleteMany?: LeagueScalarWhereInput | LeagueScalarWhereInput[]
  }

  export type GameUpdateManyWithoutSportNestedInput = {
    create?: XOR<GameCreateWithoutSportInput, GameUncheckedCreateWithoutSportInput> | GameCreateWithoutSportInput[] | GameUncheckedCreateWithoutSportInput[]
    connectOrCreate?: GameCreateOrConnectWithoutSportInput | GameCreateOrConnectWithoutSportInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutSportInput | GameUpsertWithWhereUniqueWithoutSportInput[]
    createMany?: GameCreateManySportInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutSportInput | GameUpdateWithWhereUniqueWithoutSportInput[]
    updateMany?: GameUpdateManyWithWhereWithoutSportInput | GameUpdateManyWithWhereWithoutSportInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type LeagueUncheckedUpdateManyWithoutSportNestedInput = {
    create?: XOR<LeagueCreateWithoutSportInput, LeagueUncheckedCreateWithoutSportInput> | LeagueCreateWithoutSportInput[] | LeagueUncheckedCreateWithoutSportInput[]
    connectOrCreate?: LeagueCreateOrConnectWithoutSportInput | LeagueCreateOrConnectWithoutSportInput[]
    upsert?: LeagueUpsertWithWhereUniqueWithoutSportInput | LeagueUpsertWithWhereUniqueWithoutSportInput[]
    createMany?: LeagueCreateManySportInputEnvelope
    set?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    disconnect?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    delete?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    connect?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    update?: LeagueUpdateWithWhereUniqueWithoutSportInput | LeagueUpdateWithWhereUniqueWithoutSportInput[]
    updateMany?: LeagueUpdateManyWithWhereWithoutSportInput | LeagueUpdateManyWithWhereWithoutSportInput[]
    deleteMany?: LeagueScalarWhereInput | LeagueScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutSportNestedInput = {
    create?: XOR<GameCreateWithoutSportInput, GameUncheckedCreateWithoutSportInput> | GameCreateWithoutSportInput[] | GameUncheckedCreateWithoutSportInput[]
    connectOrCreate?: GameCreateOrConnectWithoutSportInput | GameCreateOrConnectWithoutSportInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutSportInput | GameUpsertWithWhereUniqueWithoutSportInput[]
    createMany?: GameCreateManySportInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutSportInput | GameUpdateWithWhereUniqueWithoutSportInput[]
    updateMany?: GameUpdateManyWithWhereWithoutSportInput | GameUpdateManyWithWhereWithoutSportInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type SportCreateNestedOneWithoutLeaguesInput = {
    create?: XOR<SportCreateWithoutLeaguesInput, SportUncheckedCreateWithoutLeaguesInput>
    connectOrCreate?: SportCreateOrConnectWithoutLeaguesInput
    connect?: SportWhereUniqueInput
  }

  export type TeamCreateNestedManyWithoutLeagueInput = {
    create?: XOR<TeamCreateWithoutLeagueInput, TeamUncheckedCreateWithoutLeagueInput> | TeamCreateWithoutLeagueInput[] | TeamUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutLeagueInput | TeamCreateOrConnectWithoutLeagueInput[]
    createMany?: TeamCreateManyLeagueInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type GameCreateNestedManyWithoutLeagueInput = {
    create?: XOR<GameCreateWithoutLeagueInput, GameUncheckedCreateWithoutLeagueInput> | GameCreateWithoutLeagueInput[] | GameUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: GameCreateOrConnectWithoutLeagueInput | GameCreateOrConnectWithoutLeagueInput[]
    createMany?: GameCreateManyLeagueInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutLeagueInput = {
    create?: XOR<TeamCreateWithoutLeagueInput, TeamUncheckedCreateWithoutLeagueInput> | TeamCreateWithoutLeagueInput[] | TeamUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutLeagueInput | TeamCreateOrConnectWithoutLeagueInput[]
    createMany?: TeamCreateManyLeagueInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutLeagueInput = {
    create?: XOR<GameCreateWithoutLeagueInput, GameUncheckedCreateWithoutLeagueInput> | GameCreateWithoutLeagueInput[] | GameUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: GameCreateOrConnectWithoutLeagueInput | GameCreateOrConnectWithoutLeagueInput[]
    createMany?: GameCreateManyLeagueInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type SportUpdateOneRequiredWithoutLeaguesNestedInput = {
    create?: XOR<SportCreateWithoutLeaguesInput, SportUncheckedCreateWithoutLeaguesInput>
    connectOrCreate?: SportCreateOrConnectWithoutLeaguesInput
    upsert?: SportUpsertWithoutLeaguesInput
    connect?: SportWhereUniqueInput
    update?: XOR<XOR<SportUpdateToOneWithWhereWithoutLeaguesInput, SportUpdateWithoutLeaguesInput>, SportUncheckedUpdateWithoutLeaguesInput>
  }

  export type TeamUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<TeamCreateWithoutLeagueInput, TeamUncheckedCreateWithoutLeagueInput> | TeamCreateWithoutLeagueInput[] | TeamUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutLeagueInput | TeamCreateOrConnectWithoutLeagueInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutLeagueInput | TeamUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: TeamCreateManyLeagueInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutLeagueInput | TeamUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutLeagueInput | TeamUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type GameUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<GameCreateWithoutLeagueInput, GameUncheckedCreateWithoutLeagueInput> | GameCreateWithoutLeagueInput[] | GameUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: GameCreateOrConnectWithoutLeagueInput | GameCreateOrConnectWithoutLeagueInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutLeagueInput | GameUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: GameCreateManyLeagueInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutLeagueInput | GameUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: GameUpdateManyWithWhereWithoutLeagueInput | GameUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<TeamCreateWithoutLeagueInput, TeamUncheckedCreateWithoutLeagueInput> | TeamCreateWithoutLeagueInput[] | TeamUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutLeagueInput | TeamCreateOrConnectWithoutLeagueInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutLeagueInput | TeamUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: TeamCreateManyLeagueInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutLeagueInput | TeamUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutLeagueInput | TeamUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<GameCreateWithoutLeagueInput, GameUncheckedCreateWithoutLeagueInput> | GameCreateWithoutLeagueInput[] | GameUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: GameCreateOrConnectWithoutLeagueInput | GameCreateOrConnectWithoutLeagueInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutLeagueInput | GameUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: GameCreateManyLeagueInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutLeagueInput | GameUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: GameUpdateManyWithWhereWithoutLeagueInput | GameUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type LeagueCreateNestedOneWithoutTeamsInput = {
    create?: XOR<LeagueCreateWithoutTeamsInput, LeagueUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutTeamsInput
    connect?: LeagueWhereUniqueInput
  }

  export type GameCreateNestedManyWithoutHomeTeamInput = {
    create?: XOR<GameCreateWithoutHomeTeamInput, GameUncheckedCreateWithoutHomeTeamInput> | GameCreateWithoutHomeTeamInput[] | GameUncheckedCreateWithoutHomeTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutHomeTeamInput | GameCreateOrConnectWithoutHomeTeamInput[]
    createMany?: GameCreateManyHomeTeamInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type GameCreateNestedManyWithoutAwayTeamInput = {
    create?: XOR<GameCreateWithoutAwayTeamInput, GameUncheckedCreateWithoutAwayTeamInput> | GameCreateWithoutAwayTeamInput[] | GameUncheckedCreateWithoutAwayTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutAwayTeamInput | GameCreateOrConnectWithoutAwayTeamInput[]
    createMany?: GameCreateManyAwayTeamInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutHomeTeamInput = {
    create?: XOR<GameCreateWithoutHomeTeamInput, GameUncheckedCreateWithoutHomeTeamInput> | GameCreateWithoutHomeTeamInput[] | GameUncheckedCreateWithoutHomeTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutHomeTeamInput | GameCreateOrConnectWithoutHomeTeamInput[]
    createMany?: GameCreateManyHomeTeamInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutAwayTeamInput = {
    create?: XOR<GameCreateWithoutAwayTeamInput, GameUncheckedCreateWithoutAwayTeamInput> | GameCreateWithoutAwayTeamInput[] | GameUncheckedCreateWithoutAwayTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutAwayTeamInput | GameCreateOrConnectWithoutAwayTeamInput[]
    createMany?: GameCreateManyAwayTeamInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type LeagueUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<LeagueCreateWithoutTeamsInput, LeagueUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutTeamsInput
    upsert?: LeagueUpsertWithoutTeamsInput
    connect?: LeagueWhereUniqueInput
    update?: XOR<XOR<LeagueUpdateToOneWithWhereWithoutTeamsInput, LeagueUpdateWithoutTeamsInput>, LeagueUncheckedUpdateWithoutTeamsInput>
  }

  export type GameUpdateManyWithoutHomeTeamNestedInput = {
    create?: XOR<GameCreateWithoutHomeTeamInput, GameUncheckedCreateWithoutHomeTeamInput> | GameCreateWithoutHomeTeamInput[] | GameUncheckedCreateWithoutHomeTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutHomeTeamInput | GameCreateOrConnectWithoutHomeTeamInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutHomeTeamInput | GameUpsertWithWhereUniqueWithoutHomeTeamInput[]
    createMany?: GameCreateManyHomeTeamInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutHomeTeamInput | GameUpdateWithWhereUniqueWithoutHomeTeamInput[]
    updateMany?: GameUpdateManyWithWhereWithoutHomeTeamInput | GameUpdateManyWithWhereWithoutHomeTeamInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type GameUpdateManyWithoutAwayTeamNestedInput = {
    create?: XOR<GameCreateWithoutAwayTeamInput, GameUncheckedCreateWithoutAwayTeamInput> | GameCreateWithoutAwayTeamInput[] | GameUncheckedCreateWithoutAwayTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutAwayTeamInput | GameCreateOrConnectWithoutAwayTeamInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutAwayTeamInput | GameUpsertWithWhereUniqueWithoutAwayTeamInput[]
    createMany?: GameCreateManyAwayTeamInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutAwayTeamInput | GameUpdateWithWhereUniqueWithoutAwayTeamInput[]
    updateMany?: GameUpdateManyWithWhereWithoutAwayTeamInput | GameUpdateManyWithWhereWithoutAwayTeamInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutHomeTeamNestedInput = {
    create?: XOR<GameCreateWithoutHomeTeamInput, GameUncheckedCreateWithoutHomeTeamInput> | GameCreateWithoutHomeTeamInput[] | GameUncheckedCreateWithoutHomeTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutHomeTeamInput | GameCreateOrConnectWithoutHomeTeamInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutHomeTeamInput | GameUpsertWithWhereUniqueWithoutHomeTeamInput[]
    createMany?: GameCreateManyHomeTeamInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutHomeTeamInput | GameUpdateWithWhereUniqueWithoutHomeTeamInput[]
    updateMany?: GameUpdateManyWithWhereWithoutHomeTeamInput | GameUpdateManyWithWhereWithoutHomeTeamInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutAwayTeamNestedInput = {
    create?: XOR<GameCreateWithoutAwayTeamInput, GameUncheckedCreateWithoutAwayTeamInput> | GameCreateWithoutAwayTeamInput[] | GameUncheckedCreateWithoutAwayTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutAwayTeamInput | GameCreateOrConnectWithoutAwayTeamInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutAwayTeamInput | GameUpsertWithWhereUniqueWithoutAwayTeamInput[]
    createMany?: GameCreateManyAwayTeamInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutAwayTeamInput | GameUpdateWithWhereUniqueWithoutAwayTeamInput[]
    updateMany?: GameUpdateManyWithWhereWithoutAwayTeamInput | GameUpdateManyWithWhereWithoutAwayTeamInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type SportCreateNestedOneWithoutGamesInput = {
    create?: XOR<SportCreateWithoutGamesInput, SportUncheckedCreateWithoutGamesInput>
    connectOrCreate?: SportCreateOrConnectWithoutGamesInput
    connect?: SportWhereUniqueInput
  }

  export type LeagueCreateNestedOneWithoutGamesInput = {
    create?: XOR<LeagueCreateWithoutGamesInput, LeagueUncheckedCreateWithoutGamesInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutGamesInput
    connect?: LeagueWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutHomeGamesInput = {
    create?: XOR<TeamCreateWithoutHomeGamesInput, TeamUncheckedCreateWithoutHomeGamesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutHomeGamesInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutAwayGamesInput = {
    create?: XOR<TeamCreateWithoutAwayGamesInput, TeamUncheckedCreateWithoutAwayGamesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutAwayGamesInput
    connect?: TeamWhereUniqueInput
  }

  export type BetMarketCreateNestedManyWithoutGameInput = {
    create?: XOR<BetMarketCreateWithoutGameInput, BetMarketUncheckedCreateWithoutGameInput> | BetMarketCreateWithoutGameInput[] | BetMarketUncheckedCreateWithoutGameInput[]
    connectOrCreate?: BetMarketCreateOrConnectWithoutGameInput | BetMarketCreateOrConnectWithoutGameInput[]
    createMany?: BetMarketCreateManyGameInputEnvelope
    connect?: BetMarketWhereUniqueInput | BetMarketWhereUniqueInput[]
  }

  export type OddsSyncStatusCreateNestedOneWithoutGameInput = {
    create?: XOR<OddsSyncStatusCreateWithoutGameInput, OddsSyncStatusUncheckedCreateWithoutGameInput>
    connectOrCreate?: OddsSyncStatusCreateOrConnectWithoutGameInput
    connect?: OddsSyncStatusWhereUniqueInput
  }

  export type BetMarketUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<BetMarketCreateWithoutGameInput, BetMarketUncheckedCreateWithoutGameInput> | BetMarketCreateWithoutGameInput[] | BetMarketUncheckedCreateWithoutGameInput[]
    connectOrCreate?: BetMarketCreateOrConnectWithoutGameInput | BetMarketCreateOrConnectWithoutGameInput[]
    createMany?: BetMarketCreateManyGameInputEnvelope
    connect?: BetMarketWhereUniqueInput | BetMarketWhereUniqueInput[]
  }

  export type OddsSyncStatusUncheckedCreateNestedOneWithoutGameInput = {
    create?: XOR<OddsSyncStatusCreateWithoutGameInput, OddsSyncStatusUncheckedCreateWithoutGameInput>
    connectOrCreate?: OddsSyncStatusCreateOrConnectWithoutGameInput
    connect?: OddsSyncStatusWhereUniqueInput
  }

  export type SportUpdateOneRequiredWithoutGamesNestedInput = {
    create?: XOR<SportCreateWithoutGamesInput, SportUncheckedCreateWithoutGamesInput>
    connectOrCreate?: SportCreateOrConnectWithoutGamesInput
    upsert?: SportUpsertWithoutGamesInput
    connect?: SportWhereUniqueInput
    update?: XOR<XOR<SportUpdateToOneWithWhereWithoutGamesInput, SportUpdateWithoutGamesInput>, SportUncheckedUpdateWithoutGamesInput>
  }

  export type LeagueUpdateOneRequiredWithoutGamesNestedInput = {
    create?: XOR<LeagueCreateWithoutGamesInput, LeagueUncheckedCreateWithoutGamesInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutGamesInput
    upsert?: LeagueUpsertWithoutGamesInput
    connect?: LeagueWhereUniqueInput
    update?: XOR<XOR<LeagueUpdateToOneWithWhereWithoutGamesInput, LeagueUpdateWithoutGamesInput>, LeagueUncheckedUpdateWithoutGamesInput>
  }

  export type TeamUpdateOneRequiredWithoutHomeGamesNestedInput = {
    create?: XOR<TeamCreateWithoutHomeGamesInput, TeamUncheckedCreateWithoutHomeGamesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutHomeGamesInput
    upsert?: TeamUpsertWithoutHomeGamesInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutHomeGamesInput, TeamUpdateWithoutHomeGamesInput>, TeamUncheckedUpdateWithoutHomeGamesInput>
  }

  export type TeamUpdateOneRequiredWithoutAwayGamesNestedInput = {
    create?: XOR<TeamCreateWithoutAwayGamesInput, TeamUncheckedCreateWithoutAwayGamesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutAwayGamesInput
    upsert?: TeamUpsertWithoutAwayGamesInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutAwayGamesInput, TeamUpdateWithoutAwayGamesInput>, TeamUncheckedUpdateWithoutAwayGamesInput>
  }

  export type BetMarketUpdateManyWithoutGameNestedInput = {
    create?: XOR<BetMarketCreateWithoutGameInput, BetMarketUncheckedCreateWithoutGameInput> | BetMarketCreateWithoutGameInput[] | BetMarketUncheckedCreateWithoutGameInput[]
    connectOrCreate?: BetMarketCreateOrConnectWithoutGameInput | BetMarketCreateOrConnectWithoutGameInput[]
    upsert?: BetMarketUpsertWithWhereUniqueWithoutGameInput | BetMarketUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: BetMarketCreateManyGameInputEnvelope
    set?: BetMarketWhereUniqueInput | BetMarketWhereUniqueInput[]
    disconnect?: BetMarketWhereUniqueInput | BetMarketWhereUniqueInput[]
    delete?: BetMarketWhereUniqueInput | BetMarketWhereUniqueInput[]
    connect?: BetMarketWhereUniqueInput | BetMarketWhereUniqueInput[]
    update?: BetMarketUpdateWithWhereUniqueWithoutGameInput | BetMarketUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: BetMarketUpdateManyWithWhereWithoutGameInput | BetMarketUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: BetMarketScalarWhereInput | BetMarketScalarWhereInput[]
  }

  export type OddsSyncStatusUpdateOneWithoutGameNestedInput = {
    create?: XOR<OddsSyncStatusCreateWithoutGameInput, OddsSyncStatusUncheckedCreateWithoutGameInput>
    connectOrCreate?: OddsSyncStatusCreateOrConnectWithoutGameInput
    upsert?: OddsSyncStatusUpsertWithoutGameInput
    disconnect?: OddsSyncStatusWhereInput | boolean
    delete?: OddsSyncStatusWhereInput | boolean
    connect?: OddsSyncStatusWhereUniqueInput
    update?: XOR<XOR<OddsSyncStatusUpdateToOneWithWhereWithoutGameInput, OddsSyncStatusUpdateWithoutGameInput>, OddsSyncStatusUncheckedUpdateWithoutGameInput>
  }

  export type BetMarketUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<BetMarketCreateWithoutGameInput, BetMarketUncheckedCreateWithoutGameInput> | BetMarketCreateWithoutGameInput[] | BetMarketUncheckedCreateWithoutGameInput[]
    connectOrCreate?: BetMarketCreateOrConnectWithoutGameInput | BetMarketCreateOrConnectWithoutGameInput[]
    upsert?: BetMarketUpsertWithWhereUniqueWithoutGameInput | BetMarketUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: BetMarketCreateManyGameInputEnvelope
    set?: BetMarketWhereUniqueInput | BetMarketWhereUniqueInput[]
    disconnect?: BetMarketWhereUniqueInput | BetMarketWhereUniqueInput[]
    delete?: BetMarketWhereUniqueInput | BetMarketWhereUniqueInput[]
    connect?: BetMarketWhereUniqueInput | BetMarketWhereUniqueInput[]
    update?: BetMarketUpdateWithWhereUniqueWithoutGameInput | BetMarketUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: BetMarketUpdateManyWithWhereWithoutGameInput | BetMarketUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: BetMarketScalarWhereInput | BetMarketScalarWhereInput[]
  }

  export type OddsSyncStatusUncheckedUpdateOneWithoutGameNestedInput = {
    create?: XOR<OddsSyncStatusCreateWithoutGameInput, OddsSyncStatusUncheckedCreateWithoutGameInput>
    connectOrCreate?: OddsSyncStatusCreateOrConnectWithoutGameInput
    upsert?: OddsSyncStatusUpsertWithoutGameInput
    disconnect?: OddsSyncStatusWhereInput | boolean
    delete?: OddsSyncStatusWhereInput | boolean
    connect?: OddsSyncStatusWhereUniqueInput
    update?: XOR<XOR<OddsSyncStatusUpdateToOneWithWhereWithoutGameInput, OddsSyncStatusUpdateWithoutGameInput>, OddsSyncStatusUncheckedUpdateWithoutGameInput>
  }

  export type GameCreateNestedOneWithoutMarketsInput = {
    create?: XOR<GameCreateWithoutMarketsInput, GameUncheckedCreateWithoutMarketsInput>
    connectOrCreate?: GameCreateOrConnectWithoutMarketsInput
    connect?: GameWhereUniqueInput
  }

  export type BetSelectionCreateNestedManyWithoutMarketInput = {
    create?: XOR<BetSelectionCreateWithoutMarketInput, BetSelectionUncheckedCreateWithoutMarketInput> | BetSelectionCreateWithoutMarketInput[] | BetSelectionUncheckedCreateWithoutMarketInput[]
    connectOrCreate?: BetSelectionCreateOrConnectWithoutMarketInput | BetSelectionCreateOrConnectWithoutMarketInput[]
    createMany?: BetSelectionCreateManyMarketInputEnvelope
    connect?: BetSelectionWhereUniqueInput | BetSelectionWhereUniqueInput[]
  }

  export type BetSelectionUncheckedCreateNestedManyWithoutMarketInput = {
    create?: XOR<BetSelectionCreateWithoutMarketInput, BetSelectionUncheckedCreateWithoutMarketInput> | BetSelectionCreateWithoutMarketInput[] | BetSelectionUncheckedCreateWithoutMarketInput[]
    connectOrCreate?: BetSelectionCreateOrConnectWithoutMarketInput | BetSelectionCreateOrConnectWithoutMarketInput[]
    createMany?: BetSelectionCreateManyMarketInputEnvelope
    connect?: BetSelectionWhereUniqueInput | BetSelectionWhereUniqueInput[]
  }

  export type GameUpdateOneRequiredWithoutMarketsNestedInput = {
    create?: XOR<GameCreateWithoutMarketsInput, GameUncheckedCreateWithoutMarketsInput>
    connectOrCreate?: GameCreateOrConnectWithoutMarketsInput
    upsert?: GameUpsertWithoutMarketsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutMarketsInput, GameUpdateWithoutMarketsInput>, GameUncheckedUpdateWithoutMarketsInput>
  }

  export type BetSelectionUpdateManyWithoutMarketNestedInput = {
    create?: XOR<BetSelectionCreateWithoutMarketInput, BetSelectionUncheckedCreateWithoutMarketInput> | BetSelectionCreateWithoutMarketInput[] | BetSelectionUncheckedCreateWithoutMarketInput[]
    connectOrCreate?: BetSelectionCreateOrConnectWithoutMarketInput | BetSelectionCreateOrConnectWithoutMarketInput[]
    upsert?: BetSelectionUpsertWithWhereUniqueWithoutMarketInput | BetSelectionUpsertWithWhereUniqueWithoutMarketInput[]
    createMany?: BetSelectionCreateManyMarketInputEnvelope
    set?: BetSelectionWhereUniqueInput | BetSelectionWhereUniqueInput[]
    disconnect?: BetSelectionWhereUniqueInput | BetSelectionWhereUniqueInput[]
    delete?: BetSelectionWhereUniqueInput | BetSelectionWhereUniqueInput[]
    connect?: BetSelectionWhereUniqueInput | BetSelectionWhereUniqueInput[]
    update?: BetSelectionUpdateWithWhereUniqueWithoutMarketInput | BetSelectionUpdateWithWhereUniqueWithoutMarketInput[]
    updateMany?: BetSelectionUpdateManyWithWhereWithoutMarketInput | BetSelectionUpdateManyWithWhereWithoutMarketInput[]
    deleteMany?: BetSelectionScalarWhereInput | BetSelectionScalarWhereInput[]
  }

  export type BetSelectionUncheckedUpdateManyWithoutMarketNestedInput = {
    create?: XOR<BetSelectionCreateWithoutMarketInput, BetSelectionUncheckedCreateWithoutMarketInput> | BetSelectionCreateWithoutMarketInput[] | BetSelectionUncheckedCreateWithoutMarketInput[]
    connectOrCreate?: BetSelectionCreateOrConnectWithoutMarketInput | BetSelectionCreateOrConnectWithoutMarketInput[]
    upsert?: BetSelectionUpsertWithWhereUniqueWithoutMarketInput | BetSelectionUpsertWithWhereUniqueWithoutMarketInput[]
    createMany?: BetSelectionCreateManyMarketInputEnvelope
    set?: BetSelectionWhereUniqueInput | BetSelectionWhereUniqueInput[]
    disconnect?: BetSelectionWhereUniqueInput | BetSelectionWhereUniqueInput[]
    delete?: BetSelectionWhereUniqueInput | BetSelectionWhereUniqueInput[]
    connect?: BetSelectionWhereUniqueInput | BetSelectionWhereUniqueInput[]
    update?: BetSelectionUpdateWithWhereUniqueWithoutMarketInput | BetSelectionUpdateWithWhereUniqueWithoutMarketInput[]
    updateMany?: BetSelectionUpdateManyWithWhereWithoutMarketInput | BetSelectionUpdateManyWithWhereWithoutMarketInput[]
    deleteMany?: BetSelectionScalarWhereInput | BetSelectionScalarWhereInput[]
  }

  export type BetMarketCreateNestedOneWithoutSelectionsInput = {
    create?: XOR<BetMarketCreateWithoutSelectionsInput, BetMarketUncheckedCreateWithoutSelectionsInput>
    connectOrCreate?: BetMarketCreateOrConnectWithoutSelectionsInput
    connect?: BetMarketWhereUniqueInput
  }

  export type BetSelectionBetCreateNestedManyWithoutSelectionInput = {
    create?: XOR<BetSelectionBetCreateWithoutSelectionInput, BetSelectionBetUncheckedCreateWithoutSelectionInput> | BetSelectionBetCreateWithoutSelectionInput[] | BetSelectionBetUncheckedCreateWithoutSelectionInput[]
    connectOrCreate?: BetSelectionBetCreateOrConnectWithoutSelectionInput | BetSelectionBetCreateOrConnectWithoutSelectionInput[]
    createMany?: BetSelectionBetCreateManySelectionInputEnvelope
    connect?: BetSelectionBetWhereUniqueInput | BetSelectionBetWhereUniqueInput[]
  }

  export type CurrentOddsCreateNestedOneWithoutSelectionInput = {
    create?: XOR<CurrentOddsCreateWithoutSelectionInput, CurrentOddsUncheckedCreateWithoutSelectionInput>
    connectOrCreate?: CurrentOddsCreateOrConnectWithoutSelectionInput
    connect?: CurrentOddsWhereUniqueInput
  }

  export type OddsSnapshotCreateNestedManyWithoutSelectionInput = {
    create?: XOR<OddsSnapshotCreateWithoutSelectionInput, OddsSnapshotUncheckedCreateWithoutSelectionInput> | OddsSnapshotCreateWithoutSelectionInput[] | OddsSnapshotUncheckedCreateWithoutSelectionInput[]
    connectOrCreate?: OddsSnapshotCreateOrConnectWithoutSelectionInput | OddsSnapshotCreateOrConnectWithoutSelectionInput[]
    createMany?: OddsSnapshotCreateManySelectionInputEnvelope
    connect?: OddsSnapshotWhereUniqueInput | OddsSnapshotWhereUniqueInput[]
  }

  export type BetSelectionBetUncheckedCreateNestedManyWithoutSelectionInput = {
    create?: XOR<BetSelectionBetCreateWithoutSelectionInput, BetSelectionBetUncheckedCreateWithoutSelectionInput> | BetSelectionBetCreateWithoutSelectionInput[] | BetSelectionBetUncheckedCreateWithoutSelectionInput[]
    connectOrCreate?: BetSelectionBetCreateOrConnectWithoutSelectionInput | BetSelectionBetCreateOrConnectWithoutSelectionInput[]
    createMany?: BetSelectionBetCreateManySelectionInputEnvelope
    connect?: BetSelectionBetWhereUniqueInput | BetSelectionBetWhereUniqueInput[]
  }

  export type CurrentOddsUncheckedCreateNestedOneWithoutSelectionInput = {
    create?: XOR<CurrentOddsCreateWithoutSelectionInput, CurrentOddsUncheckedCreateWithoutSelectionInput>
    connectOrCreate?: CurrentOddsCreateOrConnectWithoutSelectionInput
    connect?: CurrentOddsWhereUniqueInput
  }

  export type OddsSnapshotUncheckedCreateNestedManyWithoutSelectionInput = {
    create?: XOR<OddsSnapshotCreateWithoutSelectionInput, OddsSnapshotUncheckedCreateWithoutSelectionInput> | OddsSnapshotCreateWithoutSelectionInput[] | OddsSnapshotUncheckedCreateWithoutSelectionInput[]
    connectOrCreate?: OddsSnapshotCreateOrConnectWithoutSelectionInput | OddsSnapshotCreateOrConnectWithoutSelectionInput[]
    createMany?: OddsSnapshotCreateManySelectionInputEnvelope
    connect?: OddsSnapshotWhereUniqueInput | OddsSnapshotWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BetMarketUpdateOneRequiredWithoutSelectionsNestedInput = {
    create?: XOR<BetMarketCreateWithoutSelectionsInput, BetMarketUncheckedCreateWithoutSelectionsInput>
    connectOrCreate?: BetMarketCreateOrConnectWithoutSelectionsInput
    upsert?: BetMarketUpsertWithoutSelectionsInput
    connect?: BetMarketWhereUniqueInput
    update?: XOR<XOR<BetMarketUpdateToOneWithWhereWithoutSelectionsInput, BetMarketUpdateWithoutSelectionsInput>, BetMarketUncheckedUpdateWithoutSelectionsInput>
  }

  export type BetSelectionBetUpdateManyWithoutSelectionNestedInput = {
    create?: XOR<BetSelectionBetCreateWithoutSelectionInput, BetSelectionBetUncheckedCreateWithoutSelectionInput> | BetSelectionBetCreateWithoutSelectionInput[] | BetSelectionBetUncheckedCreateWithoutSelectionInput[]
    connectOrCreate?: BetSelectionBetCreateOrConnectWithoutSelectionInput | BetSelectionBetCreateOrConnectWithoutSelectionInput[]
    upsert?: BetSelectionBetUpsertWithWhereUniqueWithoutSelectionInput | BetSelectionBetUpsertWithWhereUniqueWithoutSelectionInput[]
    createMany?: BetSelectionBetCreateManySelectionInputEnvelope
    set?: BetSelectionBetWhereUniqueInput | BetSelectionBetWhereUniqueInput[]
    disconnect?: BetSelectionBetWhereUniqueInput | BetSelectionBetWhereUniqueInput[]
    delete?: BetSelectionBetWhereUniqueInput | BetSelectionBetWhereUniqueInput[]
    connect?: BetSelectionBetWhereUniqueInput | BetSelectionBetWhereUniqueInput[]
    update?: BetSelectionBetUpdateWithWhereUniqueWithoutSelectionInput | BetSelectionBetUpdateWithWhereUniqueWithoutSelectionInput[]
    updateMany?: BetSelectionBetUpdateManyWithWhereWithoutSelectionInput | BetSelectionBetUpdateManyWithWhereWithoutSelectionInput[]
    deleteMany?: BetSelectionBetScalarWhereInput | BetSelectionBetScalarWhereInput[]
  }

  export type CurrentOddsUpdateOneWithoutSelectionNestedInput = {
    create?: XOR<CurrentOddsCreateWithoutSelectionInput, CurrentOddsUncheckedCreateWithoutSelectionInput>
    connectOrCreate?: CurrentOddsCreateOrConnectWithoutSelectionInput
    upsert?: CurrentOddsUpsertWithoutSelectionInput
    disconnect?: CurrentOddsWhereInput | boolean
    delete?: CurrentOddsWhereInput | boolean
    connect?: CurrentOddsWhereUniqueInput
    update?: XOR<XOR<CurrentOddsUpdateToOneWithWhereWithoutSelectionInput, CurrentOddsUpdateWithoutSelectionInput>, CurrentOddsUncheckedUpdateWithoutSelectionInput>
  }

  export type OddsSnapshotUpdateManyWithoutSelectionNestedInput = {
    create?: XOR<OddsSnapshotCreateWithoutSelectionInput, OddsSnapshotUncheckedCreateWithoutSelectionInput> | OddsSnapshotCreateWithoutSelectionInput[] | OddsSnapshotUncheckedCreateWithoutSelectionInput[]
    connectOrCreate?: OddsSnapshotCreateOrConnectWithoutSelectionInput | OddsSnapshotCreateOrConnectWithoutSelectionInput[]
    upsert?: OddsSnapshotUpsertWithWhereUniqueWithoutSelectionInput | OddsSnapshotUpsertWithWhereUniqueWithoutSelectionInput[]
    createMany?: OddsSnapshotCreateManySelectionInputEnvelope
    set?: OddsSnapshotWhereUniqueInput | OddsSnapshotWhereUniqueInput[]
    disconnect?: OddsSnapshotWhereUniqueInput | OddsSnapshotWhereUniqueInput[]
    delete?: OddsSnapshotWhereUniqueInput | OddsSnapshotWhereUniqueInput[]
    connect?: OddsSnapshotWhereUniqueInput | OddsSnapshotWhereUniqueInput[]
    update?: OddsSnapshotUpdateWithWhereUniqueWithoutSelectionInput | OddsSnapshotUpdateWithWhereUniqueWithoutSelectionInput[]
    updateMany?: OddsSnapshotUpdateManyWithWhereWithoutSelectionInput | OddsSnapshotUpdateManyWithWhereWithoutSelectionInput[]
    deleteMany?: OddsSnapshotScalarWhereInput | OddsSnapshotScalarWhereInput[]
  }

  export type BetSelectionBetUncheckedUpdateManyWithoutSelectionNestedInput = {
    create?: XOR<BetSelectionBetCreateWithoutSelectionInput, BetSelectionBetUncheckedCreateWithoutSelectionInput> | BetSelectionBetCreateWithoutSelectionInput[] | BetSelectionBetUncheckedCreateWithoutSelectionInput[]
    connectOrCreate?: BetSelectionBetCreateOrConnectWithoutSelectionInput | BetSelectionBetCreateOrConnectWithoutSelectionInput[]
    upsert?: BetSelectionBetUpsertWithWhereUniqueWithoutSelectionInput | BetSelectionBetUpsertWithWhereUniqueWithoutSelectionInput[]
    createMany?: BetSelectionBetCreateManySelectionInputEnvelope
    set?: BetSelectionBetWhereUniqueInput | BetSelectionBetWhereUniqueInput[]
    disconnect?: BetSelectionBetWhereUniqueInput | BetSelectionBetWhereUniqueInput[]
    delete?: BetSelectionBetWhereUniqueInput | BetSelectionBetWhereUniqueInput[]
    connect?: BetSelectionBetWhereUniqueInput | BetSelectionBetWhereUniqueInput[]
    update?: BetSelectionBetUpdateWithWhereUniqueWithoutSelectionInput | BetSelectionBetUpdateWithWhereUniqueWithoutSelectionInput[]
    updateMany?: BetSelectionBetUpdateManyWithWhereWithoutSelectionInput | BetSelectionBetUpdateManyWithWhereWithoutSelectionInput[]
    deleteMany?: BetSelectionBetScalarWhereInput | BetSelectionBetScalarWhereInput[]
  }

  export type CurrentOddsUncheckedUpdateOneWithoutSelectionNestedInput = {
    create?: XOR<CurrentOddsCreateWithoutSelectionInput, CurrentOddsUncheckedCreateWithoutSelectionInput>
    connectOrCreate?: CurrentOddsCreateOrConnectWithoutSelectionInput
    upsert?: CurrentOddsUpsertWithoutSelectionInput
    disconnect?: CurrentOddsWhereInput | boolean
    delete?: CurrentOddsWhereInput | boolean
    connect?: CurrentOddsWhereUniqueInput
    update?: XOR<XOR<CurrentOddsUpdateToOneWithWhereWithoutSelectionInput, CurrentOddsUpdateWithoutSelectionInput>, CurrentOddsUncheckedUpdateWithoutSelectionInput>
  }

  export type OddsSnapshotUncheckedUpdateManyWithoutSelectionNestedInput = {
    create?: XOR<OddsSnapshotCreateWithoutSelectionInput, OddsSnapshotUncheckedCreateWithoutSelectionInput> | OddsSnapshotCreateWithoutSelectionInput[] | OddsSnapshotUncheckedCreateWithoutSelectionInput[]
    connectOrCreate?: OddsSnapshotCreateOrConnectWithoutSelectionInput | OddsSnapshotCreateOrConnectWithoutSelectionInput[]
    upsert?: OddsSnapshotUpsertWithWhereUniqueWithoutSelectionInput | OddsSnapshotUpsertWithWhereUniqueWithoutSelectionInput[]
    createMany?: OddsSnapshotCreateManySelectionInputEnvelope
    set?: OddsSnapshotWhereUniqueInput | OddsSnapshotWhereUniqueInput[]
    disconnect?: OddsSnapshotWhereUniqueInput | OddsSnapshotWhereUniqueInput[]
    delete?: OddsSnapshotWhereUniqueInput | OddsSnapshotWhereUniqueInput[]
    connect?: OddsSnapshotWhereUniqueInput | OddsSnapshotWhereUniqueInput[]
    update?: OddsSnapshotUpdateWithWhereUniqueWithoutSelectionInput | OddsSnapshotUpdateWithWhereUniqueWithoutSelectionInput[]
    updateMany?: OddsSnapshotUpdateManyWithWhereWithoutSelectionInput | OddsSnapshotUpdateManyWithWhereWithoutSelectionInput[]
    deleteMany?: OddsSnapshotScalarWhereInput | OddsSnapshotScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBetsInput = {
    create?: XOR<UserCreateWithoutBetsInput, UserUncheckedCreateWithoutBetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBetsInput
    connect?: UserWhereUniqueInput
  }

  export type BetSelectionBetCreateNestedManyWithoutBetInput = {
    create?: XOR<BetSelectionBetCreateWithoutBetInput, BetSelectionBetUncheckedCreateWithoutBetInput> | BetSelectionBetCreateWithoutBetInput[] | BetSelectionBetUncheckedCreateWithoutBetInput[]
    connectOrCreate?: BetSelectionBetCreateOrConnectWithoutBetInput | BetSelectionBetCreateOrConnectWithoutBetInput[]
    createMany?: BetSelectionBetCreateManyBetInputEnvelope
    connect?: BetSelectionBetWhereUniqueInput | BetSelectionBetWhereUniqueInput[]
  }

  export type BetSelectionBetUncheckedCreateNestedManyWithoutBetInput = {
    create?: XOR<BetSelectionBetCreateWithoutBetInput, BetSelectionBetUncheckedCreateWithoutBetInput> | BetSelectionBetCreateWithoutBetInput[] | BetSelectionBetUncheckedCreateWithoutBetInput[]
    connectOrCreate?: BetSelectionBetCreateOrConnectWithoutBetInput | BetSelectionBetCreateOrConnectWithoutBetInput[]
    createMany?: BetSelectionBetCreateManyBetInputEnvelope
    connect?: BetSelectionBetWhereUniqueInput | BetSelectionBetWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutBetsNestedInput = {
    create?: XOR<UserCreateWithoutBetsInput, UserUncheckedCreateWithoutBetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBetsInput
    upsert?: UserUpsertWithoutBetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBetsInput, UserUpdateWithoutBetsInput>, UserUncheckedUpdateWithoutBetsInput>
  }

  export type BetSelectionBetUpdateManyWithoutBetNestedInput = {
    create?: XOR<BetSelectionBetCreateWithoutBetInput, BetSelectionBetUncheckedCreateWithoutBetInput> | BetSelectionBetCreateWithoutBetInput[] | BetSelectionBetUncheckedCreateWithoutBetInput[]
    connectOrCreate?: BetSelectionBetCreateOrConnectWithoutBetInput | BetSelectionBetCreateOrConnectWithoutBetInput[]
    upsert?: BetSelectionBetUpsertWithWhereUniqueWithoutBetInput | BetSelectionBetUpsertWithWhereUniqueWithoutBetInput[]
    createMany?: BetSelectionBetCreateManyBetInputEnvelope
    set?: BetSelectionBetWhereUniqueInput | BetSelectionBetWhereUniqueInput[]
    disconnect?: BetSelectionBetWhereUniqueInput | BetSelectionBetWhereUniqueInput[]
    delete?: BetSelectionBetWhereUniqueInput | BetSelectionBetWhereUniqueInput[]
    connect?: BetSelectionBetWhereUniqueInput | BetSelectionBetWhereUniqueInput[]
    update?: BetSelectionBetUpdateWithWhereUniqueWithoutBetInput | BetSelectionBetUpdateWithWhereUniqueWithoutBetInput[]
    updateMany?: BetSelectionBetUpdateManyWithWhereWithoutBetInput | BetSelectionBetUpdateManyWithWhereWithoutBetInput[]
    deleteMany?: BetSelectionBetScalarWhereInput | BetSelectionBetScalarWhereInput[]
  }

  export type BetSelectionBetUncheckedUpdateManyWithoutBetNestedInput = {
    create?: XOR<BetSelectionBetCreateWithoutBetInput, BetSelectionBetUncheckedCreateWithoutBetInput> | BetSelectionBetCreateWithoutBetInput[] | BetSelectionBetUncheckedCreateWithoutBetInput[]
    connectOrCreate?: BetSelectionBetCreateOrConnectWithoutBetInput | BetSelectionBetCreateOrConnectWithoutBetInput[]
    upsert?: BetSelectionBetUpsertWithWhereUniqueWithoutBetInput | BetSelectionBetUpsertWithWhereUniqueWithoutBetInput[]
    createMany?: BetSelectionBetCreateManyBetInputEnvelope
    set?: BetSelectionBetWhereUniqueInput | BetSelectionBetWhereUniqueInput[]
    disconnect?: BetSelectionBetWhereUniqueInput | BetSelectionBetWhereUniqueInput[]
    delete?: BetSelectionBetWhereUniqueInput | BetSelectionBetWhereUniqueInput[]
    connect?: BetSelectionBetWhereUniqueInput | BetSelectionBetWhereUniqueInput[]
    update?: BetSelectionBetUpdateWithWhereUniqueWithoutBetInput | BetSelectionBetUpdateWithWhereUniqueWithoutBetInput[]
    updateMany?: BetSelectionBetUpdateManyWithWhereWithoutBetInput | BetSelectionBetUpdateManyWithWhereWithoutBetInput[]
    deleteMany?: BetSelectionBetScalarWhereInput | BetSelectionBetScalarWhereInput[]
  }

  export type BetCreateNestedOneWithoutSelectionsInput = {
    create?: XOR<BetCreateWithoutSelectionsInput, BetUncheckedCreateWithoutSelectionsInput>
    connectOrCreate?: BetCreateOrConnectWithoutSelectionsInput
    connect?: BetWhereUniqueInput
  }

  export type BetSelectionCreateNestedOneWithoutBetSelectionsInput = {
    create?: XOR<BetSelectionCreateWithoutBetSelectionsInput, BetSelectionUncheckedCreateWithoutBetSelectionsInput>
    connectOrCreate?: BetSelectionCreateOrConnectWithoutBetSelectionsInput
    connect?: BetSelectionWhereUniqueInput
  }

  export type BetUpdateOneRequiredWithoutSelectionsNestedInput = {
    create?: XOR<BetCreateWithoutSelectionsInput, BetUncheckedCreateWithoutSelectionsInput>
    connectOrCreate?: BetCreateOrConnectWithoutSelectionsInput
    upsert?: BetUpsertWithoutSelectionsInput
    connect?: BetWhereUniqueInput
    update?: XOR<XOR<BetUpdateToOneWithWhereWithoutSelectionsInput, BetUpdateWithoutSelectionsInput>, BetUncheckedUpdateWithoutSelectionsInput>
  }

  export type BetSelectionUpdateOneRequiredWithoutBetSelectionsNestedInput = {
    create?: XOR<BetSelectionCreateWithoutBetSelectionsInput, BetSelectionUncheckedCreateWithoutBetSelectionsInput>
    connectOrCreate?: BetSelectionCreateOrConnectWithoutBetSelectionsInput
    upsert?: BetSelectionUpsertWithoutBetSelectionsInput
    connect?: BetSelectionWhereUniqueInput
    update?: XOR<XOR<BetSelectionUpdateToOneWithWhereWithoutBetSelectionsInput, BetSelectionUpdateWithoutBetSelectionsInput>, BetSelectionUncheckedUpdateWithoutBetSelectionsInput>
  }

  export type UserCreateNestedOneWithoutFinancialAccountsInput = {
    create?: XOR<UserCreateWithoutFinancialAccountsInput, UserUncheckedCreateWithoutFinancialAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFinancialAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutAccountInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutFinancialAccountsNestedInput = {
    create?: XOR<UserCreateWithoutFinancialAccountsInput, UserUncheckedCreateWithoutFinancialAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFinancialAccountsInput
    upsert?: UserUpsertWithoutFinancialAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFinancialAccountsInput, UserUpdateWithoutFinancialAccountsInput>, UserUncheckedUpdateWithoutFinancialAccountsInput>
  }

  export type TransactionUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutAccountInput | TransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutAccountInput | TransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutAccountInput | TransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutAccountInput | TransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutAccountInput | TransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutAccountInput | TransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type FinancialAccountCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<FinancialAccountCreateWithoutTransactionsInput, FinancialAccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: FinancialAccountCreateOrConnectWithoutTransactionsInput
    connect?: FinancialAccountWhereUniqueInput
  }

  export type PaymentMethodCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<PaymentMethodCreateWithoutTransactionsInput, PaymentMethodUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutTransactionsInput
    connect?: PaymentMethodWhereUniqueInput
  }

  export type DepositCreateNestedOneWithoutTransactionInput = {
    create?: XOR<DepositCreateWithoutTransactionInput, DepositUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: DepositCreateOrConnectWithoutTransactionInput
    connect?: DepositWhereUniqueInput
  }

  export type WithdrawalCreateNestedOneWithoutTransactionInput = {
    create?: XOR<WithdrawalCreateWithoutTransactionInput, WithdrawalUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: WithdrawalCreateOrConnectWithoutTransactionInput
    connect?: WithdrawalWhereUniqueInput
  }

  export type DepositUncheckedCreateNestedOneWithoutTransactionInput = {
    create?: XOR<DepositCreateWithoutTransactionInput, DepositUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: DepositCreateOrConnectWithoutTransactionInput
    connect?: DepositWhereUniqueInput
  }

  export type WithdrawalUncheckedCreateNestedOneWithoutTransactionInput = {
    create?: XOR<WithdrawalCreateWithoutTransactionInput, WithdrawalUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: WithdrawalCreateOrConnectWithoutTransactionInput
    connect?: WithdrawalWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type FinancialAccountUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<FinancialAccountCreateWithoutTransactionsInput, FinancialAccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: FinancialAccountCreateOrConnectWithoutTransactionsInput
    upsert?: FinancialAccountUpsertWithoutTransactionsInput
    connect?: FinancialAccountWhereUniqueInput
    update?: XOR<XOR<FinancialAccountUpdateToOneWithWhereWithoutTransactionsInput, FinancialAccountUpdateWithoutTransactionsInput>, FinancialAccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type PaymentMethodUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutTransactionsInput, PaymentMethodUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutTransactionsInput
    upsert?: PaymentMethodUpsertWithoutTransactionsInput
    disconnect?: PaymentMethodWhereInput | boolean
    delete?: PaymentMethodWhereInput | boolean
    connect?: PaymentMethodWhereUniqueInput
    update?: XOR<XOR<PaymentMethodUpdateToOneWithWhereWithoutTransactionsInput, PaymentMethodUpdateWithoutTransactionsInput>, PaymentMethodUncheckedUpdateWithoutTransactionsInput>
  }

  export type DepositUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<DepositCreateWithoutTransactionInput, DepositUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: DepositCreateOrConnectWithoutTransactionInput
    upsert?: DepositUpsertWithoutTransactionInput
    disconnect?: DepositWhereInput | boolean
    delete?: DepositWhereInput | boolean
    connect?: DepositWhereUniqueInput
    update?: XOR<XOR<DepositUpdateToOneWithWhereWithoutTransactionInput, DepositUpdateWithoutTransactionInput>, DepositUncheckedUpdateWithoutTransactionInput>
  }

  export type WithdrawalUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<WithdrawalCreateWithoutTransactionInput, WithdrawalUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: WithdrawalCreateOrConnectWithoutTransactionInput
    upsert?: WithdrawalUpsertWithoutTransactionInput
    disconnect?: WithdrawalWhereInput | boolean
    delete?: WithdrawalWhereInput | boolean
    connect?: WithdrawalWhereUniqueInput
    update?: XOR<XOR<WithdrawalUpdateToOneWithWhereWithoutTransactionInput, WithdrawalUpdateWithoutTransactionInput>, WithdrawalUncheckedUpdateWithoutTransactionInput>
  }

  export type DepositUncheckedUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<DepositCreateWithoutTransactionInput, DepositUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: DepositCreateOrConnectWithoutTransactionInput
    upsert?: DepositUpsertWithoutTransactionInput
    disconnect?: DepositWhereInput | boolean
    delete?: DepositWhereInput | boolean
    connect?: DepositWhereUniqueInput
    update?: XOR<XOR<DepositUpdateToOneWithWhereWithoutTransactionInput, DepositUpdateWithoutTransactionInput>, DepositUncheckedUpdateWithoutTransactionInput>
  }

  export type WithdrawalUncheckedUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<WithdrawalCreateWithoutTransactionInput, WithdrawalUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: WithdrawalCreateOrConnectWithoutTransactionInput
    upsert?: WithdrawalUpsertWithoutTransactionInput
    disconnect?: WithdrawalWhereInput | boolean
    delete?: WithdrawalWhereInput | boolean
    connect?: WithdrawalWhereUniqueInput
    update?: XOR<XOR<WithdrawalUpdateToOneWithWhereWithoutTransactionInput, WithdrawalUpdateWithoutTransactionInput>, WithdrawalUncheckedUpdateWithoutTransactionInput>
  }

  export type UserCreateNestedOneWithoutPaymentMethodsInput = {
    create?: XOR<UserCreateWithoutPaymentMethodsInput, UserUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentMethodsInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<TransactionCreateWithoutPaymentMethodInput, TransactionUncheckedCreateWithoutPaymentMethodInput> | TransactionCreateWithoutPaymentMethodInput[] | TransactionUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentMethodInput | TransactionCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: TransactionCreateManyPaymentMethodInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type DepositCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<DepositCreateWithoutPaymentMethodInput, DepositUncheckedCreateWithoutPaymentMethodInput> | DepositCreateWithoutPaymentMethodInput[] | DepositUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutPaymentMethodInput | DepositCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: DepositCreateManyPaymentMethodInputEnvelope
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
  }

  export type WithdrawalCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<WithdrawalCreateWithoutPaymentMethodInput, WithdrawalUncheckedCreateWithoutPaymentMethodInput> | WithdrawalCreateWithoutPaymentMethodInput[] | WithdrawalUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: WithdrawalCreateOrConnectWithoutPaymentMethodInput | WithdrawalCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: WithdrawalCreateManyPaymentMethodInputEnvelope
    connect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<TransactionCreateWithoutPaymentMethodInput, TransactionUncheckedCreateWithoutPaymentMethodInput> | TransactionCreateWithoutPaymentMethodInput[] | TransactionUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentMethodInput | TransactionCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: TransactionCreateManyPaymentMethodInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type DepositUncheckedCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<DepositCreateWithoutPaymentMethodInput, DepositUncheckedCreateWithoutPaymentMethodInput> | DepositCreateWithoutPaymentMethodInput[] | DepositUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutPaymentMethodInput | DepositCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: DepositCreateManyPaymentMethodInputEnvelope
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
  }

  export type WithdrawalUncheckedCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<WithdrawalCreateWithoutPaymentMethodInput, WithdrawalUncheckedCreateWithoutPaymentMethodInput> | WithdrawalCreateWithoutPaymentMethodInput[] | WithdrawalUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: WithdrawalCreateOrConnectWithoutPaymentMethodInput | WithdrawalCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: WithdrawalCreateManyPaymentMethodInputEnvelope
    connect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPaymentMethodsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentMethodsInput, UserUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentMethodsInput
    upsert?: UserUpsertWithoutPaymentMethodsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentMethodsInput, UserUpdateWithoutPaymentMethodsInput>, UserUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type TransactionUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<TransactionCreateWithoutPaymentMethodInput, TransactionUncheckedCreateWithoutPaymentMethodInput> | TransactionCreateWithoutPaymentMethodInput[] | TransactionUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentMethodInput | TransactionCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutPaymentMethodInput | TransactionUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: TransactionCreateManyPaymentMethodInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutPaymentMethodInput | TransactionUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutPaymentMethodInput | TransactionUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type DepositUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<DepositCreateWithoutPaymentMethodInput, DepositUncheckedCreateWithoutPaymentMethodInput> | DepositCreateWithoutPaymentMethodInput[] | DepositUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutPaymentMethodInput | DepositCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: DepositUpsertWithWhereUniqueWithoutPaymentMethodInput | DepositUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: DepositCreateManyPaymentMethodInputEnvelope
    set?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    disconnect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    delete?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    update?: DepositUpdateWithWhereUniqueWithoutPaymentMethodInput | DepositUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: DepositUpdateManyWithWhereWithoutPaymentMethodInput | DepositUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: DepositScalarWhereInput | DepositScalarWhereInput[]
  }

  export type WithdrawalUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<WithdrawalCreateWithoutPaymentMethodInput, WithdrawalUncheckedCreateWithoutPaymentMethodInput> | WithdrawalCreateWithoutPaymentMethodInput[] | WithdrawalUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: WithdrawalCreateOrConnectWithoutPaymentMethodInput | WithdrawalCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: WithdrawalUpsertWithWhereUniqueWithoutPaymentMethodInput | WithdrawalUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: WithdrawalCreateManyPaymentMethodInputEnvelope
    set?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    disconnect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    delete?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    connect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    update?: WithdrawalUpdateWithWhereUniqueWithoutPaymentMethodInput | WithdrawalUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: WithdrawalUpdateManyWithWhereWithoutPaymentMethodInput | WithdrawalUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: WithdrawalScalarWhereInput | WithdrawalScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<TransactionCreateWithoutPaymentMethodInput, TransactionUncheckedCreateWithoutPaymentMethodInput> | TransactionCreateWithoutPaymentMethodInput[] | TransactionUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentMethodInput | TransactionCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutPaymentMethodInput | TransactionUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: TransactionCreateManyPaymentMethodInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutPaymentMethodInput | TransactionUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutPaymentMethodInput | TransactionUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type DepositUncheckedUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<DepositCreateWithoutPaymentMethodInput, DepositUncheckedCreateWithoutPaymentMethodInput> | DepositCreateWithoutPaymentMethodInput[] | DepositUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutPaymentMethodInput | DepositCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: DepositUpsertWithWhereUniqueWithoutPaymentMethodInput | DepositUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: DepositCreateManyPaymentMethodInputEnvelope
    set?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    disconnect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    delete?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    update?: DepositUpdateWithWhereUniqueWithoutPaymentMethodInput | DepositUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: DepositUpdateManyWithWhereWithoutPaymentMethodInput | DepositUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: DepositScalarWhereInput | DepositScalarWhereInput[]
  }

  export type WithdrawalUncheckedUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<WithdrawalCreateWithoutPaymentMethodInput, WithdrawalUncheckedCreateWithoutPaymentMethodInput> | WithdrawalCreateWithoutPaymentMethodInput[] | WithdrawalUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: WithdrawalCreateOrConnectWithoutPaymentMethodInput | WithdrawalCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: WithdrawalUpsertWithWhereUniqueWithoutPaymentMethodInput | WithdrawalUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: WithdrawalCreateManyPaymentMethodInputEnvelope
    set?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    disconnect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    delete?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    connect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    update?: WithdrawalUpdateWithWhereUniqueWithoutPaymentMethodInput | WithdrawalUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: WithdrawalUpdateManyWithWhereWithoutPaymentMethodInput | WithdrawalUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: WithdrawalScalarWhereInput | WithdrawalScalarWhereInput[]
  }

  export type TransactionCreateNestedOneWithoutDepositInput = {
    create?: XOR<TransactionCreateWithoutDepositInput, TransactionUncheckedCreateWithoutDepositInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutDepositInput
    connect?: TransactionWhereUniqueInput
  }

  export type PaymentMethodCreateNestedOneWithoutDepositsInput = {
    create?: XOR<PaymentMethodCreateWithoutDepositsInput, PaymentMethodUncheckedCreateWithoutDepositsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutDepositsInput
    connect?: PaymentMethodWhereUniqueInput
  }

  export type TransactionUpdateOneRequiredWithoutDepositNestedInput = {
    create?: XOR<TransactionCreateWithoutDepositInput, TransactionUncheckedCreateWithoutDepositInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutDepositInput
    upsert?: TransactionUpsertWithoutDepositInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutDepositInput, TransactionUpdateWithoutDepositInput>, TransactionUncheckedUpdateWithoutDepositInput>
  }

  export type PaymentMethodUpdateOneRequiredWithoutDepositsNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutDepositsInput, PaymentMethodUncheckedCreateWithoutDepositsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutDepositsInput
    upsert?: PaymentMethodUpsertWithoutDepositsInput
    connect?: PaymentMethodWhereUniqueInput
    update?: XOR<XOR<PaymentMethodUpdateToOneWithWhereWithoutDepositsInput, PaymentMethodUpdateWithoutDepositsInput>, PaymentMethodUncheckedUpdateWithoutDepositsInput>
  }

  export type TransactionCreateNestedOneWithoutWithdrawalInput = {
    create?: XOR<TransactionCreateWithoutWithdrawalInput, TransactionUncheckedCreateWithoutWithdrawalInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutWithdrawalInput
    connect?: TransactionWhereUniqueInput
  }

  export type PaymentMethodCreateNestedOneWithoutWithdrawalsInput = {
    create?: XOR<PaymentMethodCreateWithoutWithdrawalsInput, PaymentMethodUncheckedCreateWithoutWithdrawalsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutWithdrawalsInput
    connect?: PaymentMethodWhereUniqueInput
  }

  export type TransactionUpdateOneRequiredWithoutWithdrawalNestedInput = {
    create?: XOR<TransactionCreateWithoutWithdrawalInput, TransactionUncheckedCreateWithoutWithdrawalInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutWithdrawalInput
    upsert?: TransactionUpsertWithoutWithdrawalInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutWithdrawalInput, TransactionUpdateWithoutWithdrawalInput>, TransactionUncheckedUpdateWithoutWithdrawalInput>
  }

  export type PaymentMethodUpdateOneRequiredWithoutWithdrawalsNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutWithdrawalsInput, PaymentMethodUncheckedCreateWithoutWithdrawalsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutWithdrawalsInput
    upsert?: PaymentMethodUpsertWithoutWithdrawalsInput
    connect?: PaymentMethodWhereUniqueInput
    update?: XOR<XOR<PaymentMethodUpdateToOneWithWhereWithoutWithdrawalsInput, PaymentMethodUpdateWithoutWithdrawalsInput>, PaymentMethodUncheckedUpdateWithoutWithdrawalsInput>
  }

  export type UserCreateNestedOneWithoutFraudEventsInput = {
    create?: XOR<UserCreateWithoutFraudEventsInput, UserUncheckedCreateWithoutFraudEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFraudEventsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutFraudEventsNestedInput = {
    create?: XOR<UserCreateWithoutFraudEventsInput, UserUncheckedCreateWithoutFraudEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFraudEventsInput
    upsert?: UserUpsertWithoutFraudEventsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFraudEventsInput, UserUpdateWithoutFraudEventsInput>, UserUncheckedUpdateWithoutFraudEventsInput>
  }

  export type UserCreateNestedOneWithoutBettingPatternsInput = {
    create?: XOR<UserCreateWithoutBettingPatternsInput, UserUncheckedCreateWithoutBettingPatternsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBettingPatternsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBettingPatternsNestedInput = {
    create?: XOR<UserCreateWithoutBettingPatternsInput, UserUncheckedCreateWithoutBettingPatternsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBettingPatternsInput
    upsert?: UserUpsertWithoutBettingPatternsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBettingPatternsInput, UserUpdateWithoutBettingPatternsInput>, UserUncheckedUpdateWithoutBettingPatternsInput>
  }

  export type UserCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutActivityLogsNestedInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    upsert?: UserUpsertWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityLogsInput, UserUpdateWithoutActivityLogsInput>, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserCreateNestedOneWithoutDevicesInput = {
    create?: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevicesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDevicesNestedInput = {
    create?: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevicesInput
    upsert?: UserUpsertWithoutDevicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDevicesInput, UserUpdateWithoutDevicesInput>, UserUncheckedUpdateWithoutDevicesInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutConsentsInput = {
    create?: XOR<UserCreateWithoutConsentsInput, UserUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConsentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutConsentsNestedInput = {
    create?: XOR<UserCreateWithoutConsentsInput, UserUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConsentsInput
    upsert?: UserUpsertWithoutConsentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConsentsInput, UserUpdateWithoutConsentsInput>, UserUncheckedUpdateWithoutConsentsInput>
  }

  export type UserCreateNestedOneWithoutDeletionRequestsInput = {
    create?: XOR<UserCreateWithoutDeletionRequestsInput, UserUncheckedCreateWithoutDeletionRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeletionRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDeletionRequestsNestedInput = {
    create?: XOR<UserCreateWithoutDeletionRequestsInput, UserUncheckedCreateWithoutDeletionRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeletionRequestsInput
    upsert?: UserUpsertWithoutDeletionRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeletionRequestsInput, UserUpdateWithoutDeletionRequestsInput>, UserUncheckedUpdateWithoutDeletionRequestsInput>
  }

  export type UserCreateNestedOneWithoutExportRequestsInput = {
    create?: XOR<UserCreateWithoutExportRequestsInput, UserUncheckedCreateWithoutExportRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExportRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutExportRequestsNestedInput = {
    create?: XOR<UserCreateWithoutExportRequestsInput, UserUncheckedCreateWithoutExportRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExportRequestsInput
    upsert?: UserUpsertWithoutExportRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExportRequestsInput, UserUpdateWithoutExportRequestsInput>, UserUncheckedUpdateWithoutExportRequestsInput>
  }

  export type UserCreateNestedOneWithoutSecurityAlertsInput = {
    create?: XOR<UserCreateWithoutSecurityAlertsInput, UserUncheckedCreateWithoutSecurityAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSecurityAlertsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutSecurityAlertsNestedInput = {
    create?: XOR<UserCreateWithoutSecurityAlertsInput, UserUncheckedCreateWithoutSecurityAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSecurityAlertsInput
    upsert?: UserUpsertWithoutSecurityAlertsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSecurityAlertsInput, UserUpdateWithoutSecurityAlertsInput>, UserUncheckedUpdateWithoutSecurityAlertsInput>
  }

  export type UserBonusCreateNestedManyWithoutPromotionInput = {
    create?: XOR<UserBonusCreateWithoutPromotionInput, UserBonusUncheckedCreateWithoutPromotionInput> | UserBonusCreateWithoutPromotionInput[] | UserBonusUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutPromotionInput | UserBonusCreateOrConnectWithoutPromotionInput[]
    createMany?: UserBonusCreateManyPromotionInputEnvelope
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
  }

  export type UserBonusUncheckedCreateNestedManyWithoutPromotionInput = {
    create?: XOR<UserBonusCreateWithoutPromotionInput, UserBonusUncheckedCreateWithoutPromotionInput> | UserBonusCreateWithoutPromotionInput[] | UserBonusUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutPromotionInput | UserBonusCreateOrConnectWithoutPromotionInput[]
    createMany?: UserBonusCreateManyPromotionInputEnvelope
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
  }

  export type UserBonusUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<UserBonusCreateWithoutPromotionInput, UserBonusUncheckedCreateWithoutPromotionInput> | UserBonusCreateWithoutPromotionInput[] | UserBonusUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutPromotionInput | UserBonusCreateOrConnectWithoutPromotionInput[]
    upsert?: UserBonusUpsertWithWhereUniqueWithoutPromotionInput | UserBonusUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: UserBonusCreateManyPromotionInputEnvelope
    set?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    disconnect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    delete?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    update?: UserBonusUpdateWithWhereUniqueWithoutPromotionInput | UserBonusUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: UserBonusUpdateManyWithWhereWithoutPromotionInput | UserBonusUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
  }

  export type UserBonusUncheckedUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<UserBonusCreateWithoutPromotionInput, UserBonusUncheckedCreateWithoutPromotionInput> | UserBonusCreateWithoutPromotionInput[] | UserBonusUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutPromotionInput | UserBonusCreateOrConnectWithoutPromotionInput[]
    upsert?: UserBonusUpsertWithWhereUniqueWithoutPromotionInput | UserBonusUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: UserBonusCreateManyPromotionInputEnvelope
    set?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    disconnect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    delete?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    update?: UserBonusUpdateWithWhereUniqueWithoutPromotionInput | UserBonusUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: UserBonusUpdateManyWithWhereWithoutPromotionInput | UserBonusUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBonusesInput = {
    create?: XOR<UserCreateWithoutBonusesInput, UserUncheckedCreateWithoutBonusesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBonusesInput
    connect?: UserWhereUniqueInput
  }

  export type PromotionCreateNestedOneWithoutUserBonusesInput = {
    create?: XOR<PromotionCreateWithoutUserBonusesInput, PromotionUncheckedCreateWithoutUserBonusesInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutUserBonusesInput
    connect?: PromotionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBonusesNestedInput = {
    create?: XOR<UserCreateWithoutBonusesInput, UserUncheckedCreateWithoutBonusesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBonusesInput
    upsert?: UserUpsertWithoutBonusesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBonusesInput, UserUpdateWithoutBonusesInput>, UserUncheckedUpdateWithoutBonusesInput>
  }

  export type PromotionUpdateOneRequiredWithoutUserBonusesNestedInput = {
    create?: XOR<PromotionCreateWithoutUserBonusesInput, PromotionUncheckedCreateWithoutUserBonusesInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutUserBonusesInput
    upsert?: PromotionUpsertWithoutUserBonusesInput
    connect?: PromotionWhereUniqueInput
    update?: XOR<XOR<PromotionUpdateToOneWithWhereWithoutUserBonusesInput, PromotionUpdateWithoutUserBonusesInput>, PromotionUncheckedUpdateWithoutUserBonusesInput>
  }

  export type BetSelectionCreateNestedOneWithoutCurrentOddsInput = {
    create?: XOR<BetSelectionCreateWithoutCurrentOddsInput, BetSelectionUncheckedCreateWithoutCurrentOddsInput>
    connectOrCreate?: BetSelectionCreateOrConnectWithoutCurrentOddsInput
    connect?: BetSelectionWhereUniqueInput
  }

  export type BetSelectionUpdateOneRequiredWithoutCurrentOddsNestedInput = {
    create?: XOR<BetSelectionCreateWithoutCurrentOddsInput, BetSelectionUncheckedCreateWithoutCurrentOddsInput>
    connectOrCreate?: BetSelectionCreateOrConnectWithoutCurrentOddsInput
    upsert?: BetSelectionUpsertWithoutCurrentOddsInput
    connect?: BetSelectionWhereUniqueInput
    update?: XOR<XOR<BetSelectionUpdateToOneWithWhereWithoutCurrentOddsInput, BetSelectionUpdateWithoutCurrentOddsInput>, BetSelectionUncheckedUpdateWithoutCurrentOddsInput>
  }

  export type BetSelectionCreateNestedOneWithoutOddsSnapshotsInput = {
    create?: XOR<BetSelectionCreateWithoutOddsSnapshotsInput, BetSelectionUncheckedCreateWithoutOddsSnapshotsInput>
    connectOrCreate?: BetSelectionCreateOrConnectWithoutOddsSnapshotsInput
    connect?: BetSelectionWhereUniqueInput
  }

  export type BetSelectionUpdateOneRequiredWithoutOddsSnapshotsNestedInput = {
    create?: XOR<BetSelectionCreateWithoutOddsSnapshotsInput, BetSelectionUncheckedCreateWithoutOddsSnapshotsInput>
    connectOrCreate?: BetSelectionCreateOrConnectWithoutOddsSnapshotsInput
    upsert?: BetSelectionUpsertWithoutOddsSnapshotsInput
    connect?: BetSelectionWhereUniqueInput
    update?: XOR<XOR<BetSelectionUpdateToOneWithWhereWithoutOddsSnapshotsInput, BetSelectionUpdateWithoutOddsSnapshotsInput>, BetSelectionUncheckedUpdateWithoutOddsSnapshotsInput>
  }

  export type GameCreateNestedOneWithoutSyncStatusInput = {
    create?: XOR<GameCreateWithoutSyncStatusInput, GameUncheckedCreateWithoutSyncStatusInput>
    connectOrCreate?: GameCreateOrConnectWithoutSyncStatusInput
    connect?: GameWhereUniqueInput
  }

  export type GameUpdateOneRequiredWithoutSyncStatusNestedInput = {
    create?: XOR<GameCreateWithoutSyncStatusInput, GameUncheckedCreateWithoutSyncStatusInput>
    connectOrCreate?: GameCreateOrConnectWithoutSyncStatusInput
    upsert?: GameUpsertWithoutSyncStatusInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutSyncStatusInput, GameUpdateWithoutSyncStatusInput>, GameUncheckedUpdateWithoutSyncStatusInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileCreateWithoutUserInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    phoneNumber?: string | null
    country?: string | null
    timezone?: string | null
    language?: string | null
    marketingOptIn?: boolean
    responsibleGamingSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUncheckedCreateWithoutUserInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    phoneNumber?: string | null
    country?: string | null
    timezone?: string | null
    language?: string | null
    marketingOptIn?: boolean
    responsibleGamingSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileCreateOrConnectWithoutUserInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type UserPasswordCreateWithoutUserInput = {
    id?: string
    passwordHash: string
    passwordHistory?: NullableJsonNullValueInput | InputJsonValue
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    passwordChangedAt?: Date | string
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPasswordUncheckedCreateWithoutUserInput = {
    id?: string
    passwordHash: string
    passwordHistory?: NullableJsonNullValueInput | InputJsonValue
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    passwordChangedAt?: Date | string
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPasswordCreateOrConnectWithoutUserInput = {
    where: UserPasswordWhereUniqueInput
    create: XOR<UserPasswordCreateWithoutUserInput, UserPasswordUncheckedCreateWithoutUserInput>
  }

  export type TwoFactorAuthCreateWithoutUserInput = {
    id?: string
    method: string
    secretKey?: string | null
    backupCodes?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean
    lastVerifiedAt?: Date | string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorAuthUncheckedCreateWithoutUserInput = {
    id?: string
    method: string
    secretKey?: string | null
    backupCodes?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean
    lastVerifiedAt?: Date | string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorAuthCreateOrConnectWithoutUserInput = {
    where: TwoFactorAuthWhereUniqueInput
    create: XOR<TwoFactorAuthCreateWithoutUserInput, TwoFactorAuthUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateWithoutUserInput = {
    id?: string
    token: string
    deviceFingerprint: string
    ipAddressHash: string
    userAgent?: string | null
    lastActivityAt?: Date | string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    deviceFingerprint: string
    ipAddressHash: string
    userAgent?: string | null
    lastActivityAt?: Date | string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FinancialAccountCreateWithoutUserInput = {
    id?: string
    accountType?: string
    balance?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    lockedBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    lastTransactionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutAccountInput
  }

  export type FinancialAccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountType?: string
    balance?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    lockedBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    lastTransactionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
  }

  export type FinancialAccountCreateOrConnectWithoutUserInput = {
    where: FinancialAccountWhereUniqueInput
    create: XOR<FinancialAccountCreateWithoutUserInput, FinancialAccountUncheckedCreateWithoutUserInput>
  }

  export type FinancialAccountCreateManyUserInputEnvelope = {
    data: FinancialAccountCreateManyUserInput | FinancialAccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BetCreateWithoutUserInput = {
    id?: string
    betType: string
    totalStake: Decimal | DecimalJsLike | number | string
    potentialPayout: Decimal | DecimalJsLike | number | string
    actualPayout?: Decimal | DecimalJsLike | number | string | null
    status?: string
    placedAt?: Date | string
    settledAt?: Date | string | null
    cashoutAt?: Date | string | null
    oddsSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    selections?: BetSelectionBetCreateNestedManyWithoutBetInput
  }

  export type BetUncheckedCreateWithoutUserInput = {
    id?: string
    betType: string
    totalStake: Decimal | DecimalJsLike | number | string
    potentialPayout: Decimal | DecimalJsLike | number | string
    actualPayout?: Decimal | DecimalJsLike | number | string | null
    status?: string
    placedAt?: Date | string
    settledAt?: Date | string | null
    cashoutAt?: Date | string | null
    oddsSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    selections?: BetSelectionBetUncheckedCreateNestedManyWithoutBetInput
  }

  export type BetCreateOrConnectWithoutUserInput = {
    where: BetWhereUniqueInput
    create: XOR<BetCreateWithoutUserInput, BetUncheckedCreateWithoutUserInput>
  }

  export type BetCreateManyUserInputEnvelope = {
    data: BetCreateManyUserInput | BetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    id?: string
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    status?: string
    externalTransactionId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    account: FinancialAccountCreateNestedOneWithoutTransactionsInput
    paymentMethod?: PaymentMethodCreateNestedOneWithoutTransactionsInput
    deposit?: DepositCreateNestedOneWithoutTransactionInput
    withdrawal?: WithdrawalCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    status?: string
    paymentMethodId?: string | null
    externalTransactionId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    deposit?: DepositUncheckedCreateNestedOneWithoutTransactionInput
    withdrawal?: WithdrawalUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentMethodCreateWithoutUserInput = {
    id?: string
    paymentType: string
    provider: string
    tokenizedId: string
    last4Digits?: string | null
    expiryDate?: string | null
    billingAddress?: string | null
    isDefault?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutPaymentMethodInput
    deposits?: DepositCreateNestedManyWithoutPaymentMethodInput
    withdrawals?: WithdrawalCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUncheckedCreateWithoutUserInput = {
    id?: string
    paymentType: string
    provider: string
    tokenizedId: string
    last4Digits?: string | null
    expiryDate?: string | null
    billingAddress?: string | null
    isDefault?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutPaymentMethodInput
    deposits?: DepositUncheckedCreateNestedManyWithoutPaymentMethodInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodCreateOrConnectWithoutUserInput = {
    where: PaymentMethodWhereUniqueInput
    create: XOR<PaymentMethodCreateWithoutUserInput, PaymentMethodUncheckedCreateWithoutUserInput>
  }

  export type PaymentMethodCreateManyUserInputEnvelope = {
    data: PaymentMethodCreateManyUserInput | PaymentMethodCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FraudEventCreateWithoutUserInput = {
    id?: string
    eventType: string
    severity: string
    riskScore: number
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type FraudEventUncheckedCreateWithoutUserInput = {
    id?: string
    eventType: string
    severity: string
    riskScore: number
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type FraudEventCreateOrConnectWithoutUserInput = {
    where: FraudEventWhereUniqueInput
    create: XOR<FraudEventCreateWithoutUserInput, FraudEventUncheckedCreateWithoutUserInput>
  }

  export type FraudEventCreateManyUserInputEnvelope = {
    data: FraudEventCreateManyUserInput | FraudEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BettingPatternCreateWithoutUserInput = {
    id?: string
    patternType: string
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    detectedAt?: Date | string
    riskScore: number
    actionTaken?: string | null
  }

  export type BettingPatternUncheckedCreateWithoutUserInput = {
    id?: string
    patternType: string
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    detectedAt?: Date | string
    riskScore: number
    actionTaken?: string | null
  }

  export type BettingPatternCreateOrConnectWithoutUserInput = {
    where: BettingPatternWhereUniqueInput
    create: XOR<BettingPatternCreateWithoutUserInput, BettingPatternUncheckedCreateWithoutUserInput>
  }

  export type BettingPatternCreateManyUserInputEnvelope = {
    data: BettingPatternCreateManyUserInput | BettingPatternCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountActivityLogCreateWithoutUserInput = {
    id?: string
    activityType: string
    ipAddressHash: string
    deviceFingerprint?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    userAgent?: string | null
    success: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AccountActivityLogUncheckedCreateWithoutUserInput = {
    id?: string
    activityType: string
    ipAddressHash: string
    deviceFingerprint?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    userAgent?: string | null
    success: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AccountActivityLogCreateOrConnectWithoutUserInput = {
    where: AccountActivityLogWhereUniqueInput
    create: XOR<AccountActivityLogCreateWithoutUserInput, AccountActivityLogUncheckedCreateWithoutUserInput>
  }

  export type AccountActivityLogCreateManyUserInputEnvelope = {
    data: AccountActivityLogCreateManyUserInput | AccountActivityLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DeviceRegistryCreateWithoutUserInput = {
    id?: string
    deviceFingerprint: string
    deviceName?: string | null
    deviceType?: string | null
    os?: string | null
    browser?: string | null
    trusted?: boolean
    blocked?: boolean
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
  }

  export type DeviceRegistryUncheckedCreateWithoutUserInput = {
    id?: string
    deviceFingerprint: string
    deviceName?: string | null
    deviceType?: string | null
    os?: string | null
    browser?: string | null
    trusted?: boolean
    blocked?: boolean
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
  }

  export type DeviceRegistryCreateOrConnectWithoutUserInput = {
    where: DeviceRegistryWhereUniqueInput
    create: XOR<DeviceRegistryCreateWithoutUserInput, DeviceRegistryUncheckedCreateWithoutUserInput>
  }

  export type DeviceRegistryCreateManyUserInputEnvelope = {
    data: DeviceRegistryCreateManyUserInput | DeviceRegistryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    priority?: string
    title: string
    message: string
    read?: boolean
    dismissed?: boolean
    actionUrl?: string | null
    actionLabel?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    priority?: string
    title: string
    message: string
    read?: boolean
    dismissed?: boolean
    actionUrl?: string | null
    actionLabel?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GdprConsentCreateWithoutUserInput = {
    id?: string
    consentType: string
    consentStatus: string
    consentMethod: string
    ipAddressHash?: string | null
    withdrawnAt?: Date | string | null
    createdAt?: Date | string
  }

  export type GdprConsentUncheckedCreateWithoutUserInput = {
    id?: string
    consentType: string
    consentStatus: string
    consentMethod: string
    ipAddressHash?: string | null
    withdrawnAt?: Date | string | null
    createdAt?: Date | string
  }

  export type GdprConsentCreateOrConnectWithoutUserInput = {
    where: GdprConsentWhereUniqueInput
    create: XOR<GdprConsentCreateWithoutUserInput, GdprConsentUncheckedCreateWithoutUserInput>
  }

  export type GdprConsentCreateManyUserInputEnvelope = {
    data: GdprConsentCreateManyUserInput | GdprConsentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DataDeletionRequestCreateWithoutUserInput = {
    id?: string
    status?: string
    requestedAt?: Date | string
    processedAt?: Date | string | null
    rejectionReason?: string | null
    dataDeleted?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataDeletionRequestUncheckedCreateWithoutUserInput = {
    id?: string
    status?: string
    requestedAt?: Date | string
    processedAt?: Date | string | null
    rejectionReason?: string | null
    dataDeleted?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataDeletionRequestCreateOrConnectWithoutUserInput = {
    where: DataDeletionRequestWhereUniqueInput
    create: XOR<DataDeletionRequestCreateWithoutUserInput, DataDeletionRequestUncheckedCreateWithoutUserInput>
  }

  export type DataDeletionRequestCreateManyUserInputEnvelope = {
    data: DataDeletionRequestCreateManyUserInput | DataDeletionRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DataExportRequestCreateWithoutUserInput = {
    id?: string
    status?: string
    exportFormat?: string
    filePath?: string | null
    expiresAt?: Date | string | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataExportRequestUncheckedCreateWithoutUserInput = {
    id?: string
    status?: string
    exportFormat?: string
    filePath?: string | null
    expiresAt?: Date | string | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataExportRequestCreateOrConnectWithoutUserInput = {
    where: DataExportRequestWhereUniqueInput
    create: XOR<DataExportRequestCreateWithoutUserInput, DataExportRequestUncheckedCreateWithoutUserInput>
  }

  export type DataExportRequestCreateManyUserInputEnvelope = {
    data: DataExportRequestCreateManyUserInput | DataExportRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SecurityAlertCreateWithoutUserInput = {
    id?: string
    alertType: string
    severity: string
    description?: string | null
    actionRequired?: string | null
    acknowledged?: boolean
    createdAt?: Date | string
  }

  export type SecurityAlertUncheckedCreateWithoutUserInput = {
    id?: string
    alertType: string
    severity: string
    description?: string | null
    actionRequired?: string | null
    acknowledged?: boolean
    createdAt?: Date | string
  }

  export type SecurityAlertCreateOrConnectWithoutUserInput = {
    where: SecurityAlertWhereUniqueInput
    create: XOR<SecurityAlertCreateWithoutUserInput, SecurityAlertUncheckedCreateWithoutUserInput>
  }

  export type SecurityAlertCreateManyUserInputEnvelope = {
    data: SecurityAlertCreateManyUserInput | SecurityAlertCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserBonusCreateWithoutUserInput = {
    id?: string
    bonusAmount: Decimal | DecimalJsLike | number | string
    wageringRequirement: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    promotion: PromotionCreateNestedOneWithoutUserBonusesInput
  }

  export type UserBonusUncheckedCreateWithoutUserInput = {
    id?: string
    promotionId: string
    bonusAmount: Decimal | DecimalJsLike | number | string
    wageringRequirement: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBonusCreateOrConnectWithoutUserInput = {
    where: UserBonusWhereUniqueInput
    create: XOR<UserBonusCreateWithoutUserInput, UserBonusUncheckedCreateWithoutUserInput>
  }

  export type UserBonusCreateManyUserInputEnvelope = {
    data: UserBonusCreateManyUserInput | UserBonusCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    ipAddressHash?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    ipAddressHash?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type UserProfileUpsertWithoutUserInput = {
    update: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    marketingOptIn?: BoolFieldUpdateOperationsInput | boolean
    responsibleGamingSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    marketingOptIn?: BoolFieldUpdateOperationsInput | boolean
    responsibleGamingSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPasswordUpsertWithoutUserInput = {
    update: XOR<UserPasswordUpdateWithoutUserInput, UserPasswordUncheckedUpdateWithoutUserInput>
    create: XOR<UserPasswordCreateWithoutUserInput, UserPasswordUncheckedCreateWithoutUserInput>
    where?: UserPasswordWhereInput
  }

  export type UserPasswordUpdateToOneWithWhereWithoutUserInput = {
    where?: UserPasswordWhereInput
    data: XOR<UserPasswordUpdateWithoutUserInput, UserPasswordUncheckedUpdateWithoutUserInput>
  }

  export type UserPasswordUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    passwordHistory?: NullableJsonNullValueInput | InputJsonValue
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPasswordUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    passwordHistory?: NullableJsonNullValueInput | InputJsonValue
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorAuthUpsertWithoutUserInput = {
    update: XOR<TwoFactorAuthUpdateWithoutUserInput, TwoFactorAuthUncheckedUpdateWithoutUserInput>
    create: XOR<TwoFactorAuthCreateWithoutUserInput, TwoFactorAuthUncheckedCreateWithoutUserInput>
    where?: TwoFactorAuthWhereInput
  }

  export type TwoFactorAuthUpdateToOneWithWhereWithoutUserInput = {
    where?: TwoFactorAuthWhereInput
    data: XOR<TwoFactorAuthUpdateWithoutUserInput, TwoFactorAuthUncheckedUpdateWithoutUserInput>
  }

  export type TwoFactorAuthUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    secretKey?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    lastVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorAuthUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    secretKey?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    lastVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    token?: StringFilter<"UserSession"> | string
    deviceFingerprint?: StringFilter<"UserSession"> | string
    ipAddressHash?: StringFilter<"UserSession"> | string
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    lastActivityAt?: DateTimeFilter<"UserSession"> | Date | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    revoked?: BoolFilter<"UserSession"> | boolean
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
  }

  export type FinancialAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: FinancialAccountWhereUniqueInput
    update: XOR<FinancialAccountUpdateWithoutUserInput, FinancialAccountUncheckedUpdateWithoutUserInput>
    create: XOR<FinancialAccountCreateWithoutUserInput, FinancialAccountUncheckedCreateWithoutUserInput>
  }

  export type FinancialAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: FinancialAccountWhereUniqueInput
    data: XOR<FinancialAccountUpdateWithoutUserInput, FinancialAccountUncheckedUpdateWithoutUserInput>
  }

  export type FinancialAccountUpdateManyWithWhereWithoutUserInput = {
    where: FinancialAccountScalarWhereInput
    data: XOR<FinancialAccountUpdateManyMutationInput, FinancialAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type FinancialAccountScalarWhereInput = {
    AND?: FinancialAccountScalarWhereInput | FinancialAccountScalarWhereInput[]
    OR?: FinancialAccountScalarWhereInput[]
    NOT?: FinancialAccountScalarWhereInput | FinancialAccountScalarWhereInput[]
    id?: StringFilter<"FinancialAccount"> | string
    userId?: StringFilter<"FinancialAccount"> | string
    accountType?: StringFilter<"FinancialAccount"> | string
    balance?: DecimalFilter<"FinancialAccount"> | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFilter<"FinancialAccount"> | Decimal | DecimalJsLike | number | string
    lockedBalance?: DecimalFilter<"FinancialAccount"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"FinancialAccount"> | string
    lastTransactionAt?: DateTimeNullableFilter<"FinancialAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"FinancialAccount"> | Date | string
    updatedAt?: DateTimeFilter<"FinancialAccount"> | Date | string
  }

  export type BetUpsertWithWhereUniqueWithoutUserInput = {
    where: BetWhereUniqueInput
    update: XOR<BetUpdateWithoutUserInput, BetUncheckedUpdateWithoutUserInput>
    create: XOR<BetCreateWithoutUserInput, BetUncheckedCreateWithoutUserInput>
  }

  export type BetUpdateWithWhereUniqueWithoutUserInput = {
    where: BetWhereUniqueInput
    data: XOR<BetUpdateWithoutUserInput, BetUncheckedUpdateWithoutUserInput>
  }

  export type BetUpdateManyWithWhereWithoutUserInput = {
    where: BetScalarWhereInput
    data: XOR<BetUpdateManyMutationInput, BetUncheckedUpdateManyWithoutUserInput>
  }

  export type BetScalarWhereInput = {
    AND?: BetScalarWhereInput | BetScalarWhereInput[]
    OR?: BetScalarWhereInput[]
    NOT?: BetScalarWhereInput | BetScalarWhereInput[]
    id?: StringFilter<"Bet"> | string
    userId?: StringFilter<"Bet"> | string
    betType?: StringFilter<"Bet"> | string
    totalStake?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    potentialPayout?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    actualPayout?: DecimalNullableFilter<"Bet"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"Bet"> | string
    placedAt?: DateTimeFilter<"Bet"> | Date | string
    settledAt?: DateTimeNullableFilter<"Bet"> | Date | string | null
    cashoutAt?: DateTimeNullableFilter<"Bet"> | Date | string | null
    oddsSnapshot?: JsonNullableFilter<"Bet">
    createdAt?: DateTimeFilter<"Bet"> | Date | string
    updatedAt?: DateTimeFilter<"Bet"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    accountId?: StringFilter<"Transaction"> | string
    transactionType?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Transaction"> | string
    paymentMethodId?: StringNullableFilter<"Transaction"> | string | null
    externalTransactionId?: StringNullableFilter<"Transaction"> | string | null
    description?: StringNullableFilter<"Transaction"> | string | null
    metadata?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    processedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
  }

  export type PaymentMethodUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentMethodWhereUniqueInput
    update: XOR<PaymentMethodUpdateWithoutUserInput, PaymentMethodUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentMethodCreateWithoutUserInput, PaymentMethodUncheckedCreateWithoutUserInput>
  }

  export type PaymentMethodUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentMethodWhereUniqueInput
    data: XOR<PaymentMethodUpdateWithoutUserInput, PaymentMethodUncheckedUpdateWithoutUserInput>
  }

  export type PaymentMethodUpdateManyWithWhereWithoutUserInput = {
    where: PaymentMethodScalarWhereInput
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentMethodScalarWhereInput = {
    AND?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
    OR?: PaymentMethodScalarWhereInput[]
    NOT?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
    id?: StringFilter<"PaymentMethod"> | string
    userId?: StringFilter<"PaymentMethod"> | string
    paymentType?: StringFilter<"PaymentMethod"> | string
    provider?: StringFilter<"PaymentMethod"> | string
    tokenizedId?: StringFilter<"PaymentMethod"> | string
    last4Digits?: StringNullableFilter<"PaymentMethod"> | string | null
    expiryDate?: StringNullableFilter<"PaymentMethod"> | string | null
    billingAddress?: StringNullableFilter<"PaymentMethod"> | string | null
    isDefault?: BoolFilter<"PaymentMethod"> | boolean
    verified?: BoolFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
  }

  export type FraudEventUpsertWithWhereUniqueWithoutUserInput = {
    where: FraudEventWhereUniqueInput
    update: XOR<FraudEventUpdateWithoutUserInput, FraudEventUncheckedUpdateWithoutUserInput>
    create: XOR<FraudEventCreateWithoutUserInput, FraudEventUncheckedCreateWithoutUserInput>
  }

  export type FraudEventUpdateWithWhereUniqueWithoutUserInput = {
    where: FraudEventWhereUniqueInput
    data: XOR<FraudEventUpdateWithoutUserInput, FraudEventUncheckedUpdateWithoutUserInput>
  }

  export type FraudEventUpdateManyWithWhereWithoutUserInput = {
    where: FraudEventScalarWhereInput
    data: XOR<FraudEventUpdateManyMutationInput, FraudEventUncheckedUpdateManyWithoutUserInput>
  }

  export type FraudEventScalarWhereInput = {
    AND?: FraudEventScalarWhereInput | FraudEventScalarWhereInput[]
    OR?: FraudEventScalarWhereInput[]
    NOT?: FraudEventScalarWhereInput | FraudEventScalarWhereInput[]
    id?: StringFilter<"FraudEvent"> | string
    userId?: StringNullableFilter<"FraudEvent"> | string | null
    eventType?: StringFilter<"FraudEvent"> | string
    severity?: StringFilter<"FraudEvent"> | string
    riskScore?: IntFilter<"FraudEvent"> | number
    description?: StringNullableFilter<"FraudEvent"> | string | null
    metadata?: JsonNullableFilter<"FraudEvent">
    status?: StringFilter<"FraudEvent"> | string
    reviewedBy?: StringNullableFilter<"FraudEvent"> | string | null
    reviewedAt?: DateTimeNullableFilter<"FraudEvent"> | Date | string | null
    createdAt?: DateTimeFilter<"FraudEvent"> | Date | string
  }

  export type BettingPatternUpsertWithWhereUniqueWithoutUserInput = {
    where: BettingPatternWhereUniqueInput
    update: XOR<BettingPatternUpdateWithoutUserInput, BettingPatternUncheckedUpdateWithoutUserInput>
    create: XOR<BettingPatternCreateWithoutUserInput, BettingPatternUncheckedCreateWithoutUserInput>
  }

  export type BettingPatternUpdateWithWhereUniqueWithoutUserInput = {
    where: BettingPatternWhereUniqueInput
    data: XOR<BettingPatternUpdateWithoutUserInput, BettingPatternUncheckedUpdateWithoutUserInput>
  }

  export type BettingPatternUpdateManyWithWhereWithoutUserInput = {
    where: BettingPatternScalarWhereInput
    data: XOR<BettingPatternUpdateManyMutationInput, BettingPatternUncheckedUpdateManyWithoutUserInput>
  }

  export type BettingPatternScalarWhereInput = {
    AND?: BettingPatternScalarWhereInput | BettingPatternScalarWhereInput[]
    OR?: BettingPatternScalarWhereInput[]
    NOT?: BettingPatternScalarWhereInput | BettingPatternScalarWhereInput[]
    id?: StringFilter<"BettingPattern"> | string
    userId?: StringFilter<"BettingPattern"> | string
    patternType?: StringFilter<"BettingPattern"> | string
    patternDetails?: JsonNullableFilter<"BettingPattern">
    detectedAt?: DateTimeFilter<"BettingPattern"> | Date | string
    riskScore?: IntFilter<"BettingPattern"> | number
    actionTaken?: StringNullableFilter<"BettingPattern"> | string | null
  }

  export type AccountActivityLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountActivityLogWhereUniqueInput
    update: XOR<AccountActivityLogUpdateWithoutUserInput, AccountActivityLogUncheckedUpdateWithoutUserInput>
    create: XOR<AccountActivityLogCreateWithoutUserInput, AccountActivityLogUncheckedCreateWithoutUserInput>
  }

  export type AccountActivityLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountActivityLogWhereUniqueInput
    data: XOR<AccountActivityLogUpdateWithoutUserInput, AccountActivityLogUncheckedUpdateWithoutUserInput>
  }

  export type AccountActivityLogUpdateManyWithWhereWithoutUserInput = {
    where: AccountActivityLogScalarWhereInput
    data: XOR<AccountActivityLogUpdateManyMutationInput, AccountActivityLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountActivityLogScalarWhereInput = {
    AND?: AccountActivityLogScalarWhereInput | AccountActivityLogScalarWhereInput[]
    OR?: AccountActivityLogScalarWhereInput[]
    NOT?: AccountActivityLogScalarWhereInput | AccountActivityLogScalarWhereInput[]
    id?: StringFilter<"AccountActivityLog"> | string
    userId?: StringFilter<"AccountActivityLog"> | string
    activityType?: StringFilter<"AccountActivityLog"> | string
    ipAddressHash?: StringFilter<"AccountActivityLog"> | string
    deviceFingerprint?: StringNullableFilter<"AccountActivityLog"> | string | null
    country?: StringNullableFilter<"AccountActivityLog"> | string | null
    region?: StringNullableFilter<"AccountActivityLog"> | string | null
    city?: StringNullableFilter<"AccountActivityLog"> | string | null
    userAgent?: StringNullableFilter<"AccountActivityLog"> | string | null
    success?: BoolFilter<"AccountActivityLog"> | boolean
    metadata?: JsonNullableFilter<"AccountActivityLog">
    createdAt?: DateTimeFilter<"AccountActivityLog"> | Date | string
  }

  export type DeviceRegistryUpsertWithWhereUniqueWithoutUserInput = {
    where: DeviceRegistryWhereUniqueInput
    update: XOR<DeviceRegistryUpdateWithoutUserInput, DeviceRegistryUncheckedUpdateWithoutUserInput>
    create: XOR<DeviceRegistryCreateWithoutUserInput, DeviceRegistryUncheckedCreateWithoutUserInput>
  }

  export type DeviceRegistryUpdateWithWhereUniqueWithoutUserInput = {
    where: DeviceRegistryWhereUniqueInput
    data: XOR<DeviceRegistryUpdateWithoutUserInput, DeviceRegistryUncheckedUpdateWithoutUserInput>
  }

  export type DeviceRegistryUpdateManyWithWhereWithoutUserInput = {
    where: DeviceRegistryScalarWhereInput
    data: XOR<DeviceRegistryUpdateManyMutationInput, DeviceRegistryUncheckedUpdateManyWithoutUserInput>
  }

  export type DeviceRegistryScalarWhereInput = {
    AND?: DeviceRegistryScalarWhereInput | DeviceRegistryScalarWhereInput[]
    OR?: DeviceRegistryScalarWhereInput[]
    NOT?: DeviceRegistryScalarWhereInput | DeviceRegistryScalarWhereInput[]
    id?: StringFilter<"DeviceRegistry"> | string
    userId?: StringFilter<"DeviceRegistry"> | string
    deviceFingerprint?: StringFilter<"DeviceRegistry"> | string
    deviceName?: StringNullableFilter<"DeviceRegistry"> | string | null
    deviceType?: StringNullableFilter<"DeviceRegistry"> | string | null
    os?: StringNullableFilter<"DeviceRegistry"> | string | null
    browser?: StringNullableFilter<"DeviceRegistry"> | string | null
    trusted?: BoolFilter<"DeviceRegistry"> | boolean
    blocked?: BoolFilter<"DeviceRegistry"> | boolean
    firstSeenAt?: DateTimeFilter<"DeviceRegistry"> | Date | string
    lastSeenAt?: DateTimeFilter<"DeviceRegistry"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    priority?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    dismissed?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    actionLabel?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
  }

  export type GdprConsentUpsertWithWhereUniqueWithoutUserInput = {
    where: GdprConsentWhereUniqueInput
    update: XOR<GdprConsentUpdateWithoutUserInput, GdprConsentUncheckedUpdateWithoutUserInput>
    create: XOR<GdprConsentCreateWithoutUserInput, GdprConsentUncheckedCreateWithoutUserInput>
  }

  export type GdprConsentUpdateWithWhereUniqueWithoutUserInput = {
    where: GdprConsentWhereUniqueInput
    data: XOR<GdprConsentUpdateWithoutUserInput, GdprConsentUncheckedUpdateWithoutUserInput>
  }

  export type GdprConsentUpdateManyWithWhereWithoutUserInput = {
    where: GdprConsentScalarWhereInput
    data: XOR<GdprConsentUpdateManyMutationInput, GdprConsentUncheckedUpdateManyWithoutUserInput>
  }

  export type GdprConsentScalarWhereInput = {
    AND?: GdprConsentScalarWhereInput | GdprConsentScalarWhereInput[]
    OR?: GdprConsentScalarWhereInput[]
    NOT?: GdprConsentScalarWhereInput | GdprConsentScalarWhereInput[]
    id?: StringFilter<"GdprConsent"> | string
    userId?: StringFilter<"GdprConsent"> | string
    consentType?: StringFilter<"GdprConsent"> | string
    consentStatus?: StringFilter<"GdprConsent"> | string
    consentMethod?: StringFilter<"GdprConsent"> | string
    ipAddressHash?: StringNullableFilter<"GdprConsent"> | string | null
    withdrawnAt?: DateTimeNullableFilter<"GdprConsent"> | Date | string | null
    createdAt?: DateTimeFilter<"GdprConsent"> | Date | string
  }

  export type DataDeletionRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: DataDeletionRequestWhereUniqueInput
    update: XOR<DataDeletionRequestUpdateWithoutUserInput, DataDeletionRequestUncheckedUpdateWithoutUserInput>
    create: XOR<DataDeletionRequestCreateWithoutUserInput, DataDeletionRequestUncheckedCreateWithoutUserInput>
  }

  export type DataDeletionRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: DataDeletionRequestWhereUniqueInput
    data: XOR<DataDeletionRequestUpdateWithoutUserInput, DataDeletionRequestUncheckedUpdateWithoutUserInput>
  }

  export type DataDeletionRequestUpdateManyWithWhereWithoutUserInput = {
    where: DataDeletionRequestScalarWhereInput
    data: XOR<DataDeletionRequestUpdateManyMutationInput, DataDeletionRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type DataDeletionRequestScalarWhereInput = {
    AND?: DataDeletionRequestScalarWhereInput | DataDeletionRequestScalarWhereInput[]
    OR?: DataDeletionRequestScalarWhereInput[]
    NOT?: DataDeletionRequestScalarWhereInput | DataDeletionRequestScalarWhereInput[]
    id?: StringFilter<"DataDeletionRequest"> | string
    userId?: StringFilter<"DataDeletionRequest"> | string
    status?: StringFilter<"DataDeletionRequest"> | string
    requestedAt?: DateTimeFilter<"DataDeletionRequest"> | Date | string
    processedAt?: DateTimeNullableFilter<"DataDeletionRequest"> | Date | string | null
    rejectionReason?: StringNullableFilter<"DataDeletionRequest"> | string | null
    dataDeleted?: JsonNullableFilter<"DataDeletionRequest">
    createdAt?: DateTimeFilter<"DataDeletionRequest"> | Date | string
    updatedAt?: DateTimeFilter<"DataDeletionRequest"> | Date | string
  }

  export type DataExportRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: DataExportRequestWhereUniqueInput
    update: XOR<DataExportRequestUpdateWithoutUserInput, DataExportRequestUncheckedUpdateWithoutUserInput>
    create: XOR<DataExportRequestCreateWithoutUserInput, DataExportRequestUncheckedCreateWithoutUserInput>
  }

  export type DataExportRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: DataExportRequestWhereUniqueInput
    data: XOR<DataExportRequestUpdateWithoutUserInput, DataExportRequestUncheckedUpdateWithoutUserInput>
  }

  export type DataExportRequestUpdateManyWithWhereWithoutUserInput = {
    where: DataExportRequestScalarWhereInput
    data: XOR<DataExportRequestUpdateManyMutationInput, DataExportRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type DataExportRequestScalarWhereInput = {
    AND?: DataExportRequestScalarWhereInput | DataExportRequestScalarWhereInput[]
    OR?: DataExportRequestScalarWhereInput[]
    NOT?: DataExportRequestScalarWhereInput | DataExportRequestScalarWhereInput[]
    id?: StringFilter<"DataExportRequest"> | string
    userId?: StringFilter<"DataExportRequest"> | string
    status?: StringFilter<"DataExportRequest"> | string
    exportFormat?: StringFilter<"DataExportRequest"> | string
    filePath?: StringNullableFilter<"DataExportRequest"> | string | null
    expiresAt?: DateTimeNullableFilter<"DataExportRequest"> | Date | string | null
    requestedAt?: DateTimeFilter<"DataExportRequest"> | Date | string
    processedAt?: DateTimeNullableFilter<"DataExportRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"DataExportRequest"> | Date | string
    updatedAt?: DateTimeFilter<"DataExportRequest"> | Date | string
  }

  export type SecurityAlertUpsertWithWhereUniqueWithoutUserInput = {
    where: SecurityAlertWhereUniqueInput
    update: XOR<SecurityAlertUpdateWithoutUserInput, SecurityAlertUncheckedUpdateWithoutUserInput>
    create: XOR<SecurityAlertCreateWithoutUserInput, SecurityAlertUncheckedCreateWithoutUserInput>
  }

  export type SecurityAlertUpdateWithWhereUniqueWithoutUserInput = {
    where: SecurityAlertWhereUniqueInput
    data: XOR<SecurityAlertUpdateWithoutUserInput, SecurityAlertUncheckedUpdateWithoutUserInput>
  }

  export type SecurityAlertUpdateManyWithWhereWithoutUserInput = {
    where: SecurityAlertScalarWhereInput
    data: XOR<SecurityAlertUpdateManyMutationInput, SecurityAlertUncheckedUpdateManyWithoutUserInput>
  }

  export type SecurityAlertScalarWhereInput = {
    AND?: SecurityAlertScalarWhereInput | SecurityAlertScalarWhereInput[]
    OR?: SecurityAlertScalarWhereInput[]
    NOT?: SecurityAlertScalarWhereInput | SecurityAlertScalarWhereInput[]
    id?: StringFilter<"SecurityAlert"> | string
    userId?: StringNullableFilter<"SecurityAlert"> | string | null
    alertType?: StringFilter<"SecurityAlert"> | string
    severity?: StringFilter<"SecurityAlert"> | string
    description?: StringNullableFilter<"SecurityAlert"> | string | null
    actionRequired?: StringNullableFilter<"SecurityAlert"> | string | null
    acknowledged?: BoolFilter<"SecurityAlert"> | boolean
    createdAt?: DateTimeFilter<"SecurityAlert"> | Date | string
  }

  export type UserBonusUpsertWithWhereUniqueWithoutUserInput = {
    where: UserBonusWhereUniqueInput
    update: XOR<UserBonusUpdateWithoutUserInput, UserBonusUncheckedUpdateWithoutUserInput>
    create: XOR<UserBonusCreateWithoutUserInput, UserBonusUncheckedCreateWithoutUserInput>
  }

  export type UserBonusUpdateWithWhereUniqueWithoutUserInput = {
    where: UserBonusWhereUniqueInput
    data: XOR<UserBonusUpdateWithoutUserInput, UserBonusUncheckedUpdateWithoutUserInput>
  }

  export type UserBonusUpdateManyWithWhereWithoutUserInput = {
    where: UserBonusScalarWhereInput
    data: XOR<UserBonusUpdateManyMutationInput, UserBonusUncheckedUpdateManyWithoutUserInput>
  }

  export type UserBonusScalarWhereInput = {
    AND?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
    OR?: UserBonusScalarWhereInput[]
    NOT?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
    id?: StringFilter<"UserBonus"> | string
    userId?: StringFilter<"UserBonus"> | string
    promotionId?: StringFilter<"UserBonus"> | string
    bonusAmount?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    wageringRequirement?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"UserBonus"> | string
    expiresAt?: DateTimeNullableFilter<"UserBonus"> | Date | string | null
    createdAt?: DateTimeFilter<"UserBonus"> | Date | string
    updatedAt?: DateTimeFilter<"UserBonus"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    ipAddressHash?: StringNullableFilter<"AuditLog"> | string | null
    changes?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    password?: UserPasswordCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: GdprConsentCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventUncheckedCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: GdprConsentUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    password?: UserPasswordUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUncheckedUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    password?: UserPasswordCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: GdprConsentCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventUncheckedCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: GdprConsentUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    password?: UserPasswordUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUncheckedUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    password?: UserPasswordCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: GdprConsentCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventUncheckedCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: GdprConsentUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    password?: UserPasswordUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUncheckedUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPasswordInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: GdprConsentCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventUncheckedCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: GdprConsentUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordInput, UserUncheckedCreateWithoutPasswordInput>
  }

  export type UserUpsertWithoutPasswordInput = {
    update: XOR<UserUpdateWithoutPasswordInput, UserUncheckedUpdateWithoutPasswordInput>
    create: XOR<UserCreateWithoutPasswordInput, UserUncheckedCreateWithoutPasswordInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordInput, UserUncheckedUpdateWithoutPasswordInput>
  }

  export type UserUpdateWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUncheckedUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTwoFactorAuthInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    password?: UserPasswordCreateNestedOneWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: GdprConsentCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTwoFactorAuthInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedOneWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventUncheckedCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: GdprConsentUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTwoFactorAuthInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTwoFactorAuthInput, UserUncheckedCreateWithoutTwoFactorAuthInput>
  }

  export type UserUpsertWithoutTwoFactorAuthInput = {
    update: XOR<UserUpdateWithoutTwoFactorAuthInput, UserUncheckedUpdateWithoutTwoFactorAuthInput>
    create: XOR<UserCreateWithoutTwoFactorAuthInput, UserUncheckedCreateWithoutTwoFactorAuthInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTwoFactorAuthInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTwoFactorAuthInput, UserUncheckedUpdateWithoutTwoFactorAuthInput>
  }

  export type UserUpdateWithoutTwoFactorAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    password?: UserPasswordUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTwoFactorAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUncheckedUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUserSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    password?: UserPasswordCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    financialAccounts?: FinancialAccountCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: GdprConsentCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    financialAccounts?: FinancialAccountUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventUncheckedCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: GdprConsentUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSessionsInput, UserUncheckedCreateWithoutUserSessionsInput>
  }

  export type UserUpsertWithoutUserSessionsInput = {
    update: XOR<UserUpdateWithoutUserSessionsInput, UserUncheckedUpdateWithoutUserSessionsInput>
    create: XOR<UserCreateWithoutUserSessionsInput, UserUncheckedCreateWithoutUserSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserSessionsInput, UserUncheckedUpdateWithoutUserSessionsInput>
  }

  export type UserUpdateWithoutUserSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    password?: UserPasswordUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    financialAccounts?: FinancialAccountUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    financialAccounts?: FinancialAccountUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUncheckedUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LeagueCreateWithoutSportInput = {
    id?: string
    name: string
    code: string
    country?: string | null
    region?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamCreateNestedManyWithoutLeagueInput
    games?: GameCreateNestedManyWithoutLeagueInput
  }

  export type LeagueUncheckedCreateWithoutSportInput = {
    id?: string
    name: string
    code: string
    country?: string | null
    region?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutLeagueInput
    games?: GameUncheckedCreateNestedManyWithoutLeagueInput
  }

  export type LeagueCreateOrConnectWithoutSportInput = {
    where: LeagueWhereUniqueInput
    create: XOR<LeagueCreateWithoutSportInput, LeagueUncheckedCreateWithoutSportInput>
  }

  export type LeagueCreateManySportInputEnvelope = {
    data: LeagueCreateManySportInput | LeagueCreateManySportInput[]
    skipDuplicates?: boolean
  }

  export type GameCreateWithoutSportInput = {
    id?: string
    scheduledStartAt: Date | string
    actualStartAt?: Date | string | null
    status?: string
    homeScore?: number | null
    awayScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutGamesInput
    homeTeam: TeamCreateNestedOneWithoutHomeGamesInput
    awayTeam: TeamCreateNestedOneWithoutAwayGamesInput
    markets?: BetMarketCreateNestedManyWithoutGameInput
    syncStatus?: OddsSyncStatusCreateNestedOneWithoutGameInput
  }

  export type GameUncheckedCreateWithoutSportInput = {
    id?: string
    leagueId: string
    homeTeamId: string
    awayTeamId: string
    scheduledStartAt: Date | string
    actualStartAt?: Date | string | null
    status?: string
    homeScore?: number | null
    awayScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    markets?: BetMarketUncheckedCreateNestedManyWithoutGameInput
    syncStatus?: OddsSyncStatusUncheckedCreateNestedOneWithoutGameInput
  }

  export type GameCreateOrConnectWithoutSportInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutSportInput, GameUncheckedCreateWithoutSportInput>
  }

  export type GameCreateManySportInputEnvelope = {
    data: GameCreateManySportInput | GameCreateManySportInput[]
    skipDuplicates?: boolean
  }

  export type LeagueUpsertWithWhereUniqueWithoutSportInput = {
    where: LeagueWhereUniqueInput
    update: XOR<LeagueUpdateWithoutSportInput, LeagueUncheckedUpdateWithoutSportInput>
    create: XOR<LeagueCreateWithoutSportInput, LeagueUncheckedCreateWithoutSportInput>
  }

  export type LeagueUpdateWithWhereUniqueWithoutSportInput = {
    where: LeagueWhereUniqueInput
    data: XOR<LeagueUpdateWithoutSportInput, LeagueUncheckedUpdateWithoutSportInput>
  }

  export type LeagueUpdateManyWithWhereWithoutSportInput = {
    where: LeagueScalarWhereInput
    data: XOR<LeagueUpdateManyMutationInput, LeagueUncheckedUpdateManyWithoutSportInput>
  }

  export type LeagueScalarWhereInput = {
    AND?: LeagueScalarWhereInput | LeagueScalarWhereInput[]
    OR?: LeagueScalarWhereInput[]
    NOT?: LeagueScalarWhereInput | LeagueScalarWhereInput[]
    id?: StringFilter<"League"> | string
    sportId?: StringFilter<"League"> | string
    name?: StringFilter<"League"> | string
    code?: StringFilter<"League"> | string
    country?: StringNullableFilter<"League"> | string | null
    region?: StringNullableFilter<"League"> | string | null
    active?: BoolFilter<"League"> | boolean
    createdAt?: DateTimeFilter<"League"> | Date | string
    updatedAt?: DateTimeFilter<"League"> | Date | string
  }

  export type GameUpsertWithWhereUniqueWithoutSportInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutSportInput, GameUncheckedUpdateWithoutSportInput>
    create: XOR<GameCreateWithoutSportInput, GameUncheckedCreateWithoutSportInput>
  }

  export type GameUpdateWithWhereUniqueWithoutSportInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutSportInput, GameUncheckedUpdateWithoutSportInput>
  }

  export type GameUpdateManyWithWhereWithoutSportInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutSportInput>
  }

  export type GameScalarWhereInput = {
    AND?: GameScalarWhereInput | GameScalarWhereInput[]
    OR?: GameScalarWhereInput[]
    NOT?: GameScalarWhereInput | GameScalarWhereInput[]
    id?: StringFilter<"Game"> | string
    sportId?: StringFilter<"Game"> | string
    leagueId?: StringFilter<"Game"> | string
    homeTeamId?: StringFilter<"Game"> | string
    awayTeamId?: StringFilter<"Game"> | string
    scheduledStartAt?: DateTimeFilter<"Game"> | Date | string
    actualStartAt?: DateTimeNullableFilter<"Game"> | Date | string | null
    status?: StringFilter<"Game"> | string
    homeScore?: IntNullableFilter<"Game"> | number | null
    awayScore?: IntNullableFilter<"Game"> | number | null
    metadata?: JsonNullableFilter<"Game">
    createdAt?: DateTimeFilter<"Game"> | Date | string
    updatedAt?: DateTimeFilter<"Game"> | Date | string
  }

  export type SportCreateWithoutLeaguesInput = {
    id?: string
    name: string
    code: string
    active?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    games?: GameCreateNestedManyWithoutSportInput
  }

  export type SportUncheckedCreateWithoutLeaguesInput = {
    id?: string
    name: string
    code: string
    active?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    games?: GameUncheckedCreateNestedManyWithoutSportInput
  }

  export type SportCreateOrConnectWithoutLeaguesInput = {
    where: SportWhereUniqueInput
    create: XOR<SportCreateWithoutLeaguesInput, SportUncheckedCreateWithoutLeaguesInput>
  }

  export type TeamCreateWithoutLeagueInput = {
    id?: string
    name: string
    code: string
    logoUrl?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    homeGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayGames?: GameCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateWithoutLeagueInput = {
    id?: string
    name: string
    code: string
    logoUrl?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    homeGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamCreateOrConnectWithoutLeagueInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutLeagueInput, TeamUncheckedCreateWithoutLeagueInput>
  }

  export type TeamCreateManyLeagueInputEnvelope = {
    data: TeamCreateManyLeagueInput | TeamCreateManyLeagueInput[]
    skipDuplicates?: boolean
  }

  export type GameCreateWithoutLeagueInput = {
    id?: string
    scheduledStartAt: Date | string
    actualStartAt?: Date | string | null
    status?: string
    homeScore?: number | null
    awayScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sport: SportCreateNestedOneWithoutGamesInput
    homeTeam: TeamCreateNestedOneWithoutHomeGamesInput
    awayTeam: TeamCreateNestedOneWithoutAwayGamesInput
    markets?: BetMarketCreateNestedManyWithoutGameInput
    syncStatus?: OddsSyncStatusCreateNestedOneWithoutGameInput
  }

  export type GameUncheckedCreateWithoutLeagueInput = {
    id?: string
    sportId: string
    homeTeamId: string
    awayTeamId: string
    scheduledStartAt: Date | string
    actualStartAt?: Date | string | null
    status?: string
    homeScore?: number | null
    awayScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    markets?: BetMarketUncheckedCreateNestedManyWithoutGameInput
    syncStatus?: OddsSyncStatusUncheckedCreateNestedOneWithoutGameInput
  }

  export type GameCreateOrConnectWithoutLeagueInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutLeagueInput, GameUncheckedCreateWithoutLeagueInput>
  }

  export type GameCreateManyLeagueInputEnvelope = {
    data: GameCreateManyLeagueInput | GameCreateManyLeagueInput[]
    skipDuplicates?: boolean
  }

  export type SportUpsertWithoutLeaguesInput = {
    update: XOR<SportUpdateWithoutLeaguesInput, SportUncheckedUpdateWithoutLeaguesInput>
    create: XOR<SportCreateWithoutLeaguesInput, SportUncheckedCreateWithoutLeaguesInput>
    where?: SportWhereInput
  }

  export type SportUpdateToOneWithWhereWithoutLeaguesInput = {
    where?: SportWhereInput
    data: XOR<SportUpdateWithoutLeaguesInput, SportUncheckedUpdateWithoutLeaguesInput>
  }

  export type SportUpdateWithoutLeaguesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: GameUpdateManyWithoutSportNestedInput
  }

  export type SportUncheckedUpdateWithoutLeaguesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: GameUncheckedUpdateManyWithoutSportNestedInput
  }

  export type TeamUpsertWithWhereUniqueWithoutLeagueInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutLeagueInput, TeamUncheckedUpdateWithoutLeagueInput>
    create: XOR<TeamCreateWithoutLeagueInput, TeamUncheckedCreateWithoutLeagueInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutLeagueInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutLeagueInput, TeamUncheckedUpdateWithoutLeagueInput>
  }

  export type TeamUpdateManyWithWhereWithoutLeagueInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutLeagueInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: StringFilter<"Team"> | string
    leagueId?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    code?: StringFilter<"Team"> | string
    logoUrl?: StringNullableFilter<"Team"> | string | null
    active?: BoolFilter<"Team"> | boolean
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
  }

  export type GameUpsertWithWhereUniqueWithoutLeagueInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutLeagueInput, GameUncheckedUpdateWithoutLeagueInput>
    create: XOR<GameCreateWithoutLeagueInput, GameUncheckedCreateWithoutLeagueInput>
  }

  export type GameUpdateWithWhereUniqueWithoutLeagueInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutLeagueInput, GameUncheckedUpdateWithoutLeagueInput>
  }

  export type GameUpdateManyWithWhereWithoutLeagueInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutLeagueInput>
  }

  export type LeagueCreateWithoutTeamsInput = {
    id?: string
    name: string
    code: string
    country?: string | null
    region?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sport: SportCreateNestedOneWithoutLeaguesInput
    games?: GameCreateNestedManyWithoutLeagueInput
  }

  export type LeagueUncheckedCreateWithoutTeamsInput = {
    id?: string
    sportId: string
    name: string
    code: string
    country?: string | null
    region?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    games?: GameUncheckedCreateNestedManyWithoutLeagueInput
  }

  export type LeagueCreateOrConnectWithoutTeamsInput = {
    where: LeagueWhereUniqueInput
    create: XOR<LeagueCreateWithoutTeamsInput, LeagueUncheckedCreateWithoutTeamsInput>
  }

  export type GameCreateWithoutHomeTeamInput = {
    id?: string
    scheduledStartAt: Date | string
    actualStartAt?: Date | string | null
    status?: string
    homeScore?: number | null
    awayScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sport: SportCreateNestedOneWithoutGamesInput
    league: LeagueCreateNestedOneWithoutGamesInput
    awayTeam: TeamCreateNestedOneWithoutAwayGamesInput
    markets?: BetMarketCreateNestedManyWithoutGameInput
    syncStatus?: OddsSyncStatusCreateNestedOneWithoutGameInput
  }

  export type GameUncheckedCreateWithoutHomeTeamInput = {
    id?: string
    sportId: string
    leagueId: string
    awayTeamId: string
    scheduledStartAt: Date | string
    actualStartAt?: Date | string | null
    status?: string
    homeScore?: number | null
    awayScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    markets?: BetMarketUncheckedCreateNestedManyWithoutGameInput
    syncStatus?: OddsSyncStatusUncheckedCreateNestedOneWithoutGameInput
  }

  export type GameCreateOrConnectWithoutHomeTeamInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutHomeTeamInput, GameUncheckedCreateWithoutHomeTeamInput>
  }

  export type GameCreateManyHomeTeamInputEnvelope = {
    data: GameCreateManyHomeTeamInput | GameCreateManyHomeTeamInput[]
    skipDuplicates?: boolean
  }

  export type GameCreateWithoutAwayTeamInput = {
    id?: string
    scheduledStartAt: Date | string
    actualStartAt?: Date | string | null
    status?: string
    homeScore?: number | null
    awayScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sport: SportCreateNestedOneWithoutGamesInput
    league: LeagueCreateNestedOneWithoutGamesInput
    homeTeam: TeamCreateNestedOneWithoutHomeGamesInput
    markets?: BetMarketCreateNestedManyWithoutGameInput
    syncStatus?: OddsSyncStatusCreateNestedOneWithoutGameInput
  }

  export type GameUncheckedCreateWithoutAwayTeamInput = {
    id?: string
    sportId: string
    leagueId: string
    homeTeamId: string
    scheduledStartAt: Date | string
    actualStartAt?: Date | string | null
    status?: string
    homeScore?: number | null
    awayScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    markets?: BetMarketUncheckedCreateNestedManyWithoutGameInput
    syncStatus?: OddsSyncStatusUncheckedCreateNestedOneWithoutGameInput
  }

  export type GameCreateOrConnectWithoutAwayTeamInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutAwayTeamInput, GameUncheckedCreateWithoutAwayTeamInput>
  }

  export type GameCreateManyAwayTeamInputEnvelope = {
    data: GameCreateManyAwayTeamInput | GameCreateManyAwayTeamInput[]
    skipDuplicates?: boolean
  }

  export type LeagueUpsertWithoutTeamsInput = {
    update: XOR<LeagueUpdateWithoutTeamsInput, LeagueUncheckedUpdateWithoutTeamsInput>
    create: XOR<LeagueCreateWithoutTeamsInput, LeagueUncheckedCreateWithoutTeamsInput>
    where?: LeagueWhereInput
  }

  export type LeagueUpdateToOneWithWhereWithoutTeamsInput = {
    where?: LeagueWhereInput
    data: XOR<LeagueUpdateWithoutTeamsInput, LeagueUncheckedUpdateWithoutTeamsInput>
  }

  export type LeagueUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: SportUpdateOneRequiredWithoutLeaguesNestedInput
    games?: GameUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sportId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: GameUncheckedUpdateManyWithoutLeagueNestedInput
  }

  export type GameUpsertWithWhereUniqueWithoutHomeTeamInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutHomeTeamInput, GameUncheckedUpdateWithoutHomeTeamInput>
    create: XOR<GameCreateWithoutHomeTeamInput, GameUncheckedCreateWithoutHomeTeamInput>
  }

  export type GameUpdateWithWhereUniqueWithoutHomeTeamInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutHomeTeamInput, GameUncheckedUpdateWithoutHomeTeamInput>
  }

  export type GameUpdateManyWithWhereWithoutHomeTeamInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutHomeTeamInput>
  }

  export type GameUpsertWithWhereUniqueWithoutAwayTeamInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutAwayTeamInput, GameUncheckedUpdateWithoutAwayTeamInput>
    create: XOR<GameCreateWithoutAwayTeamInput, GameUncheckedCreateWithoutAwayTeamInput>
  }

  export type GameUpdateWithWhereUniqueWithoutAwayTeamInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutAwayTeamInput, GameUncheckedUpdateWithoutAwayTeamInput>
  }

  export type GameUpdateManyWithWhereWithoutAwayTeamInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutAwayTeamInput>
  }

  export type SportCreateWithoutGamesInput = {
    id?: string
    name: string
    code: string
    active?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    leagues?: LeagueCreateNestedManyWithoutSportInput
  }

  export type SportUncheckedCreateWithoutGamesInput = {
    id?: string
    name: string
    code: string
    active?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    leagues?: LeagueUncheckedCreateNestedManyWithoutSportInput
  }

  export type SportCreateOrConnectWithoutGamesInput = {
    where: SportWhereUniqueInput
    create: XOR<SportCreateWithoutGamesInput, SportUncheckedCreateWithoutGamesInput>
  }

  export type LeagueCreateWithoutGamesInput = {
    id?: string
    name: string
    code: string
    country?: string | null
    region?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sport: SportCreateNestedOneWithoutLeaguesInput
    teams?: TeamCreateNestedManyWithoutLeagueInput
  }

  export type LeagueUncheckedCreateWithoutGamesInput = {
    id?: string
    sportId: string
    name: string
    code: string
    country?: string | null
    region?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutLeagueInput
  }

  export type LeagueCreateOrConnectWithoutGamesInput = {
    where: LeagueWhereUniqueInput
    create: XOR<LeagueCreateWithoutGamesInput, LeagueUncheckedCreateWithoutGamesInput>
  }

  export type TeamCreateWithoutHomeGamesInput = {
    id?: string
    name: string
    code: string
    logoUrl?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutTeamsInput
    awayGames?: GameCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateWithoutHomeGamesInput = {
    id?: string
    leagueId: string
    name: string
    code: string
    logoUrl?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    awayGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamCreateOrConnectWithoutHomeGamesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutHomeGamesInput, TeamUncheckedCreateWithoutHomeGamesInput>
  }

  export type TeamCreateWithoutAwayGamesInput = {
    id?: string
    name: string
    code: string
    logoUrl?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutTeamsInput
    homeGames?: GameCreateNestedManyWithoutHomeTeamInput
  }

  export type TeamUncheckedCreateWithoutAwayGamesInput = {
    id?: string
    leagueId: string
    name: string
    code: string
    logoUrl?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    homeGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
  }

  export type TeamCreateOrConnectWithoutAwayGamesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutAwayGamesInput, TeamUncheckedCreateWithoutAwayGamesInput>
  }

  export type BetMarketCreateWithoutGameInput = {
    id?: string
    marketType: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    selections?: BetSelectionCreateNestedManyWithoutMarketInput
  }

  export type BetMarketUncheckedCreateWithoutGameInput = {
    id?: string
    marketType: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    selections?: BetSelectionUncheckedCreateNestedManyWithoutMarketInput
  }

  export type BetMarketCreateOrConnectWithoutGameInput = {
    where: BetMarketWhereUniqueInput
    create: XOR<BetMarketCreateWithoutGameInput, BetMarketUncheckedCreateWithoutGameInput>
  }

  export type BetMarketCreateManyGameInputEnvelope = {
    data: BetMarketCreateManyGameInput | BetMarketCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type OddsSyncStatusCreateWithoutGameInput = {
    id?: string
    lastSyncAt?: Date | string
    nextSyncAt?: Date | string | null
    syncStatus?: string
    failureCount?: number
    lastError?: string | null
    syncInterval?: number
  }

  export type OddsSyncStatusUncheckedCreateWithoutGameInput = {
    id?: string
    lastSyncAt?: Date | string
    nextSyncAt?: Date | string | null
    syncStatus?: string
    failureCount?: number
    lastError?: string | null
    syncInterval?: number
  }

  export type OddsSyncStatusCreateOrConnectWithoutGameInput = {
    where: OddsSyncStatusWhereUniqueInput
    create: XOR<OddsSyncStatusCreateWithoutGameInput, OddsSyncStatusUncheckedCreateWithoutGameInput>
  }

  export type SportUpsertWithoutGamesInput = {
    update: XOR<SportUpdateWithoutGamesInput, SportUncheckedUpdateWithoutGamesInput>
    create: XOR<SportCreateWithoutGamesInput, SportUncheckedCreateWithoutGamesInput>
    where?: SportWhereInput
  }

  export type SportUpdateToOneWithWhereWithoutGamesInput = {
    where?: SportWhereInput
    data: XOR<SportUpdateWithoutGamesInput, SportUncheckedUpdateWithoutGamesInput>
  }

  export type SportUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leagues?: LeagueUpdateManyWithoutSportNestedInput
  }

  export type SportUncheckedUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leagues?: LeagueUncheckedUpdateManyWithoutSportNestedInput
  }

  export type LeagueUpsertWithoutGamesInput = {
    update: XOR<LeagueUpdateWithoutGamesInput, LeagueUncheckedUpdateWithoutGamesInput>
    create: XOR<LeagueCreateWithoutGamesInput, LeagueUncheckedCreateWithoutGamesInput>
    where?: LeagueWhereInput
  }

  export type LeagueUpdateToOneWithWhereWithoutGamesInput = {
    where?: LeagueWhereInput
    data: XOR<LeagueUpdateWithoutGamesInput, LeagueUncheckedUpdateWithoutGamesInput>
  }

  export type LeagueUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: SportUpdateOneRequiredWithoutLeaguesNestedInput
    teams?: TeamUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueUncheckedUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sportId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutLeagueNestedInput
  }

  export type TeamUpsertWithoutHomeGamesInput = {
    update: XOR<TeamUpdateWithoutHomeGamesInput, TeamUncheckedUpdateWithoutHomeGamesInput>
    create: XOR<TeamCreateWithoutHomeGamesInput, TeamUncheckedCreateWithoutHomeGamesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutHomeGamesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutHomeGamesInput, TeamUncheckedUpdateWithoutHomeGamesInput>
  }

  export type TeamUpdateWithoutHomeGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTeamsNestedInput
    awayGames?: GameUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutHomeGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    awayGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUpsertWithoutAwayGamesInput = {
    update: XOR<TeamUpdateWithoutAwayGamesInput, TeamUncheckedUpdateWithoutAwayGamesInput>
    create: XOR<TeamCreateWithoutAwayGamesInput, TeamUncheckedCreateWithoutAwayGamesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutAwayGamesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutAwayGamesInput, TeamUncheckedUpdateWithoutAwayGamesInput>
  }

  export type TeamUpdateWithoutAwayGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTeamsNestedInput
    homeGames?: GameUpdateManyWithoutHomeTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutAwayGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    homeGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
  }

  export type BetMarketUpsertWithWhereUniqueWithoutGameInput = {
    where: BetMarketWhereUniqueInput
    update: XOR<BetMarketUpdateWithoutGameInput, BetMarketUncheckedUpdateWithoutGameInput>
    create: XOR<BetMarketCreateWithoutGameInput, BetMarketUncheckedCreateWithoutGameInput>
  }

  export type BetMarketUpdateWithWhereUniqueWithoutGameInput = {
    where: BetMarketWhereUniqueInput
    data: XOR<BetMarketUpdateWithoutGameInput, BetMarketUncheckedUpdateWithoutGameInput>
  }

  export type BetMarketUpdateManyWithWhereWithoutGameInput = {
    where: BetMarketScalarWhereInput
    data: XOR<BetMarketUpdateManyMutationInput, BetMarketUncheckedUpdateManyWithoutGameInput>
  }

  export type BetMarketScalarWhereInput = {
    AND?: BetMarketScalarWhereInput | BetMarketScalarWhereInput[]
    OR?: BetMarketScalarWhereInput[]
    NOT?: BetMarketScalarWhereInput | BetMarketScalarWhereInput[]
    id?: StringFilter<"BetMarket"> | string
    gameId?: StringFilter<"BetMarket"> | string
    marketType?: StringFilter<"BetMarket"> | string
    name?: StringFilter<"BetMarket"> | string
    active?: BoolFilter<"BetMarket"> | boolean
    createdAt?: DateTimeFilter<"BetMarket"> | Date | string
    updatedAt?: DateTimeFilter<"BetMarket"> | Date | string
  }

  export type OddsSyncStatusUpsertWithoutGameInput = {
    update: XOR<OddsSyncStatusUpdateWithoutGameInput, OddsSyncStatusUncheckedUpdateWithoutGameInput>
    create: XOR<OddsSyncStatusCreateWithoutGameInput, OddsSyncStatusUncheckedCreateWithoutGameInput>
    where?: OddsSyncStatusWhereInput
  }

  export type OddsSyncStatusUpdateToOneWithWhereWithoutGameInput = {
    where?: OddsSyncStatusWhereInput
    data: XOR<OddsSyncStatusUpdateWithoutGameInput, OddsSyncStatusUncheckedUpdateWithoutGameInput>
  }

  export type OddsSyncStatusUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    failureCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    syncInterval?: IntFieldUpdateOperationsInput | number
  }

  export type OddsSyncStatusUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    failureCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    syncInterval?: IntFieldUpdateOperationsInput | number
  }

  export type GameCreateWithoutMarketsInput = {
    id?: string
    scheduledStartAt: Date | string
    actualStartAt?: Date | string | null
    status?: string
    homeScore?: number | null
    awayScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sport: SportCreateNestedOneWithoutGamesInput
    league: LeagueCreateNestedOneWithoutGamesInput
    homeTeam: TeamCreateNestedOneWithoutHomeGamesInput
    awayTeam: TeamCreateNestedOneWithoutAwayGamesInput
    syncStatus?: OddsSyncStatusCreateNestedOneWithoutGameInput
  }

  export type GameUncheckedCreateWithoutMarketsInput = {
    id?: string
    sportId: string
    leagueId: string
    homeTeamId: string
    awayTeamId: string
    scheduledStartAt: Date | string
    actualStartAt?: Date | string | null
    status?: string
    homeScore?: number | null
    awayScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    syncStatus?: OddsSyncStatusUncheckedCreateNestedOneWithoutGameInput
  }

  export type GameCreateOrConnectWithoutMarketsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutMarketsInput, GameUncheckedCreateWithoutMarketsInput>
  }

  export type BetSelectionCreateWithoutMarketInput = {
    id?: string
    name: string
    odds: Decimal | DecimalJsLike | number | string
    status?: string
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    betSelections?: BetSelectionBetCreateNestedManyWithoutSelectionInput
    currentOdds?: CurrentOddsCreateNestedOneWithoutSelectionInput
    oddsSnapshots?: OddsSnapshotCreateNestedManyWithoutSelectionInput
  }

  export type BetSelectionUncheckedCreateWithoutMarketInput = {
    id?: string
    name: string
    odds: Decimal | DecimalJsLike | number | string
    status?: string
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    betSelections?: BetSelectionBetUncheckedCreateNestedManyWithoutSelectionInput
    currentOdds?: CurrentOddsUncheckedCreateNestedOneWithoutSelectionInput
    oddsSnapshots?: OddsSnapshotUncheckedCreateNestedManyWithoutSelectionInput
  }

  export type BetSelectionCreateOrConnectWithoutMarketInput = {
    where: BetSelectionWhereUniqueInput
    create: XOR<BetSelectionCreateWithoutMarketInput, BetSelectionUncheckedCreateWithoutMarketInput>
  }

  export type BetSelectionCreateManyMarketInputEnvelope = {
    data: BetSelectionCreateManyMarketInput | BetSelectionCreateManyMarketInput[]
    skipDuplicates?: boolean
  }

  export type GameUpsertWithoutMarketsInput = {
    update: XOR<GameUpdateWithoutMarketsInput, GameUncheckedUpdateWithoutMarketsInput>
    create: XOR<GameCreateWithoutMarketsInput, GameUncheckedCreateWithoutMarketsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutMarketsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutMarketsInput, GameUncheckedUpdateWithoutMarketsInput>
  }

  export type GameUpdateWithoutMarketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: SportUpdateOneRequiredWithoutGamesNestedInput
    league?: LeagueUpdateOneRequiredWithoutGamesNestedInput
    homeTeam?: TeamUpdateOneRequiredWithoutHomeGamesNestedInput
    awayTeam?: TeamUpdateOneRequiredWithoutAwayGamesNestedInput
    syncStatus?: OddsSyncStatusUpdateOneWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutMarketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sportId?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    homeTeamId?: StringFieldUpdateOperationsInput | string
    awayTeamId?: StringFieldUpdateOperationsInput | string
    scheduledStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncStatus?: OddsSyncStatusUncheckedUpdateOneWithoutGameNestedInput
  }

  export type BetSelectionUpsertWithWhereUniqueWithoutMarketInput = {
    where: BetSelectionWhereUniqueInput
    update: XOR<BetSelectionUpdateWithoutMarketInput, BetSelectionUncheckedUpdateWithoutMarketInput>
    create: XOR<BetSelectionCreateWithoutMarketInput, BetSelectionUncheckedCreateWithoutMarketInput>
  }

  export type BetSelectionUpdateWithWhereUniqueWithoutMarketInput = {
    where: BetSelectionWhereUniqueInput
    data: XOR<BetSelectionUpdateWithoutMarketInput, BetSelectionUncheckedUpdateWithoutMarketInput>
  }

  export type BetSelectionUpdateManyWithWhereWithoutMarketInput = {
    where: BetSelectionScalarWhereInput
    data: XOR<BetSelectionUpdateManyMutationInput, BetSelectionUncheckedUpdateManyWithoutMarketInput>
  }

  export type BetSelectionScalarWhereInput = {
    AND?: BetSelectionScalarWhereInput | BetSelectionScalarWhereInput[]
    OR?: BetSelectionScalarWhereInput[]
    NOT?: BetSelectionScalarWhereInput | BetSelectionScalarWhereInput[]
    id?: StringFilter<"BetSelection"> | string
    marketId?: StringFilter<"BetSelection"> | string
    name?: StringFilter<"BetSelection"> | string
    odds?: DecimalFilter<"BetSelection"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"BetSelection"> | string
    result?: StringNullableFilter<"BetSelection"> | string | null
    createdAt?: DateTimeFilter<"BetSelection"> | Date | string
    updatedAt?: DateTimeFilter<"BetSelection"> | Date | string
  }

  export type BetMarketCreateWithoutSelectionsInput = {
    id?: string
    marketType: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    game: GameCreateNestedOneWithoutMarketsInput
  }

  export type BetMarketUncheckedCreateWithoutSelectionsInput = {
    id?: string
    gameId: string
    marketType: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetMarketCreateOrConnectWithoutSelectionsInput = {
    where: BetMarketWhereUniqueInput
    create: XOR<BetMarketCreateWithoutSelectionsInput, BetMarketUncheckedCreateWithoutSelectionsInput>
  }

  export type BetSelectionBetCreateWithoutSelectionInput = {
    id?: string
    oddsAtBet: Decimal | DecimalJsLike | number | string
    result?: string | null
    createdAt?: Date | string
    bet: BetCreateNestedOneWithoutSelectionsInput
  }

  export type BetSelectionBetUncheckedCreateWithoutSelectionInput = {
    id?: string
    betId: string
    oddsAtBet: Decimal | DecimalJsLike | number | string
    result?: string | null
    createdAt?: Date | string
  }

  export type BetSelectionBetCreateOrConnectWithoutSelectionInput = {
    where: BetSelectionBetWhereUniqueInput
    create: XOR<BetSelectionBetCreateWithoutSelectionInput, BetSelectionBetUncheckedCreateWithoutSelectionInput>
  }

  export type BetSelectionBetCreateManySelectionInputEnvelope = {
    data: BetSelectionBetCreateManySelectionInput | BetSelectionBetCreateManySelectionInput[]
    skipDuplicates?: boolean
  }

  export type CurrentOddsCreateWithoutSelectionInput = {
    id?: string
    currentOdds: Decimal | DecimalJsLike | number | string
    previousOdds?: Decimal | DecimalJsLike | number | string | null
    oddsMovement?: string | null
    lastUpdatedAt?: Date | string
    syncedAt?: Date | string
    externalOddsId?: string | null
    suspended?: boolean
  }

  export type CurrentOddsUncheckedCreateWithoutSelectionInput = {
    id?: string
    currentOdds: Decimal | DecimalJsLike | number | string
    previousOdds?: Decimal | DecimalJsLike | number | string | null
    oddsMovement?: string | null
    lastUpdatedAt?: Date | string
    syncedAt?: Date | string
    externalOddsId?: string | null
    suspended?: boolean
  }

  export type CurrentOddsCreateOrConnectWithoutSelectionInput = {
    where: CurrentOddsWhereUniqueInput
    create: XOR<CurrentOddsCreateWithoutSelectionInput, CurrentOddsUncheckedCreateWithoutSelectionInput>
  }

  export type OddsSnapshotCreateWithoutSelectionInput = {
    id?: string
    odds: Decimal | DecimalJsLike | number | string
    timestamp?: Date | string
    source?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OddsSnapshotUncheckedCreateWithoutSelectionInput = {
    id?: string
    odds: Decimal | DecimalJsLike | number | string
    timestamp?: Date | string
    source?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OddsSnapshotCreateOrConnectWithoutSelectionInput = {
    where: OddsSnapshotWhereUniqueInput
    create: XOR<OddsSnapshotCreateWithoutSelectionInput, OddsSnapshotUncheckedCreateWithoutSelectionInput>
  }

  export type OddsSnapshotCreateManySelectionInputEnvelope = {
    data: OddsSnapshotCreateManySelectionInput | OddsSnapshotCreateManySelectionInput[]
    skipDuplicates?: boolean
  }

  export type BetMarketUpsertWithoutSelectionsInput = {
    update: XOR<BetMarketUpdateWithoutSelectionsInput, BetMarketUncheckedUpdateWithoutSelectionsInput>
    create: XOR<BetMarketCreateWithoutSelectionsInput, BetMarketUncheckedCreateWithoutSelectionsInput>
    where?: BetMarketWhereInput
  }

  export type BetMarketUpdateToOneWithWhereWithoutSelectionsInput = {
    where?: BetMarketWhereInput
    data: XOR<BetMarketUpdateWithoutSelectionsInput, BetMarketUncheckedUpdateWithoutSelectionsInput>
  }

  export type BetMarketUpdateWithoutSelectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutMarketsNestedInput
  }

  export type BetMarketUncheckedUpdateWithoutSelectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    marketType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetSelectionBetUpsertWithWhereUniqueWithoutSelectionInput = {
    where: BetSelectionBetWhereUniqueInput
    update: XOR<BetSelectionBetUpdateWithoutSelectionInput, BetSelectionBetUncheckedUpdateWithoutSelectionInput>
    create: XOR<BetSelectionBetCreateWithoutSelectionInput, BetSelectionBetUncheckedCreateWithoutSelectionInput>
  }

  export type BetSelectionBetUpdateWithWhereUniqueWithoutSelectionInput = {
    where: BetSelectionBetWhereUniqueInput
    data: XOR<BetSelectionBetUpdateWithoutSelectionInput, BetSelectionBetUncheckedUpdateWithoutSelectionInput>
  }

  export type BetSelectionBetUpdateManyWithWhereWithoutSelectionInput = {
    where: BetSelectionBetScalarWhereInput
    data: XOR<BetSelectionBetUpdateManyMutationInput, BetSelectionBetUncheckedUpdateManyWithoutSelectionInput>
  }

  export type BetSelectionBetScalarWhereInput = {
    AND?: BetSelectionBetScalarWhereInput | BetSelectionBetScalarWhereInput[]
    OR?: BetSelectionBetScalarWhereInput[]
    NOT?: BetSelectionBetScalarWhereInput | BetSelectionBetScalarWhereInput[]
    id?: StringFilter<"BetSelectionBet"> | string
    betId?: StringFilter<"BetSelectionBet"> | string
    selectionId?: StringFilter<"BetSelectionBet"> | string
    oddsAtBet?: DecimalFilter<"BetSelectionBet"> | Decimal | DecimalJsLike | number | string
    result?: StringNullableFilter<"BetSelectionBet"> | string | null
    createdAt?: DateTimeFilter<"BetSelectionBet"> | Date | string
  }

  export type CurrentOddsUpsertWithoutSelectionInput = {
    update: XOR<CurrentOddsUpdateWithoutSelectionInput, CurrentOddsUncheckedUpdateWithoutSelectionInput>
    create: XOR<CurrentOddsCreateWithoutSelectionInput, CurrentOddsUncheckedCreateWithoutSelectionInput>
    where?: CurrentOddsWhereInput
  }

  export type CurrentOddsUpdateToOneWithWhereWithoutSelectionInput = {
    where?: CurrentOddsWhereInput
    data: XOR<CurrentOddsUpdateWithoutSelectionInput, CurrentOddsUncheckedUpdateWithoutSelectionInput>
  }

  export type CurrentOddsUpdateWithoutSelectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    previousOdds?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    oddsMovement?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalOddsId?: NullableStringFieldUpdateOperationsInput | string | null
    suspended?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CurrentOddsUncheckedUpdateWithoutSelectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentOdds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    previousOdds?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    oddsMovement?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalOddsId?: NullableStringFieldUpdateOperationsInput | string | null
    suspended?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OddsSnapshotUpsertWithWhereUniqueWithoutSelectionInput = {
    where: OddsSnapshotWhereUniqueInput
    update: XOR<OddsSnapshotUpdateWithoutSelectionInput, OddsSnapshotUncheckedUpdateWithoutSelectionInput>
    create: XOR<OddsSnapshotCreateWithoutSelectionInput, OddsSnapshotUncheckedCreateWithoutSelectionInput>
  }

  export type OddsSnapshotUpdateWithWhereUniqueWithoutSelectionInput = {
    where: OddsSnapshotWhereUniqueInput
    data: XOR<OddsSnapshotUpdateWithoutSelectionInput, OddsSnapshotUncheckedUpdateWithoutSelectionInput>
  }

  export type OddsSnapshotUpdateManyWithWhereWithoutSelectionInput = {
    where: OddsSnapshotScalarWhereInput
    data: XOR<OddsSnapshotUpdateManyMutationInput, OddsSnapshotUncheckedUpdateManyWithoutSelectionInput>
  }

  export type OddsSnapshotScalarWhereInput = {
    AND?: OddsSnapshotScalarWhereInput | OddsSnapshotScalarWhereInput[]
    OR?: OddsSnapshotScalarWhereInput[]
    NOT?: OddsSnapshotScalarWhereInput | OddsSnapshotScalarWhereInput[]
    id?: StringFilter<"OddsSnapshot"> | string
    selectionId?: StringFilter<"OddsSnapshot"> | string
    odds?: DecimalFilter<"OddsSnapshot"> | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeFilter<"OddsSnapshot"> | Date | string
    source?: StringFilter<"OddsSnapshot"> | string
    metadata?: JsonNullableFilter<"OddsSnapshot">
  }

  export type UserCreateWithoutBetsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    password?: UserPasswordCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: GdprConsentCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBetsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventUncheckedCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: GdprConsentUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBetsInput, UserUncheckedCreateWithoutBetsInput>
  }

  export type BetSelectionBetCreateWithoutBetInput = {
    id?: string
    oddsAtBet: Decimal | DecimalJsLike | number | string
    result?: string | null
    createdAt?: Date | string
    selection: BetSelectionCreateNestedOneWithoutBetSelectionsInput
  }

  export type BetSelectionBetUncheckedCreateWithoutBetInput = {
    id?: string
    selectionId: string
    oddsAtBet: Decimal | DecimalJsLike | number | string
    result?: string | null
    createdAt?: Date | string
  }

  export type BetSelectionBetCreateOrConnectWithoutBetInput = {
    where: BetSelectionBetWhereUniqueInput
    create: XOR<BetSelectionBetCreateWithoutBetInput, BetSelectionBetUncheckedCreateWithoutBetInput>
  }

  export type BetSelectionBetCreateManyBetInputEnvelope = {
    data: BetSelectionBetCreateManyBetInput | BetSelectionBetCreateManyBetInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBetsInput = {
    update: XOR<UserUpdateWithoutBetsInput, UserUncheckedUpdateWithoutBetsInput>
    create: XOR<UserCreateWithoutBetsInput, UserUncheckedCreateWithoutBetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBetsInput, UserUncheckedUpdateWithoutBetsInput>
  }

  export type UserUpdateWithoutBetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    password?: UserPasswordUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUncheckedUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BetSelectionBetUpsertWithWhereUniqueWithoutBetInput = {
    where: BetSelectionBetWhereUniqueInput
    update: XOR<BetSelectionBetUpdateWithoutBetInput, BetSelectionBetUncheckedUpdateWithoutBetInput>
    create: XOR<BetSelectionBetCreateWithoutBetInput, BetSelectionBetUncheckedCreateWithoutBetInput>
  }

  export type BetSelectionBetUpdateWithWhereUniqueWithoutBetInput = {
    where: BetSelectionBetWhereUniqueInput
    data: XOR<BetSelectionBetUpdateWithoutBetInput, BetSelectionBetUncheckedUpdateWithoutBetInput>
  }

  export type BetSelectionBetUpdateManyWithWhereWithoutBetInput = {
    where: BetSelectionBetScalarWhereInput
    data: XOR<BetSelectionBetUpdateManyMutationInput, BetSelectionBetUncheckedUpdateManyWithoutBetInput>
  }

  export type BetCreateWithoutSelectionsInput = {
    id?: string
    betType: string
    totalStake: Decimal | DecimalJsLike | number | string
    potentialPayout: Decimal | DecimalJsLike | number | string
    actualPayout?: Decimal | DecimalJsLike | number | string | null
    status?: string
    placedAt?: Date | string
    settledAt?: Date | string | null
    cashoutAt?: Date | string | null
    oddsSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBetsInput
  }

  export type BetUncheckedCreateWithoutSelectionsInput = {
    id?: string
    userId: string
    betType: string
    totalStake: Decimal | DecimalJsLike | number | string
    potentialPayout: Decimal | DecimalJsLike | number | string
    actualPayout?: Decimal | DecimalJsLike | number | string | null
    status?: string
    placedAt?: Date | string
    settledAt?: Date | string | null
    cashoutAt?: Date | string | null
    oddsSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetCreateOrConnectWithoutSelectionsInput = {
    where: BetWhereUniqueInput
    create: XOR<BetCreateWithoutSelectionsInput, BetUncheckedCreateWithoutSelectionsInput>
  }

  export type BetSelectionCreateWithoutBetSelectionsInput = {
    id?: string
    name: string
    odds: Decimal | DecimalJsLike | number | string
    status?: string
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    market: BetMarketCreateNestedOneWithoutSelectionsInput
    currentOdds?: CurrentOddsCreateNestedOneWithoutSelectionInput
    oddsSnapshots?: OddsSnapshotCreateNestedManyWithoutSelectionInput
  }

  export type BetSelectionUncheckedCreateWithoutBetSelectionsInput = {
    id?: string
    marketId: string
    name: string
    odds: Decimal | DecimalJsLike | number | string
    status?: string
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentOdds?: CurrentOddsUncheckedCreateNestedOneWithoutSelectionInput
    oddsSnapshots?: OddsSnapshotUncheckedCreateNestedManyWithoutSelectionInput
  }

  export type BetSelectionCreateOrConnectWithoutBetSelectionsInput = {
    where: BetSelectionWhereUniqueInput
    create: XOR<BetSelectionCreateWithoutBetSelectionsInput, BetSelectionUncheckedCreateWithoutBetSelectionsInput>
  }

  export type BetUpsertWithoutSelectionsInput = {
    update: XOR<BetUpdateWithoutSelectionsInput, BetUncheckedUpdateWithoutSelectionsInput>
    create: XOR<BetCreateWithoutSelectionsInput, BetUncheckedCreateWithoutSelectionsInput>
    where?: BetWhereInput
  }

  export type BetUpdateToOneWithWhereWithoutSelectionsInput = {
    where?: BetWhereInput
    data: XOR<BetUpdateWithoutSelectionsInput, BetUncheckedUpdateWithoutSelectionsInput>
  }

  export type BetUpdateWithoutSelectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    betType?: StringFieldUpdateOperationsInput | string
    totalStake?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    potentialPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualPayout?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    placedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oddsSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBetsNestedInput
  }

  export type BetUncheckedUpdateWithoutSelectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    betType?: StringFieldUpdateOperationsInput | string
    totalStake?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    potentialPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualPayout?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    placedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oddsSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetSelectionUpsertWithoutBetSelectionsInput = {
    update: XOR<BetSelectionUpdateWithoutBetSelectionsInput, BetSelectionUncheckedUpdateWithoutBetSelectionsInput>
    create: XOR<BetSelectionCreateWithoutBetSelectionsInput, BetSelectionUncheckedCreateWithoutBetSelectionsInput>
    where?: BetSelectionWhereInput
  }

  export type BetSelectionUpdateToOneWithWhereWithoutBetSelectionsInput = {
    where?: BetSelectionWhereInput
    data: XOR<BetSelectionUpdateWithoutBetSelectionsInput, BetSelectionUncheckedUpdateWithoutBetSelectionsInput>
  }

  export type BetSelectionUpdateWithoutBetSelectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    market?: BetMarketUpdateOneRequiredWithoutSelectionsNestedInput
    currentOdds?: CurrentOddsUpdateOneWithoutSelectionNestedInput
    oddsSnapshots?: OddsSnapshotUpdateManyWithoutSelectionNestedInput
  }

  export type BetSelectionUncheckedUpdateWithoutBetSelectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentOdds?: CurrentOddsUncheckedUpdateOneWithoutSelectionNestedInput
    oddsSnapshots?: OddsSnapshotUncheckedUpdateManyWithoutSelectionNestedInput
  }

  export type UserCreateWithoutFinancialAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    password?: UserPasswordCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: GdprConsentCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFinancialAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventUncheckedCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: GdprConsentUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFinancialAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFinancialAccountsInput, UserUncheckedCreateWithoutFinancialAccountsInput>
  }

  export type TransactionCreateWithoutAccountInput = {
    id?: string
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    status?: string
    externalTransactionId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    user: UserCreateNestedOneWithoutTransactionsInput
    paymentMethod?: PaymentMethodCreateNestedOneWithoutTransactionsInput
    deposit?: DepositCreateNestedOneWithoutTransactionInput
    withdrawal?: WithdrawalCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutAccountInput = {
    id?: string
    userId: string
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    status?: string
    paymentMethodId?: string | null
    externalTransactionId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    deposit?: DepositUncheckedCreateNestedOneWithoutTransactionInput
    withdrawal?: WithdrawalUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput>
  }

  export type TransactionCreateManyAccountInputEnvelope = {
    data: TransactionCreateManyAccountInput | TransactionCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutFinancialAccountsInput = {
    update: XOR<UserUpdateWithoutFinancialAccountsInput, UserUncheckedUpdateWithoutFinancialAccountsInput>
    create: XOR<UserCreateWithoutFinancialAccountsInput, UserUncheckedCreateWithoutFinancialAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFinancialAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFinancialAccountsInput, UserUncheckedUpdateWithoutFinancialAccountsInput>
  }

  export type UserUpdateWithoutFinancialAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    password?: UserPasswordUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFinancialAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUncheckedUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutAccountInput, TransactionUncheckedUpdateWithoutAccountInput>
    create: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutAccountInput, TransactionUncheckedUpdateWithoutAccountInput>
  }

  export type TransactionUpdateManyWithWhereWithoutAccountInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutAccountInput>
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    password?: UserPasswordCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: GdprConsentCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventUncheckedCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: GdprConsentUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type FinancialAccountCreateWithoutTransactionsInput = {
    id?: string
    accountType?: string
    balance?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    lockedBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    lastTransactionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFinancialAccountsInput
  }

  export type FinancialAccountUncheckedCreateWithoutTransactionsInput = {
    id?: string
    userId: string
    accountType?: string
    balance?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    lockedBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    lastTransactionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialAccountCreateOrConnectWithoutTransactionsInput = {
    where: FinancialAccountWhereUniqueInput
    create: XOR<FinancialAccountCreateWithoutTransactionsInput, FinancialAccountUncheckedCreateWithoutTransactionsInput>
  }

  export type PaymentMethodCreateWithoutTransactionsInput = {
    id?: string
    paymentType: string
    provider: string
    tokenizedId: string
    last4Digits?: string | null
    expiryDate?: string | null
    billingAddress?: string | null
    isDefault?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentMethodsInput
    deposits?: DepositCreateNestedManyWithoutPaymentMethodInput
    withdrawals?: WithdrawalCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUncheckedCreateWithoutTransactionsInput = {
    id?: string
    userId: string
    paymentType: string
    provider: string
    tokenizedId: string
    last4Digits?: string | null
    expiryDate?: string | null
    billingAddress?: string | null
    isDefault?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deposits?: DepositUncheckedCreateNestedManyWithoutPaymentMethodInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodCreateOrConnectWithoutTransactionsInput = {
    where: PaymentMethodWhereUniqueInput
    create: XOR<PaymentMethodCreateWithoutTransactionsInput, PaymentMethodUncheckedCreateWithoutTransactionsInput>
  }

  export type DepositCreateWithoutTransactionInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    providerTransactionId?: string | null
    status?: string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethod: PaymentMethodCreateNestedOneWithoutDepositsInput
  }

  export type DepositUncheckedCreateWithoutTransactionInput = {
    id?: string
    paymentMethodId: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    providerTransactionId?: string | null
    status?: string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepositCreateOrConnectWithoutTransactionInput = {
    where: DepositWhereUniqueInput
    create: XOR<DepositCreateWithoutTransactionInput, DepositUncheckedCreateWithoutTransactionInput>
  }

  export type WithdrawalCreateWithoutTransactionInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status?: string
    providerTransactionId?: string | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    kycVerificationRequired?: boolean
    requestedAt?: Date | string
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethod: PaymentMethodCreateNestedOneWithoutWithdrawalsInput
  }

  export type WithdrawalUncheckedCreateWithoutTransactionInput = {
    id?: string
    paymentMethodId: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status?: string
    providerTransactionId?: string | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    kycVerificationRequired?: boolean
    requestedAt?: Date | string
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WithdrawalCreateOrConnectWithoutTransactionInput = {
    where: WithdrawalWhereUniqueInput
    create: XOR<WithdrawalCreateWithoutTransactionInput, WithdrawalUncheckedCreateWithoutTransactionInput>
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    password?: UserPasswordUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUncheckedUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FinancialAccountUpsertWithoutTransactionsInput = {
    update: XOR<FinancialAccountUpdateWithoutTransactionsInput, FinancialAccountUncheckedUpdateWithoutTransactionsInput>
    create: XOR<FinancialAccountCreateWithoutTransactionsInput, FinancialAccountUncheckedCreateWithoutTransactionsInput>
    where?: FinancialAccountWhereInput
  }

  export type FinancialAccountUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: FinancialAccountWhereInput
    data: XOR<FinancialAccountUpdateWithoutTransactionsInput, FinancialAccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type FinancialAccountUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    lastTransactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFinancialAccountsNestedInput
  }

  export type FinancialAccountUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    lastTransactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUpsertWithoutTransactionsInput = {
    update: XOR<PaymentMethodUpdateWithoutTransactionsInput, PaymentMethodUncheckedUpdateWithoutTransactionsInput>
    create: XOR<PaymentMethodCreateWithoutTransactionsInput, PaymentMethodUncheckedCreateWithoutTransactionsInput>
    where?: PaymentMethodWhereInput
  }

  export type PaymentMethodUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: PaymentMethodWhereInput
    data: XOR<PaymentMethodUpdateWithoutTransactionsInput, PaymentMethodUncheckedUpdateWithoutTransactionsInput>
  }

  export type PaymentMethodUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    tokenizedId?: StringFieldUpdateOperationsInput | string
    last4Digits?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentMethodsNestedInput
    deposits?: DepositUpdateManyWithoutPaymentMethodNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    tokenizedId?: StringFieldUpdateOperationsInput | string
    last4Digits?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deposits?: DepositUncheckedUpdateManyWithoutPaymentMethodNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutPaymentMethodNestedInput
  }

  export type DepositUpsertWithoutTransactionInput = {
    update: XOR<DepositUpdateWithoutTransactionInput, DepositUncheckedUpdateWithoutTransactionInput>
    create: XOR<DepositCreateWithoutTransactionInput, DepositUncheckedCreateWithoutTransactionInput>
    where?: DepositWhereInput
  }

  export type DepositUpdateToOneWithWhereWithoutTransactionInput = {
    where?: DepositWhereInput
    data: XOR<DepositUpdateWithoutTransactionInput, DepositUncheckedUpdateWithoutTransactionInput>
  }

  export type DepositUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutDepositsNestedInput
  }

  export type DepositUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WithdrawalUpsertWithoutTransactionInput = {
    update: XOR<WithdrawalUpdateWithoutTransactionInput, WithdrawalUncheckedUpdateWithoutTransactionInput>
    create: XOR<WithdrawalCreateWithoutTransactionInput, WithdrawalUncheckedCreateWithoutTransactionInput>
    where?: WithdrawalWhereInput
  }

  export type WithdrawalUpdateToOneWithWhereWithoutTransactionInput = {
    where?: WithdrawalWhereInput
    data: XOR<WithdrawalUpdateWithoutTransactionInput, WithdrawalUncheckedUpdateWithoutTransactionInput>
  }

  export type WithdrawalUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    kycVerificationRequired?: BoolFieldUpdateOperationsInput | boolean
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutWithdrawalsNestedInput
  }

  export type WithdrawalUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    kycVerificationRequired?: BoolFieldUpdateOperationsInput | boolean
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutPaymentMethodsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    password?: UserPasswordCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: GdprConsentCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentMethodsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventUncheckedCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: GdprConsentUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentMethodsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentMethodsInput, UserUncheckedCreateWithoutPaymentMethodsInput>
  }

  export type TransactionCreateWithoutPaymentMethodInput = {
    id?: string
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    status?: string
    externalTransactionId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    user: UserCreateNestedOneWithoutTransactionsInput
    account: FinancialAccountCreateNestedOneWithoutTransactionsInput
    deposit?: DepositCreateNestedOneWithoutTransactionInput
    withdrawal?: WithdrawalCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutPaymentMethodInput = {
    id?: string
    userId: string
    accountId: string
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    status?: string
    externalTransactionId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    deposit?: DepositUncheckedCreateNestedOneWithoutTransactionInput
    withdrawal?: WithdrawalUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutPaymentMethodInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutPaymentMethodInput, TransactionUncheckedCreateWithoutPaymentMethodInput>
  }

  export type TransactionCreateManyPaymentMethodInputEnvelope = {
    data: TransactionCreateManyPaymentMethodInput | TransactionCreateManyPaymentMethodInput[]
    skipDuplicates?: boolean
  }

  export type DepositCreateWithoutPaymentMethodInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    providerTransactionId?: string | null
    status?: string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutDepositInput
  }

  export type DepositUncheckedCreateWithoutPaymentMethodInput = {
    id?: string
    transactionId: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    providerTransactionId?: string | null
    status?: string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepositCreateOrConnectWithoutPaymentMethodInput = {
    where: DepositWhereUniqueInput
    create: XOR<DepositCreateWithoutPaymentMethodInput, DepositUncheckedCreateWithoutPaymentMethodInput>
  }

  export type DepositCreateManyPaymentMethodInputEnvelope = {
    data: DepositCreateManyPaymentMethodInput | DepositCreateManyPaymentMethodInput[]
    skipDuplicates?: boolean
  }

  export type WithdrawalCreateWithoutPaymentMethodInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status?: string
    providerTransactionId?: string | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    kycVerificationRequired?: boolean
    requestedAt?: Date | string
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutWithdrawalInput
  }

  export type WithdrawalUncheckedCreateWithoutPaymentMethodInput = {
    id?: string
    transactionId: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status?: string
    providerTransactionId?: string | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    kycVerificationRequired?: boolean
    requestedAt?: Date | string
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WithdrawalCreateOrConnectWithoutPaymentMethodInput = {
    where: WithdrawalWhereUniqueInput
    create: XOR<WithdrawalCreateWithoutPaymentMethodInput, WithdrawalUncheckedCreateWithoutPaymentMethodInput>
  }

  export type WithdrawalCreateManyPaymentMethodInputEnvelope = {
    data: WithdrawalCreateManyPaymentMethodInput | WithdrawalCreateManyPaymentMethodInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPaymentMethodsInput = {
    update: XOR<UserUpdateWithoutPaymentMethodsInput, UserUncheckedUpdateWithoutPaymentMethodsInput>
    create: XOR<UserCreateWithoutPaymentMethodsInput, UserUncheckedCreateWithoutPaymentMethodsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentMethodsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentMethodsInput, UserUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type UserUpdateWithoutPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    password?: UserPasswordUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUncheckedUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutPaymentMethodInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutPaymentMethodInput, TransactionUncheckedUpdateWithoutPaymentMethodInput>
    create: XOR<TransactionCreateWithoutPaymentMethodInput, TransactionUncheckedCreateWithoutPaymentMethodInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutPaymentMethodInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutPaymentMethodInput, TransactionUncheckedUpdateWithoutPaymentMethodInput>
  }

  export type TransactionUpdateManyWithWhereWithoutPaymentMethodInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutPaymentMethodInput>
  }

  export type DepositUpsertWithWhereUniqueWithoutPaymentMethodInput = {
    where: DepositWhereUniqueInput
    update: XOR<DepositUpdateWithoutPaymentMethodInput, DepositUncheckedUpdateWithoutPaymentMethodInput>
    create: XOR<DepositCreateWithoutPaymentMethodInput, DepositUncheckedCreateWithoutPaymentMethodInput>
  }

  export type DepositUpdateWithWhereUniqueWithoutPaymentMethodInput = {
    where: DepositWhereUniqueInput
    data: XOR<DepositUpdateWithoutPaymentMethodInput, DepositUncheckedUpdateWithoutPaymentMethodInput>
  }

  export type DepositUpdateManyWithWhereWithoutPaymentMethodInput = {
    where: DepositScalarWhereInput
    data: XOR<DepositUpdateManyMutationInput, DepositUncheckedUpdateManyWithoutPaymentMethodInput>
  }

  export type DepositScalarWhereInput = {
    AND?: DepositScalarWhereInput | DepositScalarWhereInput[]
    OR?: DepositScalarWhereInput[]
    NOT?: DepositScalarWhereInput | DepositScalarWhereInput[]
    id?: StringFilter<"Deposit"> | string
    transactionId?: StringFilter<"Deposit"> | string
    paymentMethodId?: StringFilter<"Deposit"> | string
    amount?: DecimalFilter<"Deposit"> | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFilter<"Deposit"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Deposit"> | Decimal | DecimalJsLike | number | string
    providerTransactionId?: StringNullableFilter<"Deposit"> | string | null
    status?: StringFilter<"Deposit"> | string
    providerResponse?: JsonNullableFilter<"Deposit">
    processedAt?: DateTimeNullableFilter<"Deposit"> | Date | string | null
    createdAt?: DateTimeFilter<"Deposit"> | Date | string
    updatedAt?: DateTimeFilter<"Deposit"> | Date | string
  }

  export type WithdrawalUpsertWithWhereUniqueWithoutPaymentMethodInput = {
    where: WithdrawalWhereUniqueInput
    update: XOR<WithdrawalUpdateWithoutPaymentMethodInput, WithdrawalUncheckedUpdateWithoutPaymentMethodInput>
    create: XOR<WithdrawalCreateWithoutPaymentMethodInput, WithdrawalUncheckedCreateWithoutPaymentMethodInput>
  }

  export type WithdrawalUpdateWithWhereUniqueWithoutPaymentMethodInput = {
    where: WithdrawalWhereUniqueInput
    data: XOR<WithdrawalUpdateWithoutPaymentMethodInput, WithdrawalUncheckedUpdateWithoutPaymentMethodInput>
  }

  export type WithdrawalUpdateManyWithWhereWithoutPaymentMethodInput = {
    where: WithdrawalScalarWhereInput
    data: XOR<WithdrawalUpdateManyMutationInput, WithdrawalUncheckedUpdateManyWithoutPaymentMethodInput>
  }

  export type WithdrawalScalarWhereInput = {
    AND?: WithdrawalScalarWhereInput | WithdrawalScalarWhereInput[]
    OR?: WithdrawalScalarWhereInput[]
    NOT?: WithdrawalScalarWhereInput | WithdrawalScalarWhereInput[]
    id?: StringFilter<"Withdrawal"> | string
    transactionId?: StringFilter<"Withdrawal"> | string
    paymentMethodId?: StringFilter<"Withdrawal"> | string
    amount?: DecimalFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Withdrawal"> | string
    providerTransactionId?: StringNullableFilter<"Withdrawal"> | string | null
    providerResponse?: JsonNullableFilter<"Withdrawal">
    kycVerificationRequired?: BoolFilter<"Withdrawal"> | boolean
    requestedAt?: DateTimeFilter<"Withdrawal"> | Date | string
    processedAt?: DateTimeNullableFilter<"Withdrawal"> | Date | string | null
    createdAt?: DateTimeFilter<"Withdrawal"> | Date | string
    updatedAt?: DateTimeFilter<"Withdrawal"> | Date | string
  }

  export type TransactionCreateWithoutDepositInput = {
    id?: string
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    status?: string
    externalTransactionId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    user: UserCreateNestedOneWithoutTransactionsInput
    account: FinancialAccountCreateNestedOneWithoutTransactionsInput
    paymentMethod?: PaymentMethodCreateNestedOneWithoutTransactionsInput
    withdrawal?: WithdrawalCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutDepositInput = {
    id?: string
    userId: string
    accountId: string
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    status?: string
    paymentMethodId?: string | null
    externalTransactionId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    withdrawal?: WithdrawalUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutDepositInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutDepositInput, TransactionUncheckedCreateWithoutDepositInput>
  }

  export type PaymentMethodCreateWithoutDepositsInput = {
    id?: string
    paymentType: string
    provider: string
    tokenizedId: string
    last4Digits?: string | null
    expiryDate?: string | null
    billingAddress?: string | null
    isDefault?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentMethodsInput
    transactions?: TransactionCreateNestedManyWithoutPaymentMethodInput
    withdrawals?: WithdrawalCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUncheckedCreateWithoutDepositsInput = {
    id?: string
    userId: string
    paymentType: string
    provider: string
    tokenizedId: string
    last4Digits?: string | null
    expiryDate?: string | null
    billingAddress?: string | null
    isDefault?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutPaymentMethodInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodCreateOrConnectWithoutDepositsInput = {
    where: PaymentMethodWhereUniqueInput
    create: XOR<PaymentMethodCreateWithoutDepositsInput, PaymentMethodUncheckedCreateWithoutDepositsInput>
  }

  export type TransactionUpsertWithoutDepositInput = {
    update: XOR<TransactionUpdateWithoutDepositInput, TransactionUncheckedUpdateWithoutDepositInput>
    create: XOR<TransactionCreateWithoutDepositInput, TransactionUncheckedCreateWithoutDepositInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutDepositInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutDepositInput, TransactionUncheckedUpdateWithoutDepositInput>
  }

  export type TransactionUpdateWithoutDepositInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    account?: FinancialAccountUpdateOneRequiredWithoutTransactionsNestedInput
    paymentMethod?: PaymentMethodUpdateOneWithoutTransactionsNestedInput
    withdrawal?: WithdrawalUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutDepositInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawal?: WithdrawalUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type PaymentMethodUpsertWithoutDepositsInput = {
    update: XOR<PaymentMethodUpdateWithoutDepositsInput, PaymentMethodUncheckedUpdateWithoutDepositsInput>
    create: XOR<PaymentMethodCreateWithoutDepositsInput, PaymentMethodUncheckedCreateWithoutDepositsInput>
    where?: PaymentMethodWhereInput
  }

  export type PaymentMethodUpdateToOneWithWhereWithoutDepositsInput = {
    where?: PaymentMethodWhereInput
    data: XOR<PaymentMethodUpdateWithoutDepositsInput, PaymentMethodUncheckedUpdateWithoutDepositsInput>
  }

  export type PaymentMethodUpdateWithoutDepositsInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    tokenizedId?: StringFieldUpdateOperationsInput | string
    last4Digits?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentMethodsNestedInput
    transactions?: TransactionUpdateManyWithoutPaymentMethodNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodUncheckedUpdateWithoutDepositsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    tokenizedId?: StringFieldUpdateOperationsInput | string
    last4Digits?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutPaymentMethodNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutPaymentMethodNestedInput
  }

  export type TransactionCreateWithoutWithdrawalInput = {
    id?: string
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    status?: string
    externalTransactionId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    user: UserCreateNestedOneWithoutTransactionsInput
    account: FinancialAccountCreateNestedOneWithoutTransactionsInput
    paymentMethod?: PaymentMethodCreateNestedOneWithoutTransactionsInput
    deposit?: DepositCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutWithdrawalInput = {
    id?: string
    userId: string
    accountId: string
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    status?: string
    paymentMethodId?: string | null
    externalTransactionId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    deposit?: DepositUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutWithdrawalInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutWithdrawalInput, TransactionUncheckedCreateWithoutWithdrawalInput>
  }

  export type PaymentMethodCreateWithoutWithdrawalsInput = {
    id?: string
    paymentType: string
    provider: string
    tokenizedId: string
    last4Digits?: string | null
    expiryDate?: string | null
    billingAddress?: string | null
    isDefault?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentMethodsInput
    transactions?: TransactionCreateNestedManyWithoutPaymentMethodInput
    deposits?: DepositCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUncheckedCreateWithoutWithdrawalsInput = {
    id?: string
    userId: string
    paymentType: string
    provider: string
    tokenizedId: string
    last4Digits?: string | null
    expiryDate?: string | null
    billingAddress?: string | null
    isDefault?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutPaymentMethodInput
    deposits?: DepositUncheckedCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodCreateOrConnectWithoutWithdrawalsInput = {
    where: PaymentMethodWhereUniqueInput
    create: XOR<PaymentMethodCreateWithoutWithdrawalsInput, PaymentMethodUncheckedCreateWithoutWithdrawalsInput>
  }

  export type TransactionUpsertWithoutWithdrawalInput = {
    update: XOR<TransactionUpdateWithoutWithdrawalInput, TransactionUncheckedUpdateWithoutWithdrawalInput>
    create: XOR<TransactionCreateWithoutWithdrawalInput, TransactionUncheckedCreateWithoutWithdrawalInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutWithdrawalInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutWithdrawalInput, TransactionUncheckedUpdateWithoutWithdrawalInput>
  }

  export type TransactionUpdateWithoutWithdrawalInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    account?: FinancialAccountUpdateOneRequiredWithoutTransactionsNestedInput
    paymentMethod?: PaymentMethodUpdateOneWithoutTransactionsNestedInput
    deposit?: DepositUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutWithdrawalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposit?: DepositUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type PaymentMethodUpsertWithoutWithdrawalsInput = {
    update: XOR<PaymentMethodUpdateWithoutWithdrawalsInput, PaymentMethodUncheckedUpdateWithoutWithdrawalsInput>
    create: XOR<PaymentMethodCreateWithoutWithdrawalsInput, PaymentMethodUncheckedCreateWithoutWithdrawalsInput>
    where?: PaymentMethodWhereInput
  }

  export type PaymentMethodUpdateToOneWithWhereWithoutWithdrawalsInput = {
    where?: PaymentMethodWhereInput
    data: XOR<PaymentMethodUpdateWithoutWithdrawalsInput, PaymentMethodUncheckedUpdateWithoutWithdrawalsInput>
  }

  export type PaymentMethodUpdateWithoutWithdrawalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    tokenizedId?: StringFieldUpdateOperationsInput | string
    last4Digits?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentMethodsNestedInput
    transactions?: TransactionUpdateManyWithoutPaymentMethodNestedInput
    deposits?: DepositUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodUncheckedUpdateWithoutWithdrawalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    tokenizedId?: StringFieldUpdateOperationsInput | string
    last4Digits?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutPaymentMethodNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutPaymentMethodNestedInput
  }

  export type UserCreateWithoutFraudEventsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    password?: UserPasswordCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: GdprConsentCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFraudEventsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: GdprConsentUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFraudEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFraudEventsInput, UserUncheckedCreateWithoutFraudEventsInput>
  }

  export type UserUpsertWithoutFraudEventsInput = {
    update: XOR<UserUpdateWithoutFraudEventsInput, UserUncheckedUpdateWithoutFraudEventsInput>
    create: XOR<UserCreateWithoutFraudEventsInput, UserUncheckedCreateWithoutFraudEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFraudEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFraudEventsInput, UserUncheckedUpdateWithoutFraudEventsInput>
  }

  export type UserUpdateWithoutFraudEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    password?: UserPasswordUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFraudEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBettingPatternsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    password?: UserPasswordCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: GdprConsentCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBettingPatternsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: GdprConsentUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBettingPatternsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBettingPatternsInput, UserUncheckedCreateWithoutBettingPatternsInput>
  }

  export type UserUpsertWithoutBettingPatternsInput = {
    update: XOR<UserUpdateWithoutBettingPatternsInput, UserUncheckedUpdateWithoutBettingPatternsInput>
    create: XOR<UserCreateWithoutBettingPatternsInput, UserUncheckedCreateWithoutBettingPatternsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBettingPatternsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBettingPatternsInput, UserUncheckedUpdateWithoutBettingPatternsInput>
  }

  export type UserUpdateWithoutBettingPatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    password?: UserPasswordUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBettingPatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutActivityLogsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    password?: UserPasswordCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: GdprConsentCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivityLogsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventUncheckedCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: GdprConsentUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivityLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
  }

  export type UserUpsertWithoutActivityLogsInput = {
    update: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    password?: UserPasswordUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUncheckedUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDevicesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    password?: UserPasswordCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: GdprConsentCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDevicesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventUncheckedCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: GdprConsentUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDevicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
  }

  export type UserUpsertWithoutDevicesInput = {
    update: XOR<UserUpdateWithoutDevicesInput, UserUncheckedUpdateWithoutDevicesInput>
    create: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDevicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDevicesInput, UserUncheckedUpdateWithoutDevicesInput>
  }

  export type UserUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    password?: UserPasswordUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUncheckedUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    password?: UserPasswordCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: GdprConsentCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventUncheckedCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: GdprConsentUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    password?: UserPasswordUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUncheckedUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutConsentsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    password?: UserPasswordCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConsentsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventUncheckedCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConsentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConsentsInput, UserUncheckedCreateWithoutConsentsInput>
  }

  export type UserUpsertWithoutConsentsInput = {
    update: XOR<UserUpdateWithoutConsentsInput, UserUncheckedUpdateWithoutConsentsInput>
    create: XOR<UserCreateWithoutConsentsInput, UserUncheckedCreateWithoutConsentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConsentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConsentsInput, UserUncheckedUpdateWithoutConsentsInput>
  }

  export type UserUpdateWithoutConsentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    password?: UserPasswordUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConsentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUncheckedUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDeletionRequestsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    password?: UserPasswordCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: GdprConsentCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDeletionRequestsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventUncheckedCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: GdprConsentUncheckedCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDeletionRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeletionRequestsInput, UserUncheckedCreateWithoutDeletionRequestsInput>
  }

  export type UserUpsertWithoutDeletionRequestsInput = {
    update: XOR<UserUpdateWithoutDeletionRequestsInput, UserUncheckedUpdateWithoutDeletionRequestsInput>
    create: XOR<UserCreateWithoutDeletionRequestsInput, UserUncheckedCreateWithoutDeletionRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeletionRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeletionRequestsInput, UserUncheckedUpdateWithoutDeletionRequestsInput>
  }

  export type UserUpdateWithoutDeletionRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    password?: UserPasswordUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeletionRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUncheckedUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUncheckedUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutExportRequestsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    password?: UserPasswordCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: GdprConsentCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExportRequestsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventUncheckedCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: GdprConsentUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExportRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExportRequestsInput, UserUncheckedCreateWithoutExportRequestsInput>
  }

  export type UserUpsertWithoutExportRequestsInput = {
    update: XOR<UserUpdateWithoutExportRequestsInput, UserUncheckedUpdateWithoutExportRequestsInput>
    create: XOR<UserCreateWithoutExportRequestsInput, UserUncheckedCreateWithoutExportRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExportRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExportRequestsInput, UserUncheckedUpdateWithoutExportRequestsInput>
  }

  export type UserUpdateWithoutExportRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    password?: UserPasswordUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExportRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUncheckedUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSecurityAlertsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    password?: UserPasswordCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: GdprConsentCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSecurityAlertsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventUncheckedCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: GdprConsentUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSecurityAlertsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSecurityAlertsInput, UserUncheckedCreateWithoutSecurityAlertsInput>
  }

  export type UserUpsertWithoutSecurityAlertsInput = {
    update: XOR<UserUpdateWithoutSecurityAlertsInput, UserUncheckedUpdateWithoutSecurityAlertsInput>
    create: XOR<UserCreateWithoutSecurityAlertsInput, UserUncheckedCreateWithoutSecurityAlertsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSecurityAlertsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSecurityAlertsInput, UserUncheckedUpdateWithoutSecurityAlertsInput>
  }

  export type UserUpdateWithoutSecurityAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    password?: UserPasswordUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSecurityAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUncheckedUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserBonusCreateWithoutPromotionInput = {
    id?: string
    bonusAmount: Decimal | DecimalJsLike | number | string
    wageringRequirement: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBonusesInput
  }

  export type UserBonusUncheckedCreateWithoutPromotionInput = {
    id?: string
    userId: string
    bonusAmount: Decimal | DecimalJsLike | number | string
    wageringRequirement: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBonusCreateOrConnectWithoutPromotionInput = {
    where: UserBonusWhereUniqueInput
    create: XOR<UserBonusCreateWithoutPromotionInput, UserBonusUncheckedCreateWithoutPromotionInput>
  }

  export type UserBonusCreateManyPromotionInputEnvelope = {
    data: UserBonusCreateManyPromotionInput | UserBonusCreateManyPromotionInput[]
    skipDuplicates?: boolean
  }

  export type UserBonusUpsertWithWhereUniqueWithoutPromotionInput = {
    where: UserBonusWhereUniqueInput
    update: XOR<UserBonusUpdateWithoutPromotionInput, UserBonusUncheckedUpdateWithoutPromotionInput>
    create: XOR<UserBonusCreateWithoutPromotionInput, UserBonusUncheckedCreateWithoutPromotionInput>
  }

  export type UserBonusUpdateWithWhereUniqueWithoutPromotionInput = {
    where: UserBonusWhereUniqueInput
    data: XOR<UserBonusUpdateWithoutPromotionInput, UserBonusUncheckedUpdateWithoutPromotionInput>
  }

  export type UserBonusUpdateManyWithWhereWithoutPromotionInput = {
    where: UserBonusScalarWhereInput
    data: XOR<UserBonusUpdateManyMutationInput, UserBonusUncheckedUpdateManyWithoutPromotionInput>
  }

  export type UserCreateWithoutBonusesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    password?: UserPasswordCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: GdprConsentCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBonusesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventUncheckedCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: GdprConsentUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBonusesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBonusesInput, UserUncheckedCreateWithoutBonusesInput>
  }

  export type PromotionCreateWithoutUserBonusesInput = {
    id?: string
    name: string
    description?: string | null
    promotionType: string
    termsAndConditions?: string | null
    startDate: Date | string
    endDate: Date | string
    active?: boolean
    eligibilityCriteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionUncheckedCreateWithoutUserBonusesInput = {
    id?: string
    name: string
    description?: string | null
    promotionType: string
    termsAndConditions?: string | null
    startDate: Date | string
    endDate: Date | string
    active?: boolean
    eligibilityCriteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionCreateOrConnectWithoutUserBonusesInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutUserBonusesInput, PromotionUncheckedCreateWithoutUserBonusesInput>
  }

  export type UserUpsertWithoutBonusesInput = {
    update: XOR<UserUpdateWithoutBonusesInput, UserUncheckedUpdateWithoutBonusesInput>
    create: XOR<UserCreateWithoutBonusesInput, UserUncheckedCreateWithoutBonusesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBonusesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBonusesInput, UserUncheckedUpdateWithoutBonusesInput>
  }

  export type UserUpdateWithoutBonusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    password?: UserPasswordUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBonusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUncheckedUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PromotionUpsertWithoutUserBonusesInput = {
    update: XOR<PromotionUpdateWithoutUserBonusesInput, PromotionUncheckedUpdateWithoutUserBonusesInput>
    create: XOR<PromotionCreateWithoutUserBonusesInput, PromotionUncheckedCreateWithoutUserBonusesInput>
    where?: PromotionWhereInput
  }

  export type PromotionUpdateToOneWithWhereWithoutUserBonusesInput = {
    where?: PromotionWhereInput
    data: XOR<PromotionUpdateWithoutUserBonusesInput, PromotionUncheckedUpdateWithoutUserBonusesInput>
  }

  export type PromotionUpdateWithoutUserBonusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    promotionType?: StringFieldUpdateOperationsInput | string
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    eligibilityCriteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateWithoutUserBonusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    promotionType?: StringFieldUpdateOperationsInput | string
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    eligibilityCriteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetSelectionCreateWithoutCurrentOddsInput = {
    id?: string
    name: string
    odds: Decimal | DecimalJsLike | number | string
    status?: string
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    market: BetMarketCreateNestedOneWithoutSelectionsInput
    betSelections?: BetSelectionBetCreateNestedManyWithoutSelectionInput
    oddsSnapshots?: OddsSnapshotCreateNestedManyWithoutSelectionInput
  }

  export type BetSelectionUncheckedCreateWithoutCurrentOddsInput = {
    id?: string
    marketId: string
    name: string
    odds: Decimal | DecimalJsLike | number | string
    status?: string
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    betSelections?: BetSelectionBetUncheckedCreateNestedManyWithoutSelectionInput
    oddsSnapshots?: OddsSnapshotUncheckedCreateNestedManyWithoutSelectionInput
  }

  export type BetSelectionCreateOrConnectWithoutCurrentOddsInput = {
    where: BetSelectionWhereUniqueInput
    create: XOR<BetSelectionCreateWithoutCurrentOddsInput, BetSelectionUncheckedCreateWithoutCurrentOddsInput>
  }

  export type BetSelectionUpsertWithoutCurrentOddsInput = {
    update: XOR<BetSelectionUpdateWithoutCurrentOddsInput, BetSelectionUncheckedUpdateWithoutCurrentOddsInput>
    create: XOR<BetSelectionCreateWithoutCurrentOddsInput, BetSelectionUncheckedCreateWithoutCurrentOddsInput>
    where?: BetSelectionWhereInput
  }

  export type BetSelectionUpdateToOneWithWhereWithoutCurrentOddsInput = {
    where?: BetSelectionWhereInput
    data: XOR<BetSelectionUpdateWithoutCurrentOddsInput, BetSelectionUncheckedUpdateWithoutCurrentOddsInput>
  }

  export type BetSelectionUpdateWithoutCurrentOddsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    market?: BetMarketUpdateOneRequiredWithoutSelectionsNestedInput
    betSelections?: BetSelectionBetUpdateManyWithoutSelectionNestedInput
    oddsSnapshots?: OddsSnapshotUpdateManyWithoutSelectionNestedInput
  }

  export type BetSelectionUncheckedUpdateWithoutCurrentOddsInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    betSelections?: BetSelectionBetUncheckedUpdateManyWithoutSelectionNestedInput
    oddsSnapshots?: OddsSnapshotUncheckedUpdateManyWithoutSelectionNestedInput
  }

  export type BetSelectionCreateWithoutOddsSnapshotsInput = {
    id?: string
    name: string
    odds: Decimal | DecimalJsLike | number | string
    status?: string
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    market: BetMarketCreateNestedOneWithoutSelectionsInput
    betSelections?: BetSelectionBetCreateNestedManyWithoutSelectionInput
    currentOdds?: CurrentOddsCreateNestedOneWithoutSelectionInput
  }

  export type BetSelectionUncheckedCreateWithoutOddsSnapshotsInput = {
    id?: string
    marketId: string
    name: string
    odds: Decimal | DecimalJsLike | number | string
    status?: string
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    betSelections?: BetSelectionBetUncheckedCreateNestedManyWithoutSelectionInput
    currentOdds?: CurrentOddsUncheckedCreateNestedOneWithoutSelectionInput
  }

  export type BetSelectionCreateOrConnectWithoutOddsSnapshotsInput = {
    where: BetSelectionWhereUniqueInput
    create: XOR<BetSelectionCreateWithoutOddsSnapshotsInput, BetSelectionUncheckedCreateWithoutOddsSnapshotsInput>
  }

  export type BetSelectionUpsertWithoutOddsSnapshotsInput = {
    update: XOR<BetSelectionUpdateWithoutOddsSnapshotsInput, BetSelectionUncheckedUpdateWithoutOddsSnapshotsInput>
    create: XOR<BetSelectionCreateWithoutOddsSnapshotsInput, BetSelectionUncheckedCreateWithoutOddsSnapshotsInput>
    where?: BetSelectionWhereInput
  }

  export type BetSelectionUpdateToOneWithWhereWithoutOddsSnapshotsInput = {
    where?: BetSelectionWhereInput
    data: XOR<BetSelectionUpdateWithoutOddsSnapshotsInput, BetSelectionUncheckedUpdateWithoutOddsSnapshotsInput>
  }

  export type BetSelectionUpdateWithoutOddsSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    market?: BetMarketUpdateOneRequiredWithoutSelectionsNestedInput
    betSelections?: BetSelectionBetUpdateManyWithoutSelectionNestedInput
    currentOdds?: CurrentOddsUpdateOneWithoutSelectionNestedInput
  }

  export type BetSelectionUncheckedUpdateWithoutOddsSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    betSelections?: BetSelectionBetUncheckedUpdateManyWithoutSelectionNestedInput
    currentOdds?: CurrentOddsUncheckedUpdateOneWithoutSelectionNestedInput
  }

  export type GameCreateWithoutSyncStatusInput = {
    id?: string
    scheduledStartAt: Date | string
    actualStartAt?: Date | string | null
    status?: string
    homeScore?: number | null
    awayScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sport: SportCreateNestedOneWithoutGamesInput
    league: LeagueCreateNestedOneWithoutGamesInput
    homeTeam: TeamCreateNestedOneWithoutHomeGamesInput
    awayTeam: TeamCreateNestedOneWithoutAwayGamesInput
    markets?: BetMarketCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutSyncStatusInput = {
    id?: string
    sportId: string
    leagueId: string
    homeTeamId: string
    awayTeamId: string
    scheduledStartAt: Date | string
    actualStartAt?: Date | string | null
    status?: string
    homeScore?: number | null
    awayScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    markets?: BetMarketUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutSyncStatusInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutSyncStatusInput, GameUncheckedCreateWithoutSyncStatusInput>
  }

  export type GameUpsertWithoutSyncStatusInput = {
    update: XOR<GameUpdateWithoutSyncStatusInput, GameUncheckedUpdateWithoutSyncStatusInput>
    create: XOR<GameCreateWithoutSyncStatusInput, GameUncheckedCreateWithoutSyncStatusInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutSyncStatusInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutSyncStatusInput, GameUncheckedUpdateWithoutSyncStatusInput>
  }

  export type GameUpdateWithoutSyncStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: SportUpdateOneRequiredWithoutGamesNestedInput
    league?: LeagueUpdateOneRequiredWithoutGamesNestedInput
    homeTeam?: TeamUpdateOneRequiredWithoutHomeGamesNestedInput
    awayTeam?: TeamUpdateOneRequiredWithoutAwayGamesNestedInput
    markets?: BetMarketUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutSyncStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    sportId?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    homeTeamId?: StringFieldUpdateOperationsInput | string
    awayTeamId?: StringFieldUpdateOperationsInput | string
    scheduledStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    markets?: BetMarketUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    profile?: UserProfileCreateNestedOneWithoutUserInput
    password?: UserPasswordCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryCreateNestedManyWithoutUserInput
    consents?: GdprConsentCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    accountStatus?: string
    kycVerified?: boolean
    kycLevel?: string
    gdprConsentGiven?: boolean
    marketingConsent?: boolean
    riskScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedOneWithoutUserInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    financialAccounts?: FinancialAccountUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutUserInput
    fraudEvents?: FraudEventUncheckedCreateNestedManyWithoutUserInput
    bettingPatterns?: BettingPatternUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: AccountActivityLogUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceRegistryUncheckedCreateNestedManyWithoutUserInput
    consents?: GdprConsentUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    exportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    securityAlerts?: SecurityAlertUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    password?: UserPasswordUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: StringFieldUpdateOperationsInput | string
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycLevel?: StringFieldUpdateOperationsInput | string
    gdprConsentGiven?: BoolFieldUpdateOperationsInput | boolean
    marketingConsent?: BoolFieldUpdateOperationsInput | boolean
    riskScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateOneWithoutUserNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    financialAccounts?: FinancialAccountUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    fraudEvents?: FraudEventUncheckedUpdateManyWithoutUserNestedInput
    bettingPatterns?: BettingPatternUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: AccountActivityLogUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceRegistryUncheckedUpdateManyWithoutUserNestedInput
    consents?: GdprConsentUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    exportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    securityAlerts?: SecurityAlertUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type UserSessionCreateManyUserInput = {
    id?: string
    token: string
    deviceFingerprint: string
    ipAddressHash: string
    userAgent?: string | null
    lastActivityAt?: Date | string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
  }

  export type FinancialAccountCreateManyUserInput = {
    id?: string
    accountType?: string
    balance?: Decimal | DecimalJsLike | number | string
    availableBalance?: Decimal | DecimalJsLike | number | string
    lockedBalance?: Decimal | DecimalJsLike | number | string
    currency?: string
    lastTransactionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetCreateManyUserInput = {
    id?: string
    betType: string
    totalStake: Decimal | DecimalJsLike | number | string
    potentialPayout: Decimal | DecimalJsLike | number | string
    actualPayout?: Decimal | DecimalJsLike | number | string | null
    status?: string
    placedAt?: Date | string
    settledAt?: Date | string | null
    cashoutAt?: Date | string | null
    oddsSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: string
    accountId: string
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    status?: string
    paymentMethodId?: string | null
    externalTransactionId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type PaymentMethodCreateManyUserInput = {
    id?: string
    paymentType: string
    provider: string
    tokenizedId: string
    last4Digits?: string | null
    expiryDate?: string | null
    billingAddress?: string | null
    isDefault?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FraudEventCreateManyUserInput = {
    id?: string
    eventType: string
    severity: string
    riskScore: number
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type BettingPatternCreateManyUserInput = {
    id?: string
    patternType: string
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    detectedAt?: Date | string
    riskScore: number
    actionTaken?: string | null
  }

  export type AccountActivityLogCreateManyUserInput = {
    id?: string
    activityType: string
    ipAddressHash: string
    deviceFingerprint?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    userAgent?: string | null
    success: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DeviceRegistryCreateManyUserInput = {
    id?: string
    deviceFingerprint: string
    deviceName?: string | null
    deviceType?: string | null
    os?: string | null
    browser?: string | null
    trusted?: boolean
    blocked?: boolean
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    priority?: string
    title: string
    message: string
    read?: boolean
    dismissed?: boolean
    actionUrl?: string | null
    actionLabel?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type GdprConsentCreateManyUserInput = {
    id?: string
    consentType: string
    consentStatus: string
    consentMethod: string
    ipAddressHash?: string | null
    withdrawnAt?: Date | string | null
    createdAt?: Date | string
  }

  export type DataDeletionRequestCreateManyUserInput = {
    id?: string
    status?: string
    requestedAt?: Date | string
    processedAt?: Date | string | null
    rejectionReason?: string | null
    dataDeleted?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataExportRequestCreateManyUserInput = {
    id?: string
    status?: string
    exportFormat?: string
    filePath?: string | null
    expiresAt?: Date | string | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityAlertCreateManyUserInput = {
    id?: string
    alertType: string
    severity: string
    description?: string | null
    actionRequired?: string | null
    acknowledged?: boolean
    createdAt?: Date | string
  }

  export type UserBonusCreateManyUserInput = {
    id?: string
    promotionId: string
    bonusAmount: Decimal | DecimalJsLike | number | string
    wageringRequirement: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    ipAddressHash?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    lastTransactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
  }

  export type FinancialAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    lastTransactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type FinancialAccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    availableBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    lastTransactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    betType?: StringFieldUpdateOperationsInput | string
    totalStake?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    potentialPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualPayout?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    placedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oddsSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    selections?: BetSelectionBetUpdateManyWithoutBetNestedInput
  }

  export type BetUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    betType?: StringFieldUpdateOperationsInput | string
    totalStake?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    potentialPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualPayout?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    placedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oddsSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    selections?: BetSelectionBetUncheckedUpdateManyWithoutBetNestedInput
  }

  export type BetUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    betType?: StringFieldUpdateOperationsInput | string
    totalStake?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    potentialPayout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualPayout?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    placedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oddsSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: FinancialAccountUpdateOneRequiredWithoutTransactionsNestedInput
    paymentMethod?: PaymentMethodUpdateOneWithoutTransactionsNestedInput
    deposit?: DepositUpdateOneWithoutTransactionNestedInput
    withdrawal?: WithdrawalUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposit?: DepositUncheckedUpdateOneWithoutTransactionNestedInput
    withdrawal?: WithdrawalUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentMethodUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    tokenizedId?: StringFieldUpdateOperationsInput | string
    last4Digits?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutPaymentMethodNestedInput
    deposits?: DepositUpdateManyWithoutPaymentMethodNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    tokenizedId?: StringFieldUpdateOperationsInput | string
    last4Digits?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutPaymentMethodNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutPaymentMethodNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    tokenizedId?: StringFieldUpdateOperationsInput | string
    last4Digits?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FraudEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FraudEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FraudEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BettingPatternUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternType?: StringFieldUpdateOperationsInput | string
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskScore?: IntFieldUpdateOperationsInput | number
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BettingPatternUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternType?: StringFieldUpdateOperationsInput | string
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskScore?: IntFieldUpdateOperationsInput | number
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BettingPatternUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternType?: StringFieldUpdateOperationsInput | string
    patternDetails?: NullableJsonNullValueInput | InputJsonValue
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskScore?: IntFieldUpdateOperationsInput | number
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountActivityLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountActivityLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountActivityLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceRegistryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    trusted?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceRegistryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    trusted?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceRegistryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceFingerprint?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    trusted?: BoolFieldUpdateOperationsInput | boolean
    blocked?: BoolFieldUpdateOperationsInput | boolean
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    dismissed?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    dismissed?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    dismissed?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GdprConsentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentType?: StringFieldUpdateOperationsInput | string
    consentStatus?: StringFieldUpdateOperationsInput | string
    consentMethod?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GdprConsentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentType?: StringFieldUpdateOperationsInput | string
    consentStatus?: StringFieldUpdateOperationsInput | string
    consentMethod?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GdprConsentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentType?: StringFieldUpdateOperationsInput | string
    consentStatus?: StringFieldUpdateOperationsInput | string
    consentMethod?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataDeletionRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    dataDeleted?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataDeletionRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    dataDeleted?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataDeletionRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    dataDeleted?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataExportRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    exportFormat?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataExportRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    exportFormat?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataExportRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    exportFormat?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityAlertUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    actionRequired?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityAlertUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    actionRequired?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityAlertUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    actionRequired?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBonusUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageringRequirement?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promotion?: PromotionUpdateOneRequiredWithoutUserBonusesNestedInput
  }

  export type UserBonusUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    bonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageringRequirement?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBonusUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    bonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageringRequirement?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    ipAddressHash?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeagueCreateManySportInput = {
    id?: string
    name: string
    code: string
    country?: string | null
    region?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameCreateManySportInput = {
    id?: string
    leagueId: string
    homeTeamId: string
    awayTeamId: string
    scheduledStartAt: Date | string
    actualStartAt?: Date | string | null
    status?: string
    homeScore?: number | null
    awayScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeagueUpdateWithoutSportInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUpdateManyWithoutLeagueNestedInput
    games?: GameUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueUncheckedUpdateWithoutSportInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutLeagueNestedInput
    games?: GameUncheckedUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueUncheckedUpdateManyWithoutSportInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUpdateWithoutSportInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutGamesNestedInput
    homeTeam?: TeamUpdateOneRequiredWithoutHomeGamesNestedInput
    awayTeam?: TeamUpdateOneRequiredWithoutAwayGamesNestedInput
    markets?: BetMarketUpdateManyWithoutGameNestedInput
    syncStatus?: OddsSyncStatusUpdateOneWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutSportInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    homeTeamId?: StringFieldUpdateOperationsInput | string
    awayTeamId?: StringFieldUpdateOperationsInput | string
    scheduledStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    markets?: BetMarketUncheckedUpdateManyWithoutGameNestedInput
    syncStatus?: OddsSyncStatusUncheckedUpdateOneWithoutGameNestedInput
  }

  export type GameUncheckedUpdateManyWithoutSportInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    homeTeamId?: StringFieldUpdateOperationsInput | string
    awayTeamId?: StringFieldUpdateOperationsInput | string
    scheduledStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateManyLeagueInput = {
    id?: string
    name: string
    code: string
    logoUrl?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameCreateManyLeagueInput = {
    id?: string
    sportId: string
    homeTeamId: string
    awayTeamId: string
    scheduledStartAt: Date | string
    actualStartAt?: Date | string | null
    status?: string
    homeScore?: number | null
    awayScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    homeGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayGames?: GameUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    homeGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: SportUpdateOneRequiredWithoutGamesNestedInput
    homeTeam?: TeamUpdateOneRequiredWithoutHomeGamesNestedInput
    awayTeam?: TeamUpdateOneRequiredWithoutAwayGamesNestedInput
    markets?: BetMarketUpdateManyWithoutGameNestedInput
    syncStatus?: OddsSyncStatusUpdateOneWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    sportId?: StringFieldUpdateOperationsInput | string
    homeTeamId?: StringFieldUpdateOperationsInput | string
    awayTeamId?: StringFieldUpdateOperationsInput | string
    scheduledStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    markets?: BetMarketUncheckedUpdateManyWithoutGameNestedInput
    syncStatus?: OddsSyncStatusUncheckedUpdateOneWithoutGameNestedInput
  }

  export type GameUncheckedUpdateManyWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    sportId?: StringFieldUpdateOperationsInput | string
    homeTeamId?: StringFieldUpdateOperationsInput | string
    awayTeamId?: StringFieldUpdateOperationsInput | string
    scheduledStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCreateManyHomeTeamInput = {
    id?: string
    sportId: string
    leagueId: string
    awayTeamId: string
    scheduledStartAt: Date | string
    actualStartAt?: Date | string | null
    status?: string
    homeScore?: number | null
    awayScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameCreateManyAwayTeamInput = {
    id?: string
    sportId: string
    leagueId: string
    homeTeamId: string
    scheduledStartAt: Date | string
    actualStartAt?: Date | string | null
    status?: string
    homeScore?: number | null
    awayScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameUpdateWithoutHomeTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: SportUpdateOneRequiredWithoutGamesNestedInput
    league?: LeagueUpdateOneRequiredWithoutGamesNestedInput
    awayTeam?: TeamUpdateOneRequiredWithoutAwayGamesNestedInput
    markets?: BetMarketUpdateManyWithoutGameNestedInput
    syncStatus?: OddsSyncStatusUpdateOneWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutHomeTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    sportId?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    awayTeamId?: StringFieldUpdateOperationsInput | string
    scheduledStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    markets?: BetMarketUncheckedUpdateManyWithoutGameNestedInput
    syncStatus?: OddsSyncStatusUncheckedUpdateOneWithoutGameNestedInput
  }

  export type GameUncheckedUpdateManyWithoutHomeTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    sportId?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    awayTeamId?: StringFieldUpdateOperationsInput | string
    scheduledStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUpdateWithoutAwayTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: SportUpdateOneRequiredWithoutGamesNestedInput
    league?: LeagueUpdateOneRequiredWithoutGamesNestedInput
    homeTeam?: TeamUpdateOneRequiredWithoutHomeGamesNestedInput
    markets?: BetMarketUpdateManyWithoutGameNestedInput
    syncStatus?: OddsSyncStatusUpdateOneWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutAwayTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    sportId?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    homeTeamId?: StringFieldUpdateOperationsInput | string
    scheduledStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    markets?: BetMarketUncheckedUpdateManyWithoutGameNestedInput
    syncStatus?: OddsSyncStatusUncheckedUpdateOneWithoutGameNestedInput
  }

  export type GameUncheckedUpdateManyWithoutAwayTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    sportId?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    homeTeamId?: StringFieldUpdateOperationsInput | string
    scheduledStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    homeScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetMarketCreateManyGameInput = {
    id?: string
    marketType: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetMarketUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    selections?: BetSelectionUpdateManyWithoutMarketNestedInput
  }

  export type BetMarketUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    selections?: BetSelectionUncheckedUpdateManyWithoutMarketNestedInput
  }

  export type BetMarketUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetSelectionCreateManyMarketInput = {
    id?: string
    name: string
    odds: Decimal | DecimalJsLike | number | string
    status?: string
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetSelectionUpdateWithoutMarketInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    betSelections?: BetSelectionBetUpdateManyWithoutSelectionNestedInput
    currentOdds?: CurrentOddsUpdateOneWithoutSelectionNestedInput
    oddsSnapshots?: OddsSnapshotUpdateManyWithoutSelectionNestedInput
  }

  export type BetSelectionUncheckedUpdateWithoutMarketInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    betSelections?: BetSelectionBetUncheckedUpdateManyWithoutSelectionNestedInput
    currentOdds?: CurrentOddsUncheckedUpdateOneWithoutSelectionNestedInput
    oddsSnapshots?: OddsSnapshotUncheckedUpdateManyWithoutSelectionNestedInput
  }

  export type BetSelectionUncheckedUpdateManyWithoutMarketInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetSelectionBetCreateManySelectionInput = {
    id?: string
    betId: string
    oddsAtBet: Decimal | DecimalJsLike | number | string
    result?: string | null
    createdAt?: Date | string
  }

  export type OddsSnapshotCreateManySelectionInput = {
    id?: string
    odds: Decimal | DecimalJsLike | number | string
    timestamp?: Date | string
    source?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BetSelectionBetUpdateWithoutSelectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    oddsAtBet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bet?: BetUpdateOneRequiredWithoutSelectionsNestedInput
  }

  export type BetSelectionBetUncheckedUpdateWithoutSelectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    betId?: StringFieldUpdateOperationsInput | string
    oddsAtBet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetSelectionBetUncheckedUpdateManyWithoutSelectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    betId?: StringFieldUpdateOperationsInput | string
    oddsAtBet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OddsSnapshotUpdateWithoutSelectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OddsSnapshotUncheckedUpdateWithoutSelectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OddsSnapshotUncheckedUpdateManyWithoutSelectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BetSelectionBetCreateManyBetInput = {
    id?: string
    selectionId: string
    oddsAtBet: Decimal | DecimalJsLike | number | string
    result?: string | null
    createdAt?: Date | string
  }

  export type BetSelectionBetUpdateWithoutBetInput = {
    id?: StringFieldUpdateOperationsInput | string
    oddsAtBet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    selection?: BetSelectionUpdateOneRequiredWithoutBetSelectionsNestedInput
  }

  export type BetSelectionBetUncheckedUpdateWithoutBetInput = {
    id?: StringFieldUpdateOperationsInput | string
    selectionId?: StringFieldUpdateOperationsInput | string
    oddsAtBet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetSelectionBetUncheckedUpdateManyWithoutBetInput = {
    id?: StringFieldUpdateOperationsInput | string
    selectionId?: StringFieldUpdateOperationsInput | string
    oddsAtBet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyAccountInput = {
    id?: string
    userId: string
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    status?: string
    paymentMethodId?: string | null
    externalTransactionId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type TransactionUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    paymentMethod?: PaymentMethodUpdateOneWithoutTransactionsNestedInput
    deposit?: DepositUpdateOneWithoutTransactionNestedInput
    withdrawal?: WithdrawalUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposit?: DepositUncheckedUpdateOneWithoutTransactionNestedInput
    withdrawal?: WithdrawalUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionCreateManyPaymentMethodInput = {
    id?: string
    userId: string
    accountId: string
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    status?: string
    externalTransactionId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type DepositCreateManyPaymentMethodInput = {
    id?: string
    transactionId: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    providerTransactionId?: string | null
    status?: string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WithdrawalCreateManyPaymentMethodInput = {
    id?: string
    transactionId: string
    amount: Decimal | DecimalJsLike | number | string
    feeAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status?: string
    providerTransactionId?: string | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    kycVerificationRequired?: boolean
    requestedAt?: Date | string
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    account?: FinancialAccountUpdateOneRequiredWithoutTransactionsNestedInput
    deposit?: DepositUpdateOneWithoutTransactionNestedInput
    withdrawal?: WithdrawalUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposit?: DepositUncheckedUpdateOneWithoutTransactionNestedInput
    withdrawal?: WithdrawalUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DepositUpdateWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutDepositNestedInput
  }

  export type DepositUncheckedUpdateWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositUncheckedUpdateManyWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WithdrawalUpdateWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    kycVerificationRequired?: BoolFieldUpdateOperationsInput | boolean
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutWithdrawalNestedInput
  }

  export type WithdrawalUncheckedUpdateWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    kycVerificationRequired?: BoolFieldUpdateOperationsInput | boolean
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WithdrawalUncheckedUpdateManyWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    kycVerificationRequired?: BoolFieldUpdateOperationsInput | boolean
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBonusCreateManyPromotionInput = {
    id?: string
    userId: string
    bonusAmount: Decimal | DecimalJsLike | number | string
    wageringRequirement: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    status?: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBonusUpdateWithoutPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    bonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageringRequirement?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBonusesNestedInput
  }

  export type UserBonusUncheckedUpdateWithoutPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageringRequirement?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBonusUncheckedUpdateManyWithoutPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageringRequirement?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}